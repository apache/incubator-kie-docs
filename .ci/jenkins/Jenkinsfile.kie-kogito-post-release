import org.jenkinsci.plugins.workflow.libs.Library
@Library('jenkins-pipeline-shared-libraries')_

import org.kie.jenkins.MavenCommand

docsRepo = "kie-docs"
commitMsg = "Bumped up kogito-docs version in kie-docs"


pipeline {

    agent {
        label 'kie-rhel8 && !built-in'
    }

    options{
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
    }

    tools {
        maven "${BUILD_MAVEN_TOOL}"
        jdk "${BUILD_JDK_TOOL}"
    }

    environment {
        // Static env is defined into .jenkins/dsl/jobs.groovy file
        KOGITO_CI_EMAIL_TO = credentials("${JENKINS_EMAIL_CREDS_ID}")
        PR_BRANCH = "bump-up-kie-kogito-docs-${util.generateHash(10)}"
    }

    stages{
        stage('CleanWorkspace') {
            steps {
                cleanWs()
            }
        }
        stage('Initialize') {
            steps{
                script{
                    sh 'printenv'
                    dir(docsRepo){
                        checkoutRepo(docsRepo, GIT_AUTHOR, getDocsRepoBranch(), GIT_AUTHOR_CREDENTIALS_ID)
                    }
                }
            }
        }
        stage('Create pull request branch') {
            steps{
                script{
                    dir(docsRepo){
                        githubscm.createBranch(PR_BRANCH)
                    }
                }
            }
        }
        stage('Update kogito-docs version in kie-docs') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        maven.mvnVersionsSet(parseVersion(getKogitoDocsVersion()))
                        if (githubscm.isThereAnyChanges()){
                            githubscm.commitChanges(commitMsg)
                        }
                    }
                }
            }
        }
        stage('Create tag') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        githubscm.tagRepository("${getKogitoDocsVersion()}-kogito")
                    }
                }
            }
        }
        stage('Build kie-docs/doc-content/kogito-docs') {
            steps {
                configFileProvider([configFile(fileId: '771ff52a-a8b4-40e6-9b22-d54c7314aa1e', variable: 'SETTINGS_XML_FILE')]) {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        sh""" 
                            mvn clean install -Dfull -s "$SETTINGS_XML_FILE" -Dkie.maven.settings.custom="$SETTINGS_XML_FILE" -Dmaven.test.redirectTestOutputToFile=true -Dmaven.test.failure.ignore=true
                            # clean files created by the build
                            git clean -d -f 
                        """
                    }
                }
            }
        }
        stage('Push the tag') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        githubscm.pushRemoteTag('origin', "${getKogitoDocsVersion()}-kogito")
                    }
                }
            }
        }
        stage('Upload kie-kogito-docs to filemgmt') {
            steps {
                sshagent(credentials: ['KogitoDocsUpload']) {
                    script {
                        dir("${docsRepo}/doc-content/kogito-docs") {
                            sh "../../script/uploadDocs.sh ${getSshPath()} ${getRsyncPath()} ${getKogitoDocsVersion()}"
                        }
                    }
                }
            }
        }
        stage('Bump up kie-kogito-docs to next SNAPSHOT'){
            steps{
                dir("${docsRepo}/doc-content/kogito-docs") {
                    script{
                        maven.mvnVersionsSet(util.getNextVersion(getKogitoDocsVersion(), 'minor'))
                        if ( isNewVersionRequired() ) {
                            // bump up if the current kie-version on main branch is greater then the kie-version on main-kogito branch
                            maven.mvnVersionsUpdateParentAndChildModules("${getKieVersion()}", true)
                        }
                    }
                }
            }
        }
        stage('Push changes to main-kogito branch'){
            steps{
                dir("${docsRepo}"){
                    script{
                        // Add changed files, commit, open and merge PR
                        String prLink = commitAndCreatePR(commitMsg, PR_BRANCH, getDocsRepoBranch())
                        sh "git checkout ${getDocsRepoBranch()}"
                        mergeAndPush(prLink, getDocsRepoBranch())
                        githubscm.removeRemoteBranch('origin', PR_BRANCH, getGitAuthorCredsId())  
                    }
                }
            }
        }
    }
    post {
        always {
            cleanWs()
        }
        unsuccessful {
            sendErrorNotification()
        }
    }
}

void checkoutRepo(String repo, String GIT_AUTHOR, String branch, String GIT_AUTHOR_CREDENTIALS_ID){
    checkout(githubscm.resolveRepository(repo, GIT_AUTHOR, branch, false, GIT_AUTHOR_CREDENTIALS_ID))
    // need to manually checkout branch since on a detached branch after checkout command
    sh "git checkout ${branch}"
}

String getKogitoDocsVersion(){
    return params.KOGITO_DOCS_VERSION
}

String getKieVersion(){
    return params.KIE_VERSION
}

String getSshPath(){
    return env.SSH_KOGITO_DOCS_PATH
}

String getRsyncPath(){
    return env.RSYNC_KOGITO_DOCS_PATH
}

String getDocsRepoBranch(){
    return env.KIE_DOCS_BRANCH
}

void sendNotification(String body){
    emailext body: "${body}",
             subject: "Update kie-docs/kogito-docs",
             to: env.KOGITO_CI_EMAIL_TO
}

boolean isNewVersionRequired() {
    return params.BUMP_UP
}

String getGitAuthorCredsId() {
    return env.GIT_AUTHOR_CREDENTIALS_ID
}

void sendErrorNotification(){
    sendNotification("Job #${BUILD_NUMBER} was: **${currentBuild.currentResult}**\nPlease look here: ${BUILD_URL}")
}

String parseVersion(String docVersion){
    Integer[] versionSplit = util.parseVersion(docVersion)
    return "${versionSplit[0]}.${versionSplit[1]}.${versionSplit[2]}"
}

void mergeAndPush(String prLink, String targetBranch) {
    if (prLink?.trim()) {
        githubscm.mergePR(prLink, getGitAuthorCredsId())
        githubscm.pushObject('origin', targetBranch, getGitAuthorCredsId())
    }
}

String commitAndCreatePR(String commitMsg, String localBranch, String targetBranch) {
    def prBody = "Generated by build ${BUILD_TAG}: ${BUILD_URL}"
    githubscm.commitChanges(commitMsg)
    githubscm.pushObject('origin', localBranch, getGitAuthorCredsId())
    return githubscm.createPR(commitMsg, prBody, targetBranch, getGitAuthorCredsId())
}