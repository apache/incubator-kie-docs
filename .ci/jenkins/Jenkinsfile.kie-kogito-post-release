import org.jenkinsci.plugins.workflow.libs.Library
@Library('jenkins-pipeline-shared-libraries')_

import org.kie.jenkins.MavenCommand

docsRepo = "kie-docs"
commitMsg = "Bumped up kogito-docs version in kie-docs"


pipeline {

    agent {
        docker { 
            image env.AGENT_DOCKER_BUILDER_IMAGE
            args env.AGENT_DOCKER_BUILDER_ARGS
        }
    }

    options{
        timestamps()
        timeout(time: 60, unit: 'MINUTES')
    }

    environment {
        // Static env is defined into .jenkins/dsl/jobs.groovy file
        KOGITO_CI_EMAIL_TO = credentials("${JENKINS_EMAIL_CREDS_ID}")
        PR_BRANCH = "bump-up-kie-kogito-docs-${util.generateHash(10)}"
    }

    stages{
        stage('CleanWorkspace') {
            steps {
                cleanWs(disableDeferredWipeout: true)
            }
        }
        stage('Initialize') {
            steps{
                script{
                    sh 'printenv'
                    dir(docsRepo){
                        checkoutRepo(docsRepo, GIT_AUTHOR, getDocsRepoBranch(), getGitAuthorCredsId())
                    }
                }
            }
        }
        stage('Create pull request branch') {
            steps{
                script{
                    dir(docsRepo){
                        githubscm.createBranch(PR_BRANCH)
                    }
                }
            }
        }
        stage('Update param COMMUNITY_VERSION') {
            steps {
                script {
                    dir("${docsRepo}/_artifacts") {
                        def communityVersion=parseCommunityVersion(getKogitoDocsVersion())
                        sh "sed -i '0,/:COMMUNITY_VERSION:.*/s//:COMMUNITY_VERSION: ${communityVersion}/' \'document-attributes.adoc\' "
                        sh 'head -n20 document-attributes.adoc'
                    }
                }
            }
        }
        stage('Update number of kogito & tooling release notes') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs/src/main/asciidoc/release-notes") {
                        def kogito_release_number = getKogitoReleaseNumber()
                        def tooling_release_number = getToolingReleaseNumber()
                        def tooling_version = getToolingVersion()
                        sh "sed -i '0,/.*\\*.*projectId=12322421&version=.*\\[{PRODUCT} {COMMUNITY_VERSION_FINAL}\\]/s//\\* https:\\/\\/issues.redhat.com\\/secure\\/ReleaseNote.jspa\\?projectId=12322421\\&version=${kogito_release_number}\\[{PRODUCT} {COMMUNITY_VERSION_FINAL}\\]/' chap-kogito-release-notes.adoc"
                        sh "sed -i '0,/.*\\*\\*.*projectId=12322421&version=.*\\[{PRODUCT} tooling .*\\]/s//\\*\\* https:\\/\\/issues.redhat.com\\/secure\\/ReleaseNote.jspa\\?projectId=12322421\\&version=${tooling_release_number}\\[{PRODUCT} tooling ${tooling_version}\\]/' chap-kogito-release-notes.adoc"
                        sh 'head -n20 chap-kogito-release-notes.adoc'
                    }
                }
            }
        }
        stage('Update kogito-docs version in kie-docs') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        maven.mvnVersionsSet(parseVersion(getKogitoDocsVersion()))
                        if (githubscm.isThereAnyChanges()){
                            githubscm.setUserConfigFromCreds(getGitAuthorPushCredsId())
                            githubscm.commitChanges(commitMsg)
                        }
                    }
                }
            }
        }
        stage('Create tag') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        githubscm.tagRepository("${getKogitoDocsVersion()}-kogito")
                    }
                }
            }
        }
        stage('Build kie-docs/doc-content/kogito-docs') {
            steps {
                configFileProvider([configFile(fileId: '771ff52a-a8b4-40e6-9b22-d54c7314aa1e', variable: 'SETTINGS_XML_FILE')]) {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        sh""" 
                            mvn clean install -Dfull -s "$SETTINGS_XML_FILE" -Dkie.maven.settings.custom="$SETTINGS_XML_FILE" -Dmaven.test.redirectTestOutputToFile=true -Dmaven.test.failure.ignore=true
                            # clean files created by the build
                            git clean -d -f
                            head -n30 pom.xml
                        """
                    }
                }
            }
        }
        stage('Push the tag') {
            steps {
                script {
                    dir("${docsRepo}/doc-content/kogito-docs") {
                        githubscm.pushRemoteTag('origin', "${getKogitoDocsVersion()}-kogito", getGitAuthorPushCredsId())
                    }
                }
            }
        }
        stage('Upload kie-kogito-docs to filemgmt') {
            steps {
                sshagent(credentials: ['KogitoDocsUpload']) {
                    script {
                        dir("${docsRepo}/doc-content/kogito-docs") {
                            sh "../../script/uploadDocs.sh ${getSshPath()} ${getRsyncPath()} ${getKogitoDocsVersion()}"
                        }
                    }
                }
            }
        }
        stage('Bump up kie-kogito-docs to next SNAPSHOT'){
            steps{
                dir("${docsRepo}/doc-content/kogito-docs") {
                    script{
                        maven.mvnVersionsSet(util.getNextVersion(getKogitoDocsVersion(), 'minor'))
                        if ( isNewVersionRequired() ) {
                            // bump up if the current kie-version on main branch is greater then the kie-version on main-kogito branch
                            maven.mvnVersionsUpdateParentAndChildModules("${getKieVersion()}", true)
                        }
                        sh 'head -n30 pom.xml'
                    }
                }
            }
        }
        stage('Push changes to main-kogito branch'){
            steps{
                dir("${docsRepo}"){
                    script{
                        // Add changed files, commit, open and merge PR
                        String prLink = commitAndCreatePR(commitMsg, PR_BRANCH, getDocsRepoBranch())
                        sh "git checkout ${getDocsRepoBranch()}"
                        mergeAndPush(prLink, getDocsRepoBranch())
                        githubscm.removeRemoteBranch('origin', PR_BRANCH, getGitAuthorPushCredsId())
                    }
                }
            }
        }
    }
    post {
        cleanup {
            cleanWs()
        }
        unsuccessful {
            sendErrorNotification()
        }
    }
}

void checkoutRepo(String repo, String gitAuthor, String branch, String credsId) {
    checkout(githubscm.resolveRepository(repo, gitAuthor, branch, false, credsId))
    // need to manually checkout branch since on a detached branch after checkout command
    sh "git checkout ${branch}"
}

String getKogitoDocsVersion() {
    return params.KOGITO_DOCS_VERSION
}

String getKieVersion() {
    return params.KIE_VERSION
}

String getKogitoReleaseNumber(){
    return params.KOGITO_RELEASE_NUMBER
}

String getToolingReleaseNumber(){
    return params.TOOLING_RELEASE_NUMBER
}

String getToolingVersion(){
    return params.KOGITO_TOOLING_VERSION
}

String getSshPath() {
    return env.SSH_KOGITO_DOCS_PATH
}

String getRsyncPath() {
    return env.RSYNC_KOGITO_DOCS_PATH
}

String getDocsRepoBranch() {
    return env.KIE_DOCS_BRANCH
}

void sendNotification(String body) {
    emailext body: "${body}",
             subject: "Update kie-docs/kogito-docs",
             to: env.KOGITO_CI_EMAIL_TO
}

boolean isNewVersionRequired() {
    return params.BUMP_UP
}

String getGitAuthorCredsId() {
    return env.GIT_AUTHOR_CREDS_ID
}

String getGitAuthorPushCredsId() {
    return env.GIT_AUTHOR_PUSH_CREDS_ID
}

void sendErrorNotification() {
    sendNotification("Job #${BUILD_NUMBER} was: **${currentBuild.currentResult}**\nPlease look here: ${BUILD_URL}")
}

String parseVersion(String docVersion) {
    Integer[] versionSplit = util.parseVersion(docVersion)
    return "${versionSplit[0]}.${versionSplit[1]}.${versionSplit[2]}"
}

String parseCommunityVersion(String docVersion) {
    Integer[] versionSplit = util.parseVersion(docVersion)
    return "${versionSplit[0]}.${versionSplit[1]}"
}

void mergeAndPush(String prLink, String targetBranch) {
    if (prLink?.trim()) {
        githubscm.mergePR(prLink, getGitAuthorPushCredsId())
        githubscm.pushObject('origin', targetBranch, getGitAuthorPushCredsId())
    }
}

String commitAndCreatePR(String commitMsg, String localBranch, String targetBranch) {
    def prBody = "Generated by build ${BUILD_TAG}: ${BUILD_URL}"
    githubscm.setUserConfigFromCreds(getGitAuthorPushCredsId())
    githubscm.commitChanges(commitMsg)
    githubscm.pushObject('origin', localBranch, getGitAuthorPushCredsId())
    return githubscm.createPR(commitMsg, prBody, targetBranch, getGitAuthorPushCredsId())
}