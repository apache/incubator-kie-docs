<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Apache Camel Integration</title>

  <para></para>

  <section>
    <title>Introduction</title>

    <para>The Apache Camel integration allow us interact with a Drools
    Stateless or Stateful session through a pipeline. It simple works
    transforming XML commands into executable commands and executing them. The
    advantage of this integration is that Apache Camel brings the possibility
    to implement more advanced enterprise integration patterns than a simple
    transformation pipeline. This integration with Drools allow us to add any
    of the current Camel components. Using any of the Apache Components you
    could, for example, execute commands thats come an a JMS queue/Atom
    Feed/Mina connection/a Mail/etc and send the execution result to any type
    of supported components. As you can see, this brings a more powerful
    connection scenario to implement Drools.</para>

    <para></para>

    <section>
      <title>Architecture</title>

      <para>&lt;insert cool architecture graphic here&gt;</para>

      <para></para>
    </section>

    <section>
      <title>Introduction to drools-grid</title>

      <para>Camel integration is coupled with another drools module called:
      drools-grid. This module allow us to interact with Drools sessions
      independent of the JVM location. At this moment we can use two
      implementations:</para>

      <table>
        <title>drools-grid implementations</title>

        <tgroup cols="2">
          <tbody>
            <row>
              <entry>Local</entry>

              <entry>used when the drools session's and client's are in the
              same JVM.</entry>
            </row>

            <row>
              <entry>Remote</entry>

              <entry>used when you've drools session's on a remote JVM. At
              this moment is the only implementation is using Apache Min, but
              we're going to add HornetQ support in the next release.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para></para>

      <para>Drools Grid is embedded inside the Drools Camel component, so
      don't worry about more implementation information because this should be
      enough. With this information we can start to configure our Camel
      Context.</para>

      <para></para>
    </section>
  </section>

  <section>
    <title>Creating our Camel Context</title>

    <para>We need to create our own CamelContext to start. The first thing
    that we should do is create and register the grid node that we are going
    to use inside the CamelContext. In the most common cases we need to
    implement the Local grid connection. The next step after the
    LocalConnection creation is get a new ExecutionNode and register this
    inside the CamelContext.</para>

    <programlisting>
    LocalConnection connection = new LocalConnection();
    ExecutionNode node = connection.getExecutionNode();
    node.setId("sm");
    Context jndiContext = new JndiContext();
    jndiContext.bind("sm", node);
    CamelContext camelContext = new DefaultCamelContext(jndiContext);
    </programlisting>

    <para>After all this code now we have a properly configured CamelContext
    with all the configuration to use the DroolsComponent. But isn't ready yet
    to execute Drools, there're another steps left to reach that.</para>
  </section>

  <section>
    <title>Registering our KnowledgeSession</title>

    <para>Once you've your CamelContext configured is necesary register all
    the KnowledgeSession's that you are going to use inside the
    ExecutionNode.</para>

    <programlisting>
       node.get(DirectoryLookupFactoryService.class).register("ksession1", ksession);
    </programlisting>

    <para></para>
  </section>

  <section>
    <title>Camel Routes creation</title>

    <para>This is the most powerful feature of this integration because Camel
    bring us a very large Components library that we can use to create our
    pipelines. In this section</para>

    <note>
      <para>A Camel Component is a factory of Endpoint instances</para>
    </note>

    <para>The declaration of a Drools Endpoint need a few parameters, that we
    can see next:</para>

    <para>drools:{0}/{1}?dataFormat={2}</para>

    <para>{0} : Execution Node identifier that was registered in the
    CamelContext</para>

    <para>{1} : Knowledge Session identifier that was registered in the
    Execution Node with identifier {0}</para>

    <para>{2} : XML command transformer that is going to be used. At this
    moment we have two implementations: drools-xstream &amp;
    drools-jaxb</para>

    <para></para>

    <para>The most important thing in this section is know how create your
    Drools Endpoint, so what is best that having a example:
    
    <programlisting>
    RouteBuilder rb = new RouteBuilder() { 
    	public void configure() throws Exception {
   			from("direct:with-session-xstream").to("drools:sm/ksession1?dataFormat=drools-xstream");
    } };
    camelContext.addRoutes(rb);
    </programlisting>
    </para>
  </section>

  <section>
    <title>Executing commands with JAXB</title>

    <para></para>
  </section>

  <section>
    <title>Executing commands with XStream</title>

    <para></para>
  </section>
</chapter>
