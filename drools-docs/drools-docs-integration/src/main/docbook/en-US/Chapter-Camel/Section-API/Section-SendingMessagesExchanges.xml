<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="../../" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>Sending messages exchanges</title>

  <para>In order to send messages to a Camel Endpoint we need to create a
  <link
  xlink:href="http://camel.apache.org/producertemplate.html">ProducerTemplate</link></para>

  <programlisting role="JAVA">ProducerTemplate template = camelContext.createProducerTemplate();</programlisting>

  <para>After you have a template, you can start to send message exchange to
  your route:</para>

  <programlisting role="JAVA">String xml = "&lt;xml&gt;example&lt;/xml&gt;";
template.requestBody("direct:with-session-xstream", xml);</programlisting>

  <note>
    <para>When we use commands created with JAXB we need to use a special
    method to send the JaxbContext to our route. This will be explained in
    more detail in the Using JAXB section.</para>
  </note>

  <para></para>

  <section>
    <title>Using XStream</title>

    <para>Using XStream To create XML commands with XStream we use the
    BatchExecutionHelper. The steps are the following:</para>

    <orderedlist>
      <listitem>
        <para>BatchExecutionCommand marshalling</para>

        <para>String xml =
        BatchExecutionHelper.newXStreamMarshaller().toXML(batchExecutionCommand);</para>
      </listitem>

      <listitem>
        <para>Sending the commands through the ProducerTemplate</para>

        <para>String xmlOutput = new
        String((byte[])template.requestBody("direct:test-with-session",
        xml)</para>
      </listitem>

      <listitem>
        <para>Transforming the Drools Endpoint XML response into a
        ExecutionResults instance</para>

        <para>ExecutionResults result = (ExecutionResults)
        BatchExecutionHelper.newXStreamMarshaller().fromXML(xmlOutput);</para>
      </listitem>
    </orderedlist>

    <para></para>
  </section>

  <section>
    <title>Using JAXB</title>

    <para>JAXB is more powerful because it allows us to define our model in a
    XSD file, making it unnecessary to duplicate our Java model, or even
    create a Java model in our project. In this case we need to send the
    JAXBContext with our XML command.</para>

    <para>You can use XSD files to represent your fact model inside a
    KnowledgeBuilder. In the following example we are going to use a POJO Java
    model and a XSD to duplicate the same model representation.</para>

    <para></para>

    <orderedlist>
      <listitem>
        <para>JAXBContext creation:</para>

        <para>Here we are adding our XSD model definition to our
        KnowledgeBuilder as a resource</para>

        <programlisting role="JAVA">Options xjcOpts = new Options();
xjcOpts.setSchemaLanguage( Language.XMLSCHEMA );
JaxbConfiguration jaxbConfiguration = KnowledgeBuilderFactory.newJaxbConfiguration( xjcOpts, "xsd" );
kbuilder.add( ResourceFactory.newClassPathResource("person.xsd", getClass()), ResourceType.XSD, jaxbConfiguration);</programlisting>
        <para>Then
        you need to add your knowledge resources into the kbuilder and create
        your KnowledgeBase. These steps are the same as those in the Drools
        Expert documentation. Finally, we are going to create the
        JAXBContext</para>

        <programlisting role="JAVA">// Add object model to classes array
List&lt;String&gt; classesName = new ArrayList&lt;String&gt;();
classesName.add("org.drools.model.AddressType");
classesName.add("org.drools.model.ObjectFactory");
classesName.add("org.drools.model.Person");

try {
   jaxbContext = KnowledgeBuilderHelper.newJAXBContext( classesName.toArray(new String[classesName.size()]), kbase );
}
catch (Exception e) {
   LOG.info("Errors while creating JAXB Context.", e);
   throw new RuntimeException(e);
}</programlisting>
      </listitem>

      <listitem>
        <para>BatchExecutionCommand marshalling</para>
        <programlisting role="JAVA">StringWriter xmlReq = new StringWriter();
Marshaller marshaller = jaxbContext.createMarshaller();
marshaller.setProperty("jaxb.formatted.output", true);
marshaller.marshal(batchExecutionCommand, xmlReq);</programlisting>
      </listitem>

      <listitem>
        <para>Sending the commands through the ProducerTemplate</para>

        <para>In this step we need to use another ProducerTemplate method
        called requestBodyAndHeader() because the Drools Component needs to
        know which JAXBContext must use to unmarshall the XML.</para>

        <programlisting role="JAVA">String xml = xmlReq.toString();
byte[] xmlOutput = (byte[]) template.requestBodyAndHeader("direct:test-with-session", xmlReq.toString(), "jaxb-context", jaxbContext);</programlisting>
      </listitem>

      <listitem>
        <para>Transforming the Drools Endpoint XML response to
        ExecutionResults</para>

        <para>And the final step is to convert the XML output to an
        ExecutionResults instance</para>

        <programlisting role="JAVA">ExecutionResults resp = (ExecutionResults) jaxbContext.createUnmarshaller().unmarshal(new ByteArrayInputStream(xmlOutput));</programlisting>
      </listitem>
    </orderedlist>

    <para></para>

    <note>
      The XML output conversion is not required, but is recommended to have a more legible data output. 
    </note>

    <para></para>
  </section>
</section>
