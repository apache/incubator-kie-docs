<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
                    xmlns:xlink="http://www.w3.org/1999/xlink"
                    xmlns:xi="http://www.w3.org/2001/XInclude"
                    xmlns:svg="http://www.w3.org/2000/svg"
                    xmlns:m="http://www.w3.org/1998/Math/MathML"
                    xmlns:html="http://www.w3.org/1999/xhtml"
                    xmlns:db="http://docbook.org/ns/docbook" xml:base="./">

  <title>Drools Flow API</title>

  <section>
    <title>Knowledge Base</title>

    <para>Our knowledge-based API allows you to first create a knowledge base
    that contains all the necessary knowledge.  This includes of course all the
    relevant process definitions, but also other knowledge types like rules.  The
    following code snippet shows how to create a knowledge base consisting of only
    one process definition: use a knowledge builder to add a resource, check for
    errors and create the knowledge base.</para>

<programlisting>
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
kbuilder.add(ResourceFactory.newClassPathResource("ruleflow.rf"), ResourceType.DRF);
KnowledgeBuilderErrors errors = kbuilder.getErrors();
if (errors.size() > 0) {
  for (KnowledgeBuilderError error: errors) {
    System.err.println(error);
  }
  throw new IllegalArgumentException("Could not parse knowledge.");
}
KnowledgeBase kbase = KnowledgeBaseFactory.newKnowledgeBase();
kbase.addKnowledgePackages(kbuilder.getKnowledgePackages());
</programlisting>

    <para>Note that the knowledge-based API allows users to add different types of
    resources (e.g. rules and processes) in almost identical ways into the same
    knowledge base.  This allows user that know how to user Drools Flow to start using
    Expert of Fusion (and even integrate these different types of knowledge) almost
    instantaniously.</para>

  </section>

  <section>
    <title>Session</title>

    <para>Next, you should create a session to interact with the engine.  Again, the
    API is knowledge-based, supporting different types of knowledge, with a specific
    extension for each knowledge type.  The following code snippet shows how easy it
    is to create a session based on the earlier created knowledge base and start a
    process.</para>

<programlisting>
StatefulKnowledgeSession ksession = kbase.newStatefulKnowledgeSession();
ProcessInstance processInstance = ksession.startProcess("com.sample.ruleflow");
</programlisting>

    <para>The ProcessRuntime interface defines all the methods on the session for
    interacting with processes, as shown below.  Check out the JavaDocs to get a detailed
    explanation for each of the methods.</para>

<programlisting>
ProcessInstance startProcess(String processId);
ProcessInstance startProcess(String processId, Map&lt;String, Object&gt; parameters);
void signalEvent(String type, Object event);
Collection&lt;ProcessInstance&gt; getProcessInstances();
ProcessInstance getProcessInstance(long id);
WorkItemManager getWorkItemManager();
</programlisting>

  </section>

  <section>
    <title>Events</title>

    <para>Both the stateful and stateless knowledge session provide methods for
    registering (and removing) listeners.  ProcessEventListeners can be used to
    listen to process-related events, like starting or completing a processes and
    triggering and leaving a node.  Below the different methods of a
    ProcessEventListener are shown.  The event object provides access to related
    information like the process instance and/or node instance linked to the event.
    </para>

<programlisting>
public interface ProcessEventListener {

  void beforeProcessStarted(ProcessStartedEvent event);
  void afterProcessStarted(ProcessStartedEvent event);
  void beforeProcessCompleted(ProcessCompletedEvent event);
  void afterProcessCompleted(ProcessCompletedEvent event);
  void beforeNodeTriggered(ProcessNodeTriggeredEvent event);
  void afterNodeTriggered(ProcessNodeTriggeredEvent event);
  void beforeNodeLeft(ProcessNodeLeftEvent event);
  void afterNodeLeft(ProcessNodeLeftEvent event);

}
</programlisting>

    <para>An audit log can be created based on the information provided by these process
    listeners.  We provide various default logger implementations:
    <orderedlist>
      <listitem>Console logger: This logger writes out all the events to the console.</listitem>
      <listitem>File logger: This logger writes out all the events to a file using an
      XML representation.  This log file can then for example be used in the IDE to generate
      a tree-based visualization of the events that occured during execution.</listitem>
      <listitem>Threaded file logger: Because a file logger only writes the events to disk
      when closing the logger (or when the number of events in the logger reaches a predefined
      level), it cannot be used when debugging processes at runtime.  A threaded file logger
      writes out the events to file at a specified time interval, making it possible to use
      the logger for example to visualize the progress when debugging processes in realtime.
      </listitem>
    </orderedlist>
    </para>

    <para>The KnowledgeRuntimeLoggerFactory can be used to easily add a logger to your session,
    as shown below.  When creating a console logger, the knowledge session for which the logger
    needs to be created needs to be passes as an argument.  The file logger also requires the
    name of the log file to be created, and the threaded file logger requires the interval (in
    milliseconds) after which the events should be saved.</para>

<programlisting>
KnowledgeRuntimeLogger logger = KnowledgeRuntimeLoggerFactory.newFileLogger(ksession, "test");
// add invocations to the process engine here, e.g. ksession.startProcess(processId);
...
logger.close();
</programlisting>

    <para>The log file can be opened in the Eclipse when using the Audit View in the Drools
    Eclipse plugin, where the events are visualized in a tree-based manner (events that occur
    between the before and after event are shown as children of that event).  The following
    screenshot shows a simple example, where a process is started, resulting in the triggering
    of the start node, an action node and an end node, after which the process was completed.
    </para>

    <mediaobject>
      <imageobject>
        <imagedata align="center" format="PNG" role="" 
                   fileref="images/Chapter-API/AuditView.png"/>
       </imageobject>
    </mediaobject>

  </section>


</chapter>
