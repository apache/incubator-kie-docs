<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:base="../../" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Type Declaration</title>

  <note>
    <para><replaceable>(updated to Drools 5.0)</replaceable></para>
  </note>

  <warning>
    <para>FIXME: add syntax diagram for declare</para>
  </warning>

  <para>Type Declarations have two main goals in the rules engine: allow the
  declaration of new types and/or allow the declaration of metadata for
  types.</para>

  <itemizedlist>
    <listitem>
      <para>Declaring new types: Drools works out of the box with plain POJOs
      as facts. Although, sometimes the users may want to define the model
      directly into the rules engine, without worrying to create their models
      in a lower level language like Java. Another times, there is a domain
      model already built, but eventually the user wants or needs to
      complement this model with additional entities that are used mainly
      during the reasoning process.</para>
    </listitem>

    <listitem>
      <para>Declaring metadata: facts may have meta information associated to
      them. Examples of meta information include any kind of data that is not
      represented by the fact attributes and are consistent among all
      instances of that fact type. This meta information may be queried at
      runtime by the engine and used in the reasoning process.</para>
    </listitem>
  </itemizedlist>

  <section>
    <title>Declaring New Types</title>

    <para>To declare a new type, all you need to do is use the keyword
    <emphasis role="bold">declare</emphasis>, followed by the list of fields
    and the keyword <emphasis role="bold">end</emphasis>.</para>

    <example>
      <title>declaring a new fact type: Address</title>

      <programlisting><emphasis role="bold">declare</emphasis> Address
   number : int
   streetName : String
   city : String
<emphasis role="bold">end</emphasis>
</programlisting>
    </example>

    <para>The previous example declares a new fact type called
    <emphasis>Address</emphasis>. This fact type will have 3 attributes:
    <emphasis>number</emphasis>, <emphasis>streetName</emphasis> and
    <emphasis>city</emphasis>. Each attribute has a type that can be any valid
    java type, including any other class created by the user or even other
    fact types previously declared.</para>

    <para>For instance, we may want to declare another fact type
    <emphasis>Person</emphasis>:</para>

    <para><example>
        <title>declaring a new fact type: Person</title>

        <programlisting><emphasis role="bold">declare</emphasis> Person
    name : String
    dateOfBirth : java.util.Date
    address : Address
<emphasis role="bold">end</emphasis>
</programlisting>
      </example>As we can see on the previous example,
    <emphasis>dateOfBirth</emphasis> is of type <code>java.util.Date</code>,
    from the java API, while <emphasis>address</emphasis> is of the previously
    defined fact type Address.</para>

    <para>You may avoid having to write the fully qualified name of a class
    everytime you write it by using the <emphasis
    role="bold">import</emphasis> clause, previously discussed.</para>

    <para><example>
        <title>avoiding the need to use fully qualified class names by using
        import</title>

        <programlisting><emphasis role="bold">import</emphasis> java.util.Date

<emphasis role="bold">declare</emphasis> Person
    name : String
    dateOfBirth : Date
    address : Address
<emphasis role="bold">end</emphasis></programlisting>
      </example></para>

    <para>When you declare a new fact type, Drools will bytecode generate at
    compile time a POJO that implements the fact type. The generated java
    class will be a one-to-one javabean mapping of the type definition. So,
    for the previous example, the generated java class would be:</para>

    <para><example>
        <title>generated java class for the previous Person fact type
        declaration</title>

        <programlisting><emphasis role="bold">public</emphasis> <emphasis
            role="bold">class</emphasis> Person implements Serializable {
    <emphasis role="bold">private</emphasis> String name;
    <emphasis role="bold">private</emphasis> java.util.Date dateOfBirth;
    <emphasis role="bold">private</emphasis> Address address;

    // getters and setters
    // equals/hashCode
    // toString
}
</programlisting>
      </example>Since it is a simple POJO, the generated class can be used
    transparently in the rules, like any other fact.</para>

    <para><example>
        <title>using the declared types in rules</title>

        <programlisting><emphasis role="bold">rule</emphasis> "Using a declared Type"
<emphasis role="bold">when</emphasis> 
    $p : Person( name == "Bob" )
<emphasis role="bold">then</emphasis>
    System.out.println( "The name of the person is "+ )
    <emphasis>// lets insert Mark, that is Bob's mate</emphasis>
    Person mark = new Person();
    mark.setName("Mark");
    insert( mark );
<emphasis role="bold">end</emphasis>
</programlisting>
      </example>Although, the declared type can be used like any other POJO
    inside your rules, the classes are only available at runtime, after the
    DRL is compiled. It means that you will not be able to reference them
    explicitly from your application code. You could use reflection for that,
    but anyone that ever used reflection knows that it requires quite some
    work to do anything useful. This way, Drools provides a simplified API
    that allows you to manipulate such facts from your DRL file.</para>

    <para><warning>
        <para>FIXME: Will we expose org.drools.rule.FactType through the
        drools-api module? or will it remain an internal API?</para>
      </warning></para>

    <para></para>
  </section>

  <section>
    <title>Declaring Metadata</title>

    <para>Metadata may be assigned to several different constructions in
    Drools, like fact types, fact attributes and rules. Drools uses the
    <emphasis role="bold">@</emphasis> symbol to introduce metadata, and it
    always uses the form:</para>

    <para><programlisting>@matadata_key( metadata_value )</programlisting>The
    parenthesis and the metadata_value are optional.</para>

    <para>For instance, if you want to declare a metadata attribute like
    <emphasis>author</emphasis>, whose value is <emphasis>Bob</emphasis>, you
    could simply write:</para>

    <example>
      <title>declaring an arbitraty metadata attribute</title>

      <programlisting>@author( Bob )</programlisting>
    </example>

    <para>Drools allows the declaration of any arbitrary metadata attribute,
    but some will have special meaning to the engine, while others are simply
    available for querying at runtime. Drools allows the declaration of
    metadata both for fact types and for fact attributes. Any metadata that is
    declared before the fields of a fact type are assigned to the fact type,
    while metadata declared after an attribute are assigned to the attribute
    in particular.</para>

    <example>
      <title>declaring metadata attributes for fact types and
      attributes</title>

      <programlisting><emphasis role="bold">import</emphasis> java.util.Date

<emphasis role="bold">declare</emphasis> Person
    <emphasis>@author</emphasis>( Bob )
    <emphasis>@dateOfCreation</emphasis>( 01-Feb-2009 )

    name : String <emphasis>@key @maxLength</emphasis>( 30 )
    dateOfBirth : Date 
    address : Address
<emphasis role="bold">end</emphasis></programlisting>
    </example>

    <para>In the previous example, there are two metadata declared for the
    fact type (<emphasis>@author</emphasis> and
    <emphasis>@dateOfCreation</emphasis>), and two more defined for the name
    attribute (<emphasis>@key</emphasis> and <emphasis>@maxLength</emphasis>).
    Please note that the <emphasis>@key</emphasis> metadata has no value, and
    so the parenthesis and the value were omitted. </para>
  </section>

  <section>
    <title>Declaring Metadata for Existing Types</title>

    <para>Drools allows the declaration of metadata attributes for existing
    types in the same way as when declaring metadata attributes for new fact
    types. The only difference is that there are no fields in that
    declaration.</para>

    <para>For instance, if there is a class org.drools.examples.Person, and
    one wants to declare metadata for it, just to the following:</para>

    <example>
      <title>declaring metadata for an existing type</title>

      <programlisting><emphasis role="bold">import</emphasis> org.drools.examples.Person

<emphasis role="bold">declare</emphasis> Person
    <emphasis>@author</emphasis>( Bob )
    <emphasis>@dateOfCreation</emphasis>( 01-Feb-2009 )
<emphasis role="bold">end</emphasis>
</programlisting>
    </example>

    <para>Instead of using the import, it is also possible to reference the
    class by its fully qualified name, but since the class will also be
    referenced in the rules, usually it is shorter to add the import and use
    the short class name everywhere. </para>

    <example>
      <title>declaring metadata using the fully qualified class name</title>

      <programlisting><emphasis role="bold">declare</emphasis> org.drools.examples.Person
    <emphasis>@author</emphasis>( Bob )
    <emphasis>@dateOfCreation</emphasis>( 01-Feb-2009 )
<emphasis role="bold">end</emphasis></programlisting>
    </example>
  </section>

  <section>
    <title>Accessing metadata through the API</title>

    <para></para>
  </section>
</section>
