<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="jBPMRuntimeManagement"
         xsi:schemaLocation="http://docbook.org/ns/docbook http://www.docbook.org/xml/5.0/xsd/docbook.xsd http://www.w3.org/1999/xlink http://www.docbook.org/xml/5.0/xsd/xlink.xsd"
         xml:base="Overview/" xmlns="http://docbook.org/ns/docbook" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude" xmlns:ns="http://docbook.org/ns/docbook">
  <title>Runtime Management</title>
       <section>
              <title>Deployments</title>
              <para> In version 5.x processes were stored in so called packages produced by Guvnor
                     and next downloaded by jbpm console for execution using KnowledgeAgent.
                     Alternatively one could drop their process files (bpmn2 files) into a
                     predefined directory that was scanned on the jbpm console start. That was it.
                     That enforces users to always use Guvnor when dynamic deployment was needed.
                     Although there is nothing wrong with it, actually that was recommended approach
                     but not everytime it was desired. </para>
              <para>Version 6, on the other hand moves away from proprietary packages in favor of,
                     well known and mature, Apache Maven based packaging - known as knowledge
                     archives - kjar. Processes, rules etc (aka business assets) are now part of a
                     simple jar file built and managed by Maven. Along the business assets, java
                     classes and other file types are stored in the jar file too. Moreover, as any
                     other maven artifact, kjar can have defined dependencies on other artifacts
                     including other kjars. What makes the kjar special when compared with regular
                     jars is a single descriptor file kept inside META-INF directory of the kjar -
                     kmodule.xml. That descriptor allows to define:</para>
              <para>
                     <itemizedlist>
                            <listitem>
                                   <para>knowledge bases and their properties </para>
                            </listitem>
                            <listitem>
                                   <para>knowledge sessions and their properties </para>
                            </listitem>
                            <listitem>
                                   <para>work item handlers </para>
                            </listitem>
                            <listitem>
                                   <para>event listeners</para>
                            </listitem>
                     </itemizedlist>
              </para>
              <para>By default, this descriptor is empty (just kmodule root element) and is
                     considered as marker file. Whenever a runtime component (such as jbpm console)
                     is about to process kjar it looks up kmodule.xml to build its runtime
                     representation. In addition to kmodule.xml a deployment descriptor (that
                     provides fine graind control over deployment) is available (since 6.1). </para>
              <section>
                     <title>Deployment descriptors</title>
                     <para>While kmodule is mainly targeting on knowledge base and knowledge session
                            basic configuration, deployment descriptors are considered more
                            technical configuration. Following are the items available for
                            configuration via deployment descriptors:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>persistence unit name for runtime data</para>
                                   </listitem>
                                   <listitem>
                                          <para>persistence unit for audit data</para>
                                   </listitem>
                                   <listitem>
                                          <para>persistence mode (JPA or NONE)</para>
                                   </listitem>
                                   <listitem>
                                          <para>audit mode (JPA, JMS, NONE)</para>
                                   </listitem>
                                   <listitem>
                                          <para>runtime strategy (SINGLETON, PER_REQUEST,
                                                 PER_PROCESS_INSTANCE)</para>
                                   </listitem>
                                   <listitem>
                                          <para>list of event listeners to be registered</para>
                                   </listitem>
                                   <listitem>
                                          <para>list of task event listeners to be registered</para>
                                   </listitem>
                                   <listitem>
                                          <para>list of work item handlers to be registered</para>
                                   </listitem>
                                   <listitem>
                                          <para>list of globals to be registered</para>
                                   </listitem>
                                   <listitem>
                                          <para>marshalling strategies to be registered (for
                                                 pluggable variable persistence)</para>
                                   </listitem>
                                   <listitem>
                                          <para>required roles to be granted access to resources of
                                                 the kjar</para>
                                   </listitem>
                                   <listitem>
                                          <para>additional configuration options of knowledge
                                                 session</para>
                                   </listitem>
                                   <listitem>
                        <para>additional environment entries for knowledge session</para>
                    </listitem>
                    <listitem>
                        <para>list of fully qualified class names that shall be added to the classes used for serialization by remote services</para>
                    </listitem>
          <listitem>
            <para>whether or not to limit the classes from the deployment used for serialization by the remote services</para>
          </listitem>
                            </itemizedlist>
                     </para>
                     <para>Deployment descriptor is an xml file that is placed inside META-INF
                            folder of the kjar, although it is an optional file and deployments will
                            succeed even when such descriptor is missing. </para>
                     <para>
                            <programlisting>
&lt;deployment-descriptor xsi:schemaLocation="http://www.jboss.org/jbpm deployment-descriptor.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    &lt;persistence-unit>org.jbpm.domain&lt;/persistence-unit>
    &lt;audit-persistence-unit>org.jbpm.domain&lt;/audit-persistence-unit>
    &lt;audit-mode>JPA&lt;/audit-mode>
    &lt;persistence-mode>JPA&lt;/persistence-mode>
    &lt;runtime-strategy>PER_PROCESS_INSTANCE&lt;/runtime-strategy>
    &lt;marshalling-strategies/>
    &lt;event-listeners/>
    &lt;task-event-listeners/>
    &lt;globals/>
    &lt;work-item-handlers/>
    &lt;environment-entries/>
    &lt;configurations/>
    &lt;required-roles/>
    &lt;remoteable-classes/>
    &lt;limit-serialization-classes/>
&lt;/deployment-descriptor>
</programlisting>
                     </para>
                     <para>It provides more configuration options then the standard deployment has.
                            Deployment descriptors are used in hierarchical way meaning they can be
                            placed on various levels of the system and merged on runtime. jBPM
                            supports following levels of deployment descriptors:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>server level - this is the main and considered
                                                 default deployment descriptos that apply to all
                                                 deployments on given server</para>
                                   </listitem>
                                   <listitem>
                                          <para>kjar level - this is dedicated deployment descriptor
                                                 to given kjar</para>
                                   </listitem>
                                   <listitem>
                                          <para>deploy time level - this is deployment descriptor
                                                 that is given at the time of deployment</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>Deployment descriptors on different levels are merged on deployment time
                            where the master is considered descriptor lower in the hierarchy and
                            slave one that is higher in hierarchy. To give an example, when a kjar
                            is deployed and it contains deployment descriptor kjar's deployment
                            descriptor is considered slave and server level descriptor is considered
                            master. With default merge mode it will override all master entries with
                            slave ones as long as they are not empty and combine all
                            collections.</para>
                     <para>Since kjar can have dependencies to other kjars, and in turn that
                            dependencies might have deployment descriptors as well, they will be
                            placed in deployment descriptors hierarchy lower than the actual kjar
                            that is being deployed. With that said, this is how it will look like
                            from hierarchy point of view, starting with master (server
                            level):</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>server level</para>
                                   </listitem>
                                   <listitem>
                                          <para>dependency kjar level</para>
                                   </listitem>
                                   <listitem>
                                          <para>kjar level</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>That in default merging mode will result in deployment descriptor where
                            with non empty values from kjar's deployment descriptors and merged
                            collection from all levels.</para>
                     <para>So far all merging was done with default mode, which is MERGE_COLLECTIONS
                            but that's not the only mode that is available:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>KEEP_ALL - meaning that the master wins - all
                                                 configuration defined in master will be
                                                 retained</para>
                                   </listitem>
                                   <listitem>
                                          <para>OVERRIDE_ALL - meaning that slave wins - all
                                                 configuration defined in master will be
                                                 retained</para>
                                   </listitem>
                                   <listitem>
                                          <para>OVERRIDE_EMPTY - meaning all non empty configuration
                                                 items from slave will replace those in master,
                                                 including collections</para>
                                   </listitem>
                                   <listitem>
                                          <para>MERGE_COLLECTIONS - meaning all non empty
                                                 configuration items from slave will replace those
                                                 in master but collections will me merged
                                                 (combined)</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>
                            <tip>
                                   <para>Deployment descriptos can be given as partial xml
                                          documents, meaning they do not need to be complete set of
                                          all configuration items, e.g. if user would like to
                                          override only the audit mode in kjar, it's enough to have
                                          following deployment
                                          descriptor:<programlisting>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?>
&lt;deployment-descriptor xsi:schemaLocation="http://www.jboss.org/jbpm deployment-descriptor.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    &lt;audit-mode>JPA&lt;/audit-mode>
&lt;/deployment-descriptor></programlisting></para>
                                   <para>Although it's worth noting that when using OVERRIDE_ALL
                                          merge mode all configuration items should be specified
                                          since it will always use them and do not merge with any
                                          other deployment descriptor in the hierarchy.</para>
                            </tip>
                     </para>
                     <para><emphasis role="bold">Default deployment descriptor</emphasis></para>
                     <para>There is always default deployment descriptor available, even if it was
                            not explicitly configured, when running in jbpm-console (kie-workbench)
                            the default values are as follows:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>persistence-unit is set to org.jbpm.domain</para>
                                   </listitem>
                                   <listitem>
                                          <para>audit-persistence-unit is set to
                                                 org.jbpm.domain</para>
                                   </listitem>
                                   <listitem>
                                          <para>persistence-mode is set to JPA</para>
                                   </listitem>
                                   <listitem>
                                          <para>audit-mode is set to JPA</para>
                                   </listitem>
                                   <listitem>
                                          <para>runtime-strategy is set to SINGLETON</para>
                                   </listitem>
                                   <listitem>
                                          <para>all collection based configuration items are left
                                                 empty</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>
                            <note>
                                   <para>Regardless of collection elements in default deployment
                                          descriptor are empty there will be some work item
                                          handlers/listeners registered that are required to support
                                          functionality of the jbpm console such as BAM listeners or
                                          human task work item handler.</para>
                            </note>
                     </para>
                     <para>Default deployment descriptor can be altered by specifying valid URL
                            location to an xml file that will provide fully defined deployment
                            descriptor. By fully defined we mean that all elements should be
                            specified as this deployment descriptor will become server level
                            deployment descriptor. </para>
                     <para>
                            <programlisting>-Dorg.kie.deployment.desc.location=file:/my/custom/location/deployment-descriptor.xml</programlisting>
                     </para>
                     <para><emphasis role="bold">Collection configuration items</emphasis></para>
                     <para>Deployment descriptor consists of collection based items (event
                            listeners, work item handlers, globals, etc) that usually require
                            definition of an object that should be created on runtime. There are two
                            types of collection based configuration items:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>object model - that is clear definition of the
                                                 object to be built or looked up in available
                                                 registry</para>
                                   </listitem>
                                   <listitem>
                                          <para>named object model - that is an extension to object
                                                 model and allows to provide name of the object
                                                 which will be used to register object</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>Object model consits of: </para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>identifier - defines main information about the
                                                 object, such as fully qualified class name, spring
                                                 bean id, mvel expression</para>
                                   </listitem>
                                   <listitem>
                                          <para>parameters - optional parameters that should be used
                                                 while creating object instance from the
                                                 model</para>
                                   </listitem>
                                   <listitem>
                                          <para>resolver - identifier of the resolver that will be
                                                 used to create object instances from the model -
                                                 (reflection, mvel, spring)</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>
                            <table frame="all">
                                   <title>Object models</title>
                                   <tgroup cols="2">
                                          <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                                          <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                                          <thead>
                                                 <row>
                                                  <entry>Configuration item</entry>
                                                  <entry>Type of collection items</entry>
                                                 </row>
                                          </thead>
                                          <tbody>
                                                 <row>
                                                  <entry>event-listeners</entry>
                                                  <entry>ObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>task-event-listeners</entry>
                                                  <entry>ObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>marshalling-strategies</entry>
                                                  <entry>ObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>work-item-handlers</entry>
                                                  <entry>NamedObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>globals</entry>
                                                  <entry>NamedObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>environment-entries</entry>
                                                  <entry>NamedObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>configurations</entry>
                                                  <entry>NamedObjectModel</entry>
                                                 </row>
                                                 <row>
                                                  <entry>required-roles</entry>
                                                  <entry>String</entry>
                                                 </row>
                                          </tbody>
                                   </tgroup>
                            </table>
                     </para>
                     <para>Depending on resolver type, creation or look up of the object will be
                            performed. The default (and easiest) is reflection that will use both
                            parameters and identifier (in this case is FQCN) to construct the
                            object. Parameters in this case can be  String or another object model
                            for representing other types than String. Following is an example of an
                            object model that will create an instance of
                            org.jbpm.test.CustomStrategy using reflection resolver that will use
                            constructor of that class with two String parameters. Note that String
                            paramaters are created with different ways (using object model - first
                            param, directly by giving String - second param).</para>
                     <para>
                            <example>
                                   <para>
                                          <programlisting>...
&lt;marshalling-strategy>
  &lt;resolver>reflection&lt;/resolver>
  &lt;identifier>org.jbpm.test.CustomStrategy&lt;/identifier>
  &lt;parameters>
    &lt;parameter xsi:type="objectModel">
       &lt;resolver>reflection&lt;/resolver>
       &lt;identifier>java.lang.String&lt;/identifier>
       &lt;parameters>
         &lt;parameter xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">param1&lt;/parameter>
       &lt;/parameters>
       &lt;/parameter>
         &lt;parameter xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">param2&lt;/parameter>
       &lt;/parameters>
&lt;/marshalling-strategy>
...</programlisting>
                                   </para>
                            </example>
                     </para>
                     <para>Same can be done by using DeploymentDescriptor fluent API:</para>
                     <para>
                            <programlisting>// create instance of DeploymentDescriptor with default persistence unit name
DeploymentDescriptor descriptor = new DeploymentDescriptorImpl("org.jbpm.domain");

// get builder and modify the descriptor		
descriptor.getBuilder()
.addMarshalingStrategy(new ObjectModel("org.jbpm.testCustomStrategy", 
			new Object[]{
			new ObjectModel("java.lang.String", new Object[]{"param1"}),
			"param2"}));</programlisting>
                     </para>
                     <para>Reflection based object model resolver is the most verbose in case there
                            are parameters involved but there are few parameters that are available
                            out of the box and do not need to be created, they are simply referenced
                            by name:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>entityManagerFactory (type of this parameter is
                                                 javax.persistence.EntityManagerFactory)</para>
                                   </listitem>
                                   <listitem>
                                          <para>runtimeManager (type of this parameter is
                                                 org.kie.api.runtime.manager.RuntimeManager)</para>
                                   </listitem>
                                   <listitem>
                                          <para>kieSession (type of this parameter is
                                                 org.kie.api.KieServices)</para>
                                   </listitem>
                                   <listitem>
                                          <para>taskService (type of this parameter is
                                                 org.kie.api.task.TaskService)</para>
                                   </listitem>
                                   <listitem>
                                          <para>executorService (type of this parameter is
                                                 org.kie.internal.executor.api.ExecutorService)</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>So to be able to use one of these it's enough to reference them by name
                            and make sure that proper object type is used within your class:</para>
                     <para>
                            <programlisting>...
&lt;marshalling-strategy>
  &lt;resolver>reflection&lt;/resolver>
  &lt;identifier>org.jbpm.test.CustomStrategy&lt;/identifier>
  &lt;parameters>
     &lt;parameter xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">runtimeManager&lt;/parameter>
   &lt;/parameters>
&lt;/marshalling-strategy>
...</programlisting>
                     </para>
                     <para>In case reflection based resolver is not enough, more advanced resolver
                            can be used that utilizes power of MVEL language.  It's much easier in
                            the configuration as it expects mvel expression as identifier of the
                            object model. It will provide the out of the box parameters (listed
                            above: runtime manager, kie session, etc) into the mvel context while
                            evaluating expression. To define object model with mvel resolver use
                            following xml (that will be equivalent to replection based
                            above):<programlisting>...
&lt;marshalling-strategy>
  &lt;resolver>mvel&lt;/resolver>
  &lt;identifier>new org.jbpm.test.CustomStrategy(runtimeManager)&lt;/identifier>
&lt;/marshalling-strategy>
...</programlisting></para>
                     <para>Last but not least, there is Spring based resolver available as well that
                            allows to simply look up a bean by its identifier from spring
                            application context. This resolver is not used in jbpm console
                            (kie-workbench) as it does not use spring but whenever jBPM is used
                            together with Spring it might become handy when deploying kjars into the
                            runtime. It's very simple definition in xml, again equivalent to the
                            other one assuming org.jbpm.test.CustomStrategy is registered in spring
                            application context under customStrategy
                            id.<programlisting>...
&lt;marshalling-strategy>
  &lt;resolver>spring&lt;/resolver>
  &lt;identifier>customStrategy&lt;/identifier>
&lt;/marshalling-strategy>
...</programlisting></para>
                     <para><emphasis role="bold">Manage deployment descriptor</emphasis></para>
                     <para>Deployment descriptor is created as soon as project is created. It does
                            contins the most basic deployment descriptor that is based on the
                            default one. Meaning all settings present in default deployment
                            descriptor will be copied into the one placed in the project. Further
                            changes can be done directly in the xml content (in next versions more
                            user friendly editor will most likely be provided). It is accessible
                            from Administration perspecitve as this is considered technical
                            administration task rather than business related activity.</para>
                     <para>
                            <mediaobject>
                                   <imageobject>
                                          <imagedata align="center"
                                                 fileref="images/RuntimeManagement/edit-deployment-desc.png"
                                          />
                                   </imageobject>
                            </mediaobject>
                     </para>
                     <para><emphasis role="bold">Restrict access to runtime engine</emphasis></para>
                     <para>jbpm console (kie-workbench) provides access restriction to repositories
                            that can be configured with supplementary tool called kie-config-cli.
                            This protects repositories in the authoring perspsective based on roles
                            membership. Deployment descriptors moves this capability to the runtime
                            engine by ensuring that access to processes will be granted only to
                            users that belong to groups defined in the deployment descriptor as
                            required roles. By default when project is created (at the same time
                            deployment descriptor is created as well) required roles are
                            automatically filled in based on repository restrictions. These roles
                            can be still altered by editing deployment descriptor via Administration
                            perspective as presented in Manage deployment descriptor section.</para>
                     <para>Security is enforced on two levels:</para>
                     <para>
                            <itemizedlist>
                                   <listitem>
                                          <para>user interface - user will see only process
                                                 definitions that are available for his/her
                                                 roles</para>
                                   </listitem>
                                   <listitem>
                                          <para>runtime manager - each access to get RuntimeEngine
                                                 out of RuntimeManager is pretected based on the
                                                 role membership, in case unauthorized access it
                                                 attempted SecurityException will be thrown</para>
                                   </listitem>
                            </itemizedlist>
                     </para>
                     <para>Required roles are defined as simple strings that should match actual
                            roles defined in security realm. Following is a xml snippet that shows
                            definition of required roles in deployment descriptor:</para>
                     <para>
                            <programlisting>&lt;deployment-descriptor>
...
    &lt;required-roles>
        &lt;required-role>experts&lt;/required-role>
    &lt;/required-roles>
...
&lt;/deployment-descriptor></programlisting>
                     </para>
                     <para>In case fine grained control is required defined roles can be prefixed
                with one of the following to control it on further level:</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>view:</para>
                        <para>to restrict access to be able to see given process
                            definitions/instances on UI</para>
                    </listitem>
                    <listitem>
                        <para>executre:</para>
                        <para>to restrict access to be able to execute given process
                            definitions</para>
                    </listitem>
                    <listitem>
                        <para>all:</para>
                        <para>applies to both view and execute restrictions and this is the default
                            when no prefix is given.</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>For example to restrict access to show process from given kjar only to group
                'management' but still allow them to be executed by anyone (sort of system
                processes) one could define it as follows:</para>
            <programlisting>
&lt;deployment-descriptor>
...
   &lt;required-roles>
      &lt;required-role>view:management&lt;/required-role>
   &lt;/required-roles>
...
&lt;/deployment-descriptor>
</programlisting>
            <para><emphasis role="bold">Classes used for serialization in the remote services</emphasis></para>
            <para>When processes make use of custom types (or in general non promitive types) and
                there is a use case to include remote api invocations (REST, SOAP, JMS) such types
                must be available to the remote services marshalling mechanism that is based on JAXB
                for XML type. By default all types defined in kjar will be automatically included in
                JAXB context and therefore will be avialble for remote interaction. Though there
                might be more classes (like from dependent model) that shall be included there too. </para>
            <para>Upon deployment, jBPM will scan classpath of given kjar to automatically register classes that might be needed for remote interaction. This is done based on following rules:</para>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>all classes included in kjar project itself</para>
                    </listitem>
                    <listitem>
                        <para>all classes included as dependency of projects type kjar</para>
                    </listitem>
                    <listitem>
                        <para>classes that are annotated with @XmlRootElement (JAXB annotation) and
                            included as regular dependency of the kjar</para>
                    </listitem>
                    <listitem>
                        <para>classes that are annotated with @Remotable (kie annotation) and
                            included as regular dependency of the kjar</para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>If that is not enough deployment descriptor allows to manually specify classes
                that shall be added to the JAXB context via remoteable-classes element:</para>
            <programlisting>&lt;remoteable-classes>
   ...
   &lt;remotable-class>org.jbpm.test.CustomClass&lt;/remotable-class>
   &lt;remotable-class>org.jbpm.test.AnotherCustomClass&lt;/remotable-class>
   ...
&lt;/remoteable-classes></programlisting>
            <para>With this all classes can be added to the JAXB context to properly marshal and
                unmarshal data types when interacting with jBPM remotely.</para>
            <para><emphasis role="bold">Limiting classes usd for serialization in the remote services</emphasis></para>
            <para>When there are classes in the kjar project or in the dependencies of the kjar project that woudl cause problems when used for serialization, the <code>limit-serialization-classes</code> property can be used to limit which classes are used for serialization</para>
            <programlisting>&lt;limit-serialization-classes&gt;true&lt;/limit-serialization-classes&gt;</programlisting>
            <para>This property limits classes used for serialization to classes which fulfill both of the following "location" and "annotation" criteria: </para>
      <para>Classes that: <orderedlist>
          <listitem>
            <para>are located in the kjar project</para>
          </listitem>
          <listitem>
            <para>are in a direct dependency of the kjar project</para>
          </listitem>
          <listitem>
            <para>are listed in the <code>remoteable-classes</code> element and are available on the classpath of the kjar</para>
          </listitem>
        </orderedlist> These classes must also be annotated with one of the following type annotations: <itemizedlist>
          <listitem>
            <para><code>javax.xml.bind.annotation.XmlRootElement</code></para>
          </listitem>
          <listitem>
            <para><code>javax.xml.bind.annotation.XmlType</code></para>
          </listitem>
          <listitem>
            <para><code>org.kie.api.remote.Remotable</code></para>
          </listitem>
        </itemizedlist>
      Additionally, classes will be <emphasis>excluded</emphasis> if they are any of the following: interfaces, local classes, member classes or anonymous classes.</para>
        </section>
    </section>
    <section>
        <title>Process Deployments</title>
        <para>You can access to the Process Deployments List under the Deploy top level menu of the
            KIE Workbench</para>
        <mediaobject>
            <imageobject>
                <imagedata align="center" format="PNG" role=""
                    fileref="images/RuntimeManagement/process-deployments.png"/>
            </imageobject>
        </mediaobject>
        <para>The Deployed Unit list shows all the Process Deployed Units into the platform that are
            already enabled to be used. Each deployment unit can contain multiple business processes
            and business rules. In order to have your process and rules deployed and listed in this
            list, you need ot Build and Deploy your KIE projects from the Authoring Perspective or
            via the Remote Endpoints. If your processes and rules are in a KIE Project listed in
            this list and you have correspondent the rights you should be able to see the process
            definitions in the Process Definitions Perspective. </para>
        <mediaobject>
            <imageobject>
                <imagedata align="center" format="PNG" role=""
                    fileref="images/RuntimeManagement/deployed-unit-list.png" width="700"/>
            </imageobject>
        </mediaobject>
        <para>From the Authoring Perspective (Build and Deploy), a default deployment will be
            performed, for a more advanced deployments you can trigger a custom deployment with
            other options from this screen. </para>
        <mediaobject>
            <imageobject>
                <imagedata align="center" format="PNG" role=""
                    fileref="images/RuntimeManagement/build-and-deploy.png" width="700"/>
            </imageobject>
        </mediaobject>
        <para>By clicking the New Deployment Unit (+) button you will be able to select a different
            KIE Base, KIE Session, Strategy and Merge Mode for your deployment. By default the
            "DEFAULT" KIE Base and KIE Sessions are used, the SINGLETON Strategy is selected and the
            Merge Mode is set to "Merge Collection". </para>
        <mediaobject>
            <imageobject>
                <imagedata align="center" format="PNG" role=""
                    fileref="images/RuntimeManagement/new-deployment.png"/>
            </imageobject>
        </mediaobject>
    </section>
       <section>
           <title>Jobs</title>
           <para>The Jobs perspective allows you to monitor and trigger Asynchronous Jobs schedulled to the jBPM Executor Service.
               You can access to the Jobs List from the Deploy top level menu of the KIE Workbench.
           </para>
           <mediaobject>
               <imageobject>
                   <imagedata align="center" format="PNG" role=""
                                              fileref="images/RuntimeManagement/jobs-menu.png" 
                   />
               </imageobject>
           </mediaobject>
           <para>
               The Jobs List shows all the Jobs that were schedulled and their status. The Filter on top of the table 
               helps the administrator to monitor the Jobs execution and take corrective actions in case of Failure. 
               Check the jBPM Executor section of the documentation for more information. 
               
           </para>
           <mediaobject>
               <imageobject>
                   <imagedata align="center" format="PNG" role=""
                                              fileref="images/RuntimeManagement/jobs-actions.png" 
                   />
               </imageobject>
           </mediaobject>
           <para> Administrators have also the option to configure the jBPM Executor Service Settings and to start and stop the
               service from the User Interface via the Actions -> Settings option.
           </para>
            <mediaobject>
               <imageobject>
                   <imagedata align="center" format="PNG" role=""
                                              fileref="images/RuntimeManagement/jobs-service-settings.png" width="400"
                   />
               </imageobject>
           </mediaobject>
           <para> Administrators can also schedulle manually new Jobs from the User Interface via the Actions -> Settings option. 
               By specifing the command class name and the parameters needed to run the command a new Job can be created. This manually created jobs will
               not be associated with any process instance.
               Notice also that the Due Date paramenter allows the execution to be derrefered 
               for the future. If the Due Date is the time of schedulling the jBPM Executor Service will execute the command as soon as there
               is an Executor Thread available. The number of retries will help the command to be executed more than once if it fails. This can help in situations
               when the business logic requires an external service to be called where the runtime cannot rely on that service to be available 100% of the time. 
  
           </para>
            <mediaobject>
               <imageobject>
                   <imagedata align="center" format="PNG" role=""
                                              fileref="images/RuntimeManagement/jobs-new.png" width="400"
                   />
               </imageobject>
           </mediaobject>
       </section>

</chapter>
