= Rule

.rule
image::LanguageReference/rule.png[align="center"]


A rule specifies that _when_ a particular set of conditions occur, specified in the Left Hand Side 
(LHS), _then_ do what queryis specified as a list of actions in the Right Hand Side (RHS). A 
common question from users is "Why use when instead of if?" "When" was chosen over "if" because 
"if" is normally part of a procedural execution flow, where, at a specific point in time, a 
condition is to be checked.

In contrast, "when" indicates that the condition evaluation is not tied to a specific evaluation 
sequence or point in time, but that it happens continually, at any time during the life time of 
the engine; whenever the condition is met, the actions are executed.

A rule must have a name, unique within its rule package.
If you define a rule twice in the same DRL it produces an error while loading.
If you add a DRL that includes a rule name already in the package, it replaces the previous rule.
If a rule name is to have spaces, then it will need to be enclosed in double quotes (it is best to 
always use double quotes).

Attributes - described below - are optional.
They are best written one per line.

The LHS of the rule follows the `when` keyword (ideally on a new line), similarly the RHS follows 
the `then` keyword (again, ideally on a newline). The rule is terminated by the keyword ``end``.
Rules cannot be nested.

.Rule Syntax Overview
====
[source]
----
rule "<name>"
    <attribute>*
when
    <conditional element>*
then
    <action>*
end
----
====

.A simple rule
====
[source]
----
rule "Approve if not rejected"
  salience -100 
  agenda-group "approval"
    when
        not Rejection() 
        p : Policy(approved == false, policyState:status)
        exists Driver(age > 25)
        Process(status == policyState)
    then
        log("APPROVED: due to no objections."); 
        p.setApproved(true);
end
----
====

== Rule Attributes


Rule attributes provide a declarative way to influence the behavior of the rule.
Some are quite simple, while others are part of complex subsystems such as ruleflow.
To get the most from Drools you should make sure you have a proper understanding of each attribute.

.rule attributes
image::LanguageReference/rule_attributes.png[align="center"]


`no-loop`::
default value: `false`
+
type: Boolean
+
When a rule's consequence modifies a fact it may cause the rule to activate again, causing an 
infinite loop. Setting no-loop to true will skip the creation of another Activation for the rule 
with the current set of facts.

`ruleflow-group`::
default value: N/A
+
type: String
+
Ruleflow is a Drools feature that lets you exercise control over the firing of rules.
Rules that are assembled by the same ruleflow-group identifier fire only when their group is active.

`lock-on-active`::
default value: `false`
+
type: Boolean
+
Whenever a ruleflow-group becomes active or an agenda-group receives the focus, any rule within 
that group that has lock-on-active set to true will not be activated any more; irrespective of the 
origin of the update, the activation of a matching rule is discarded. This is a stronger version 
of `no-loop`, because the change could now be caused not only by the rule itself.  It's ideal for calculation rules where you have a number of rules that modify a fact and you don't want any rule re-matching and firing again.
Only when the ruleflow-group is no longer active or the agenda-group loses the focus those rules with lock-on-active set to true become eligible again for their activations to be placed onto the agenda.

`salience`::
default value: `0`
+
type: integer
+
Each rule has an integer salience attribute which defaults to zero and can be negative or positive.
Salience is a form of priority where rules with higher salience values are given higher priority when ordered in the Activation queue.
+
Drools also supports dynamic salience where you can use an expression involving bound variables.
+


.Dynamic Salience
====
[source]
----
rule "Fire in rank order 1,2,.."
        salience( -$rank )
    when
        Element( $rank : rank,... )
    then
        ...
end
----
====
`agenda-group`::
default value: MAIN
+
type: String
+
Agenda groups allow the user to partition the Agenda providing more execution control.
Only rules in the agenda group that has acquired the focus are allowed to fire.

`auto-focus`::
default value: `false`
+
type: Boolean
+
When a rule is activated where the `auto-focus` value is true and the rule's agenda group does not have focus yet, then it is given focus, allowing the rule to potentially fire.

`activation-group`::
default value: N/A
+
type: String
+
Rules that belong to the same activation-group, identified by this attribute's string value, will only fire exclusively.
More precisely, the first rule in an activation-group to fire will cancel all pending activations of all rules in the group, i.e., stop them from firing.
+
Note: This used to be called Xor group, but technically it's not quite an Xor.
You may still hear people mention Xor group; just swap that term in your mind with activation-group.

`dialect`::
default value: as specified by the package
+
type: String
+
possible values: "java" or "mvel"
+
The dialect species the language to be used for any code expressions in the LHS or the RHS code block.
Currently two dialects are available, Java and MVEL.
While the dialect can be specified at the package level, this attribute allows the package definition to be overridden for a rule.

`date-effective`::
default value: N/A
+
type: String, containing a date and time definition
+
A rule can only activate if the current date and time is after date-effective attribute.

`date-expires`::
default value: N/A
+
type: String, containing a date and time definition
+
A rule cannot activate if the current date and time is after the date-expires attribute.

`duration`::
default value: no default value
+
type: long
+
The duration dictates that the rule will fire after a specified duration, if it is still true.

.Some attribute examples
====
[source]
----
rule "my rule"
  salience 42
  agenda-group "number 1"
    when ...
----
====

== Timers and Calendars


Rules now support both interval and cron based timers, which replace the now deprecated duration attribute.

.Sample timer attribute uses
====
[source,java]
----
timer ( int: <initial delay> <repeat interval>? )
timer ( int: 30s )
timer ( int: 30s 5m )

timer ( cron: <cron expression> )
timer ( cron:* 0/15 * * * ? )
----
====


Interval (indicated by "int:") timers follow the semantics of java.util.Timer objects, with an initial delay and an optional repeat interval.
Cron (indicated by "cron:") timers follow standard Unix cron expressions:

.A Cron Example
====
[source,java]
----
rule "Send SMS every 15 minutes"
    timer (cron:* 0/15 * * * ?)
when
    $a : Alarm( on == true )
then
    channels[ "sms" ].insert( new Sms( $a.mobileNumber, "The alarm is still on" );
end
----
====


A rule controlled by a timer becomes active when it matches, and once for each individual match.
Its consequence is executed repeatedly, according to the timer's settings.
This stops as soon as the condition doesn't match any more.

Consequences are executed even after control returns from a call to fireUntilHalt.
Moreover, the Engine remains reactive to any changes made to the Working Memory.
For instance, removing a fact that was involved in triggering the timer rule's execution causes the repeated execution to terminate, or inserting a fact so that some rule matches will cause that rule to fire.
But the Engine is not continually active, only after a rule fires, for whatever reason.
Thus, reactions to an insertion done asynchronously will not happen until the next execution of a timer-controlled rule.
Disposing a session puts an end to all timer activity.

Conversely when the rule engine runs in passive mode (i.e.: using fireAllRules instead of fireUntilHalt) by default it doesn't fire consequences of timed rules unless fireAllRules isn't invoked again.
However it is possible to change this default behavior by configuring the KieSession with a `TimedRuleExectionOption` as shown in the following example.

.Configuring a KieSession to automatically execute timed rules
====
[source,java]
----
KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
ksconf.setOption( TimedRuleExectionOption.YES );
KSession ksession = kbase.newKieSession(ksconf, null);
----
====


It is also possible to have a finer grained control on the timed rules that have to be automatically executed.
To do this it is necessary to set a `FILTERED` `TimedRuleExectionOption` that allows to define a 
callback to filter those rules, as done in the next example.

.Configuring a filter to choose which timed rules should be automatically executed
====
[source,java]
----
KieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration();
conf.setOption( new TimedRuleExectionOption.FILTERED(new TimedRuleExecutionFilter() {
    public boolean accept(Rule[] rules) {
        return rules[0].getName().equals("MyRule");
    }
}) );
----
====


For what regards interval timers it is also possible to define both the delay and interval as an 
expression instead of a fixed value. To do that it is necessary to use an expression timer 
(indicated by "expr:") as in the following example:

.An Expression Timer Example
====
[source,java]
----
declare Bean
    delay   : String = "30s"
    period  : long = 60000
end

rule "Expression timer"
    timer( expr: $d, $p )
when
    Bean( $d : delay, $p : period )
then
end
----
====


The expressions, `$d` and `$p` in this case, can use any variable defined in the pattern matching part 
of the rule and can be any String that can be parsed in a time duration or any numeric value that 
will be internally converted in a long representing a duration expressed in milliseconds.

Both interval and expression timers can have 3 optional parameters named "start", "end" and 
"repeat-limit". When one or more of these parameters are used the first part of the timer 
definition must be followed by a semicolon ';' and the parameters have to be separated by a comma 
',' as in the following example:

.An Interval Timer with a start and an end
====
[source,java]
----
timer (int: 30s 10s; start=3-JAN-2010, end=5-JAN-2010)
----
====


The value for start and end parameters can be a Date, a String representing a Date or a long, or 
more in general any Number, that will be transformed in a Java Date applying the following 
conversion:

[source,java]
----
new Date( ((Number) n).longValue() )
----


Conversely the repeat-limit can be only an integer and it defines the maximum number of 
repetitions allowed by the timer. If both the end and the repeat-limit parameters are set the 
timer will stop when the first of the two will be matched.

The using of the start parameter implies the definition of a phase for the timer, where the 
beginning of the phase is given by the start itself plus the eventual delay. In other words in 
this case the timed rule will then be scheduled at times:

[source,java]
----
start + delay + n*period
----

for up to repeat-limit times and no later than the end timestamp (whichever first). For instance 
the rule having the following interval timer

[source,java]
----
timer ( int: 30s 1m; start="3-JAN-2010" )
----

will be scheduled at the 30th second of every minute after the midnight of the 3-JAN-2010.
This also means that if for example you turn the system on at midnight of the 3-FEB-2010 it won't 
be scheduled immediately but will preserve the phase defined by the timer and so it will be 
scheduled for the first time 30 seconds after the midnight.

If for some reason the system is paused (e.g. the session is serialized and then deserialized 
after a while) the rule will be scheduled only once to recover from missing activations 
(regardless of how many activations we missed) and subsequently it will be scheduled again in 
phase with the timer.

Calendars are used to control when rules can fire. The Calendar API is modelled on 
http://www.quartz-scheduler.org/[Quartz]:

.Adapting a Quartz Calendar
====
[source,java]
----
Calendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)
----
====

Calendars are registered with the `KieSession`:

.Registering a Calendar
====
[source,java]
----
ksession.getCalendars().set( "weekday", weekDayCal );
----
====

They can be used in conjunction with normal rules and rules including timers. The rule attribute 
"calendars" may contain one or more comma-separated calendar names written as string literals.

.Using Calendars and Timers together
====
[source,java]
----
rule "weekdays are high priority"
   calendars "weekday"
   timer (int:0 1h)
when 
    Alarm()
then
    send( "priority high - we have an alarm" );
end 

rule "weekend are low priority"
   calendars "weekend"
   timer (int:0 4h)
when 
    Alarm()
then
    send( "priority low - we have an alarm" );
end
----
====

== Left Hand Side (when) syntax

=== What is the Left Hand Side?


The Left Hand Side (LHS) is a common name for the conditional part of the rule.
It consists of zero or more Conditional Elements.
If the LHS is empty, it will be considered as a condition element that is always true and it will be activated once, when a new WorkingMemory session is created.

.Left Hand Side
image::LanguageReference/lhs.png[align="center"]


.Rule without a Conditional Element
====
[source]
----
rule "no CEs"
when
    // empty
then
    ... // actions (executed once)
end

// The above rule is internally rewritten as:

rule "eval(true)"
when
    eval( true )
then
    ... // actions (executed once)
end
----
====

Conditional elements work on one or more _patterns_ (which are described below). The most common 
conditional element is " `and"`. Therefore it is implicit when you have multiple patterns in the 
LHS of a rule that are not connected in any way:

.Implicit and
====
[source]
----
rule "2 unconnected patterns"
when
    Pattern1()
    Pattern2()
then
    ... // actions
end

// The above rule is internally rewritten as:

rule "2 and connected patterns"
when
    Pattern1()
    and Pattern2()
then
    ... // actions
end
----
====

[NOTE]
====
An "`and`" cannot have a leading declaration binding (unlike for example `or`). This is obvious, 
since a declaration can only reference a single fact at a time, and when the "`and`" is satisfied 
it matches both facts - so which fact would the declaration bind to?

[source]
----
// Compile error
$person : (Person( name == "Romeo" ) and Person( name == "Juliet"))
----
====

=== Pattern (conditional element)

==== What is a pattern?


A pattern element is the most important Conditional Element.
It can potentially match on each fact that is inserted in the working memory.

A pattern contains of zero or more constraints and has an optional pattern binding.
The railroad diagram below shows the syntax for this.

.Pattern
image::LanguageReference/pattern.png[align="center"]


In its simplest form, with no constraints, a pattern matches against a fact of the given type.
In the following case the type is `Cheese`, which means that the pattern will match against all `Person` objects in the Working Memory:

[source]
----
Person()
----


The type need not be the actual class of some fact object.
Patterns may refer to superclasses or even interfaces, thereby potentially matching facts from many different classes.

[source]
----
Object() // matches all objects in the working memory
----


Inside of the pattern parenthesis is where all the action happens: it defines the constraints for that pattern.
For example, with a age related constraint:

[source]
----
Person( age == 100 )
----

[NOTE]
====
For backwards compatibility reasons it's allowed to suffix patterns with the `;` character.
But it is not recommended to do that.
====

==== Pattern binding


For referring to the matched object, use a pattern binding variable such as `$p`.

.Pattern with a binding variable
====
[source]
----
rule ...
when
    $p : Person()
then
    System.out.println( "Person " + $p );
end
----
====


The prefixed dollar symbol (`$`) is just a convention; it can be useful in complex rules where it helps to easily differentiate between variables and fields, but it is not mandatory.

=== Constraint (part of a pattern)

==== What is a constraint?


A constraint is an expression that returns `true` or `false`.
This example has a constraint that states __5 is smaller than
        6__:

[source]
----
Person( 5 < 6 )  // just an example, as constraints like this would be useless in a real pattern
----


In essence, it's a Java expression with some enhancements (such as property access) and a few differences (such as `equals()` semantics for `==`). Let's take a deeper look.

==== Property access on Java Beans (POJO's)


Any bean property can be used directly.
A bean property is exposed using a standard Java bean getter: a method `getMyProperty()` (or `isMyProperty()` for a primitive boolean) which takes no arguments and return something.
For example: the age property is written as `age` in DRL instead of the getter `getAge()`:

[source]
----
Person( age == 50 )

// this is the same as:
Person( getAge() == 50 )
----


Drools uses the standard JDK `Introspector` class to do this mapping, so it follows the standard Java bean specification.

[NOTE]
====
We recommend using property access (`age`) over using getters explicitly (`getAge()`) because of performance enhancements through field indexing.
====

[WARNING]
====
Property accessors must not change the state of the object in a way that may effect the rules.
Remember that the rule engine effectively caches the results of its matching in between invocations to make it faster.

[source]
----
public int getAge() {
    age++; // Do NOT do this
    return age;
}
----

[source]
----
public int getAge() {
    Date now = DateUtil.now(); // Do NOT do this
    return DateUtil.differenceInYears(now, birthday);
}
----

To solve this latter case, insert a fact that wraps the current date into working memory and update that fact between `fireAllRules` as needed.
====

[NOTE]
====
The following fallback applies: if the getter of a property cannot be found, the compiler will resort to using the property name as a method name and without arguments:

[source]
----
Person( age == 50 )

// If Person.getAge() does not exists, this falls back to:
Person( age() == 50 )
----
====


Nested property access is also supported:

[source]
----
Person( address.houseNumber == 50 )

// this is the same as:
Person( getAddress().getHouseNumber() == 50 )
----


Nested properties are also indexed.

[WARNING]
====
In a stateful session, care should be taken when using nested accessors as the Working Memory is not aware of any of the nested values, and does not know when they change.
Either consider them immutable while any of their parent references are inserted into the Working Memory.
Or, instead, if you wish to modify a nested value you should mark all of the outer facts as updated.
In the above example, when the `houseNumber` changes, any `Person` with that `Address` must be marked as updated.
====

==== Java expression


You can use any Java expression that returns a `boolean` as a constraint inside the parentheses of a pattern.
Java expressions can be mixed with other expression enhancements, such as property access:

[source]
----
Person( age == 50 )
----


It is possible to change the evaluation priority by using parentheses, as in any logic or mathematical expression:

[source]
----
Person( age > 100 && ( age % 10 == 0 ) )
----


It is possible to reuse Java methods:

[source]
----
Person( Math.round( weight / ( height * height ) ) < 25.0 )
----

[WARNING]
====
As for property accessors, methods must not change the state of the object in a way that may affect the rules.
Any method executed on a fact in the LHS should be a _read
          only_ method.

[source]
----
Person( incrementAndGetAge() == 10 ) // Do NOT do this
----
====

[WARNING]
====
The state of a fact should not change between rule invocations (unless those facts are marked as updated to the working memory on every change):

[source]
----
Person( System.currentTimeMillis() % 1000 == 0 ) // Do NOT do this
----
====


Normal Java operator precedence applies, see the operator precedence list below.

[IMPORTANT]
====
All operators have normal Java semantics except for `==` and ``!=``.

The `==` operator has null-safe `equals()` semantics:

[source]
----
// Similar to: java.util.Objects.equals(person.getFirstName(), "John")
// so (because "John" is not null) similar to:
// "John".equals(person.getFirstName())
Person( firstName == "John" )
----

The `!=` operator has null-safe `!equals()` semantics:

[source]
----
// Similar to: !java.util.Objects.equals(person.getFirstName(), "John")
Person( firstName != "John" )
----
====


Type coercion is always attempted if the field and the value are of different types; exceptions will be thrown if a bad coercion is attempted.
For instance, if "ten" is provided as a string in a numeric evaluator, an exception is thrown, whereas "10" would coerce to a numeric 10.
Coercion is always in favor of the field type and not the value type:

[source]
----
Person( age == "10" ) // "10" is coerced to 10
----

==== Comma separated AND


The comma character ('``,``') is used to separate constraint groups.
It has implicit _AND_ connective semantics.

[source]
----
// Person is at least 50 and weighs at least 80 kg
Person( age > 50, weight > 80 )
----

[source]
----
// Person is at least 50, weighs at least 80 kg and is taller than 2 meter.
Person( age > 50, weight > 80, height > 2 )
----

[NOTE]
====
Although the `&&` and `,` operators have the same semantics, they are resolved with different priorities: The `&&` operator precedes the `||` operator.
Both the `&&` and `||` operator precede the `,` operator.
See the operator precedence list below.

The comma operator should be preferred at the top level constraint, as it makes constraints easier to read and the engine will often be able to optimize them better.
====


The comma (``,``) operator cannot be embedded in a composite constraint expression, such as parentheses:

[source]
----
Person( ( age > 50, weight > 80 ) || height > 2 ) // Do NOT do this: compile error

// Use this instead
Person( ( age > 50 && weight > 80 ) || height > 2 )
----

==== Binding variables


A property can be bound to a variable:

[source]
----
// 2 persons of the same age
Person( $firstAge : age ) // binding
Person( age == $firstAge ) // constraint expression
----


The prefixed dollar symbol (``$``) is just a convention; it can be useful in complex rules where it helps to easily differentiate between variables and fields.

[NOTE]
====
For backwards compatibility reasons, It's allowed (but not recommended) to mix a constraint binding and constraint expressions as such:

[source]
----
// Not recommended
Person( $age : age * 2 < 100 )
----

[source]
----
// Recommended (separates bindings and constraint expressions)
Person( age * 2 < 100, $age : age )
----
====


Bound variable restrictions using the operator `==` provide for very fast execution as it use hash indexing to improve performance.

==== Unification


Drools does not allow bindings to the same declaration.
However this is an important aspect to derivation query unification.
While positional arguments are always processed with unification a special unification symbol, ':=', was introduced for named arguments named arguments.
The following "unifies" the age argument across two people.

[source]
----
Person( $age := age ) 
Person( $age := age)
----


In essence unification will declare a binding for the first occurrence and constrain to the same value of the bound field for sequence occurrences.

==== Grouped accessors for nested objects


Often it happens that it is necessary to access multiple properties of a nested object as in the following example

[source]
----
Person( name == "mark", address.city == "london", address.country == "uk" )
----


These accessors to nested objects can be grouped with a '.(...)' syntax providing more readable rules as in

[source]
----
Person( name == "mark", address.( city == "london", country == "uk") )
----


Note the '.' prefix, this is necessary to differentiate the nested object constraints from a method call.

==== Inline casts and coercion


When dealing with nested objects, it also quite common the need to cast to a subtype.
It is possible to do that via the # symbol as in:

[source]
----
Person( name == "mark", address#LongAddress.country == "uk" )
----


This example casts Address to LongAddress, making its getters available.
If the cast is not possible (instanceof returns false), the evaluation will be considered false.
Also fully qualified names are supported:

[source]
----
Person( name == "mark", address#org.domain.LongAddress.country == "uk" )
----


It is possible to use multiple inline casts in the same expression:

[source]
----
Person( name == "mark", address#LongAddress.country#DetailedCountry.population > 10000000 )
----


moreover, since we also support the instanceof operator, if that is used we will infer its results for further uses of that field, within that pattern:

[source]
----
Person( name == "mark", address instanceof LongAddress, address.country == "uk" )
----

==== Special literal support


Besides normal Java literals (including Java 5 enums), this literal is also supported:

==== Date literal


The date format `dd-mmm-yyyy` is supported by default.
You can customize this by providing an alternative date format mask as the System property named ``drools.dateformat``.
If more control is required, use a restriction.

.Date Literal Restriction
====
[source]
----
Cheese( bestBefore < "27-Oct-2009" )
----
====

==== List and Map access


It's possible to directly access a `List` value by index:

[source]
----
// Same as childList(0).getAge() == 18
Person( childList[0].age == 18 )
----


It's also possible to directly access a `Map` value by key:

[source]
----
// Same as credentialMap.get("jsmith").isValid()
Person( credentialMap["jsmith"].valid )
----

==== Abbreviated combined relation condition


This allows you to place more than one restriction on a field using the restriction connectives `&&` or ``||``.
Grouping via parentheses is permitted, resulting in a recursive syntax pattern.

.Abbreviated combined relation condition
image::LanguageReference/abbreviatedCombinedRelationCondition.png[align="center"]


.Abbreviated combined relation condition withparentheses
image::LanguageReference/abbreviatedCombinedRelationConditionGroup.png[align="center"]


[source]
----
// Simple abbreviated combined relation condition using a single &&
Person( age > 30 && < 40 )
----

{empty}

[source]
----
// Complex abbreviated combined relation using groupings
Person( age ( (> 30 && < 40) ||
              (> 20 && < 25) ) )
----

{empty}

[source]
----
// Mixing abbreviated combined relation with constraint connectives
Person( age > 30 && < 40 || location == "london" )
----

==== Special DRL operators

.Operators
image::LanguageReference/operator.png[align="center"]


Coercion to the correct value for the evaluator and the field will be attempted.

==== The operators `< <= > >=`


These operators can be used on properties with natural ordering.
For example, for Date fields, `<` means __before__, for `String` fields, it means alphabetically lower.

[source]
----
Person( firstName < $otherFirstName )
----

{empty}

[source]
----
Person( birthDate < $otherBirthDate )
----


Only applies on `Comparable` properties.

==== Null-safe dereferencing operator


The !. operator allows to derefencing in a null-safe way.
More in details the matching algorithm requires the value to the left of the !. operator to be not null in order to give a positive result for pattern matching itself.
In other words the pattern:

[source]
----
Person( $streetName : address!.street )
----


will be internally translated in:

[source]
----
Person( address != null, $streetName : address.street )
----

==== The operator `matches`


Matches a field against any valid Java 
(((regular expression)))
Regular Expression.
Typically that regexp is a string literal, but variables that resolve to a valid regexp are also allowed.

.Regular Expression Constraint
====
[source]
----
Cheese( type matches "(Buffalo)?\\S*Mozarella" )
----
====

[NOTE]
====
Like in Java, regular expressions written as string literals __need to escape '\\'__.
====


Only applies on `String` properties.
Using `matches` against a `null` value always evaluates to false.

==== The operator `not matches`


The operator returns true if the String does not match the regular expression.
The same rules apply as for the `matches` operator.
Example:

.Regular Expression Constraint
====
[source]
----
Cheese( type not matches "(Buffulo)?\\S*Mozarella" )
----
====


Only applies on `String` properties.
Using `not matches` against a `null` value always evaluates to true.

==== The operator `contains`


The operator `contains` is used to check whether a field that is a 
(((Collection)))
Collection or elements contains the specified value.

.Contains with Collections
====
[source]
----
CheeseCounter( cheeses contains "stilton" ) // contains with a String literal
CheeseCounter( cheeses contains $var ) // contains with a variable
----
====


Only applies on `Collection` properties.

The operator `contains` can also be used in place of `String.contains()` constraints checks.

.Contains with String literals
====
[source]
----
Cheese( name contains "tilto" )
Person( fullName contains "Jr" )
String( this contains "foo" )
----
====

==== The operator `not contains`


The operator `not contains` is used to check whether a field that is a 
(((Collection)))
Collection or elements does _not_ contain the specified value.

.Literal Constraint with Collections
====
[source]
----
CheeseCounter( cheeses not contains "cheddar" ) // not contains with a String literal
CheeseCounter( cheeses not contains $var ) // not contains with a variable
----
====


Only applies on `Collection` properties.

[NOTE]
====
__For backward compatibility, the `excludes` operator is supported as a synonym for ``not contains``.__
====


The operator `not contains` can also be used in place of the logical negation of `String.contains()` for constraints checks - i.e.: `! String.contains()`

.Contains with String literals
====
[source]
----
Cheese( name not contains "tilto" )
Person( fullName not contains "Jr" )
String( this not contains "foo" )
----
====

==== The operator `memberOf`


The operator `memberOf` is used to check whether a field is a member of a collection or elements; that collection must be a variable.

.Literal Constraint with Collections
====
[source]
----
CheeseCounter( cheese memberOf $matureCheeses )
----
====

==== The operator `not memberOf`


The operator `not memberOf` is used to check whether a field is not a member of a collection or elements; that collection must be a variable.

.Literal Constraint with Collections
====
[source]
----
CheeseCounter( cheese not memberOf $matureCheeses )
----
====

==== The operator `soundslike`


This operator is similar to ``matches``, but it checks whether a word has almost the same sound (using English pronunciation) as the given value.
This is based on the Soundex algorithm (see ``http://en.wikipedia.org/wiki/Soundex``).

.Test with soundslike
====
[source]
----
// match cheese "fubar" or "foobar"
Cheese( name soundslike 'foobar' )
----
====

==== The operator `str`


This operator `str` is used to check whether a field that is a `String` starts with or ends with a certain value.
It can also be used to check the length of the String.

[source]
----
Message( routingValue str[startsWith] "R1" )
----

{empty}

[source]
----
Message( routingValue str[endsWith] "R2" )
----

{empty}

[source]
----
Message( routingValue str[length] 17 )
----

==== The operators `in` and `notin` (compound value restriction)


The compound value restriction is used where there is more than one possible value to match.
Currently only the `in` and `not in` evaluators support this.
The second operand of this operator must be a comma-separated list of values, enclosed in parentheses.
Values may be given as variables, literals, return values or qualified identifiers.
Both evaluators are actually __syntactic
          sugar__, internally rewritten as a list of multiple restrictions using the operators `!=` and ``==``.

.compoundValueRestriction
image::LanguageReference/compoundValueRestriction.png[align="center"]


.Compound Restriction using "in"
====
[source]
----
Person( $cheese : favouriteCheese )
Cheese( type in ( "stilton", "cheddar", $cheese ) )
----
====

==== Inline eval operator (deprecated)

.Inline Eval Expression
image::LanguageReference/inlineEvalConstraint.png[align="center"]


An 
(((Predicate)))
inline eval constraint can use any valid dialect expression as long as it results to a primitive boolean.
The expression must be constant over time.
Any previously bound variable, from the current or previous pattern, can be used; autovivification is also used to auto-create field binding variables.
When an identifier is found that is not a current variable, the builder looks to see if the identifier is a field on the current object type, if it is, the field binding is auto-created as a variable of the same name.
This is called autovivification of field variables inside of inline eval's.

This example will find all male-female pairs where the male is 2 years older than the female; the variable `age` is auto-created in the second pattern by the autovivification process.

.Return Value operator
====
[source]
----
Person( girlAge : age, sex = "F" )
Person( eval( age == girlAge + 2 ), sex = 'M' ) // eval() is actually obsolete in this example
----
====

[NOTE]
====
Inline eval's are effectively obsolete as their inner syntax is now directly supported.
It's recommended not to use them.
Simply write the expression without wrapping eval() around it.
====

==== Operator precedence


The operators are evaluated in this precedence:

.Operator precedence
[cols="1,1,1", options="header"]
|===
| Operator type
| Operators
| Notes

|(nested / null safe) property access
|``$$.$$````!.``
|Not normal Java semantics

|List/Map access
|``[ ]``
|Not normal Java semantics

|constraint binding
|``:``
|Not normal Java semantics

|multiplicative
|``\*````/````%``
|

|additive
|``\+````-``
|

|shift
|``<<````>>````>>>``
|

|relational
|``<````>````<=````>=````instanceof``
|

|equality
|``==````!=``
|Does not use normal Java (__not__)
                _same_ semantics: uses
                (__not__) _equals_
                semantics instead.

|non-short circuiting AND
|``&``
|

|non-short circuiting exclusive OR
|``^``
|

|non-short circuiting inclusive OR
|``\|``
|

|logical AND
|``&&``
|

|logical OR
|``\|\|``
|

|ternary
|``? :``
|

|Comma separated AND
|``,``
|Not normal Java semantics
|===

=== Positional Arguments


Patterns now support positional arguments on type declarations.

Positional arguments are ones where you don't need to specify the field name, as the position maps to a known named field.
i.e.
Person( name == "mark" ) can be rewritten as Person( "mark"; ). The semicolon ';' is important so that the engine knows that everything before it is a positional argument.
Otherwise we might assume it was a boolean expression, which is how it could be interpreted after the semicolon.
You can mix positional and named arguments on a pattern by using the semicolon ';' to separate them.
Any variables used in a positional that have not yet been bound will be bound to the field that maps to that position.

[source]
----
declare Cheese
    name : String
    shop : String
    price : int
end
----


Example patterns, with two constraints and a binding.
Remember semicolon ';' is used to differentiate the positional section from the named argument section.
Variables and literals and expressions using just literals are supported in positional arguments, but not variables.
Positional arguments are always resolved using unification.

[source]
----
Cheese( "stilton", "Cheese Shop", p; )
Cheese( "stilton", "Cheese Shop"; p : price )
Cheese( "stilton"; shop == "Cheese Shop", p : price )
Cheese( name == "stilton"; shop == "Cheese Shop", p : price )
----


Positional arguments that are given a previously declared binding will constrain against that using unification; these are referred to as input arguments.
If the binding does not yet exist, it will create the declaration binding it to the field represented by the position argument; these are referred to as output arguments.

=== Fine grained property change listeners


When you call modify() (see the modify statement section) on a given object it will trigger a revaluation of all patterns of the matching object type in the knowledge base.
This can can lead to unwanted and useless evaluations and in the worst cases to infinite recursions.
The only workaround to avoid it was to split up your objects into smaller ones having a 1 to 1 relationship with the original object.

This feature allows the pattern matching to only react to modification of properties actually constrained or bound inside of a given pattern.
That will help with performance and recursion and avoid artificial object splitting.

By default this feature is off in order to make the behavior of the rule engine backward compatible with the former releases.
When you want to activate it on a specific bean you have to annotate it with @propertyReactive.
This annotation works both on DRL type declarations:

[source]
----
declare Person
@propertyReactive
    firstName : String
    lastName : String
end
----


and on Java classes:

[source]
----
@PropertyReactive
    public static class Person {
    private String firstName;
    private String lastName;
}
----


In this way, for instance, if you have a rule like the following:

[source]
----
rule "Every person named Mario is a male" when
    $person : Person( firstName == "Mario" )
then
    modify ( $person )  { setMale( true ) }
end
----


you won't have to add the no-loop attribute to it in order to avoid an infinite recursion because the engine recognizes that the pattern matching is done on the 'firstName' property while the RHS of the rule modifies the 'male' one.
Note that this feature does not work for update(), and this is one of the reasons why we promote modify() since it encapsulates the field changes within the statement.
Moreover, on Java classes, you can also annotate any method to say that its invocation actually modifies other properties.
For instance in the former Person class you could have a method like:

[source]
----
@Modifies( { "firstName", "lastName" } )
public void setName(String name) {
    String[] names = name.split("\\s");
    this.firstName = names[0];
    this.lastName = names[1];
}
----


That means that if a rule has a RHS like the following:

[source]
----
modify($person) { setName("Mario Fusco") }
----


it will correctly recognize that the values of both properties 'firstName' and 'lastName' could have potentially been modified and act accordingly, not missing of reevaluating the patterns constrained on them.
At the moment the usage of @Modifies is not allowed on fields but only on methods.
This is coherent with the most common scenario where the @Modifies will be used for methods that are not related with a class field as in the Person.setName() in the former example.
Also note that @Modifies is not transitive, meaning that if another method internally invokes the Person.setName() one it won't be enough to annotate it with @Modifies( { "name" } ), but it is necessary to use @Modifies( { "firstName", "lastName" } ) even on it.
Very likely @Modifies transitivity will be implemented in the next release.

For what regards nested accessors, the engine will be notified only for top level fields.
In other words a pattern matching like:

[source]
----
Person ( address.city.name == "London )
----


will be revaluated only for modification of the 'address' property of a Person object.
In the same way the constraints analysis is currently strictly limited to what there is inside a pattern.
Another example could help to clarify this.
An LHS like the following:

[source]
----
$p : Person( )
Car( owner = $p.name )
----


will not listen on modifications of the person's name, while this one will do:

[source]
----
Person( $name : name )
Car( owner = $name )
----


To overcome this problem it is possible to annotate a pattern with @watch as it follows:

[source]
----
$p : Person( ) @watch ( name )
Car( owner = $p.name )
----


Indeed, annotating a pattern with @watch allows you to modify the inferred set of properties for which that pattern will react.
Note that the properties named in the @watch annotation are actually added to the ones automatically inferred, but it is also possible to explicitly exclude one or more of them prepending their name with a ! and to make the pattern to listen for all or none of the properties of the type used in the pattern respectively with the wildcrds * and !*. So, for example, you can annotate a pattern in the LHS of a rule like:

[source]
----
// listens for changes on both firstName (inferred) and lastName
Person( firstName == $expectedFirstName ) @watch( lastName )

// listens for all the properties of the Person bean
Person( firstName == $expectedFirstName ) @watch( * )

// listens for changes on lastName and explicitly exclude firstName
Person( firstName == $expectedFirstName ) @watch( lastName, !firstName )

// listens for changes on all the properties except the age one
Person( firstName == $expectedFirstName ) @watch( *, !age )
----


Since doesn't make sense to use this annotation on a pattern using a type not annotated with @PropertyReactive the rule compiler will raise a compilation error if you try to do so.
Also the duplicated usage of the same property in @watch (for example like in: @watch( firstName, ! firstName ) ) will end up in a compilation error.
In a next release we will make the automatic detection of the properties to be listened smarter by doing analysis even outside of the pattern.

It also possible to enable this feature by default on all the types of your model or to completely disallow it by using on option of the KnowledgeBuilderConfiguration.
In particular this new PropertySpecificOption can have one of the following 3 values:

[source]
----
- DISABLED => the feature is turned off and all the other related annotations are just ignored
- ALLOWED => this is the default behavior: types are not property reactive unless they are not annotated with @PropertySpecific
- ALWAYS => all types are property reactive by default
----


So, for example, to have a KnowledgeBuilder generating property reactive types by default you could do:

[source]
----
KnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration();
config.setOption(PropertySpecificOption.ALWAYS);
KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);
----


In this last case it will be possible to disable the property reactivity feature on a specific type by annotating it with @ClassReactive.

=== Basic conditional elements

==== Conditional Element `and`


The Conditional Element `"and"` is used to group other Conditional Elements into a logical conjunction.
Drools supports both prefix `and` and infix ``and``.

.infixAnd
image::LanguageReference/infixAnd.png[align="center"]


Traditional infix `and` is supported:

[source]
----
//infixAnd
Cheese( cheeseType : type ) and Person( favouriteCheese == cheeseType )
----


Explicit grouping with parentheses is also supported:

[source]
----
//infixAnd with grouping
( Cheese( cheeseType : type ) and
  ( Person( favouriteCheese == cheeseType ) or 
    Person( favouriteCheese == cheeseType ) )
----

[NOTE]
====
The symbol `&&` (as an alternative to ``and``) is deprecated.
But it is still supported in the syntax for backwards compatibility.
====

.prefixAnd
image::LanguageReference/prefixAnd.png[align="center"]


Prefix `and` is also supported:

[source]
----
(and Cheese( cheeseType : type )
     Person( favouriteCheese == cheeseType ) )
----


The root element of the LHS is an implicit prefix `and` and doesn't need to be specified:

.implicit root prefixAnd
====
[source]
----
when
    Cheese( cheeseType : type )
    Person( favouriteCheese == cheeseType )
then
    ...
----
====

==== Conditional Element `or`


The Conditional Element `or` is used to group other Conditional Elements into a logical disjunction.
Drools supports both prefix `or` and infix ``or``.

.infixOr
image::LanguageReference/infixOr.png[align="center"]


Traditional infix `or` is supported:

[source]
----
//infixOr
Cheese( cheeseType : type ) or Person( favouriteCheese == cheeseType )
----


Explicit grouping with parentheses is also supported:

[source]
----
//infixOr with grouping
( Cheese( cheeseType : type ) or
  ( Person( favouriteCheese == cheeseType ) and
    Person( favouriteCheese == cheeseType ) )
----

[NOTE]
====
The symbol `||` (as an alternative to ``or``) is deprecated.
But it is still supported in the syntax for backwards compatibility.
====

.prefixOr
image::LanguageReference/prefixOr.png[align="center"]


Prefix `or` is also supported:

[source]
----
(or Person( sex == "f", age > 60 )
    Person( sex == "m", age > 65 )
----

[NOTE]
====
The behavior of the Conditional Element `or` is different from the connective `||` for constraints and restrictions in field constraints.
The engine actually has no understanding of the Conditional Element ``or``.
Instead, via a number of different logic transformations, a rule with `or` is rewritten as a number of subrules.
This process ultimately results in a rule that has a single `or` as the root node and one subrule for each of its CEs.
Each subrule can activate and fire like any normal rule; there is no special behavior or interaction between these subrules.
- This can be most confusing to new rule authors.
====


The Conditional Element `or` also allows for optional pattern binding.
This means that each resulting subrule will bind its pattern to the pattern binding.
Each pattern must be bound separately, using eponymous variables:

[source]
----
pensioner : ( Person( sex == "f", age > 60 ) or Person( sex == "m", age > 65 ) )
----

[source]
----
(or pensioner : Person( sex == "f", age > 60 ) 
    pensioner : Person( sex == "m", age > 65 ) )
----


Since the conditional element `or` results in multiple subrule generation, one for each possible logically outcome, the example above would result in the internal generation of two rules.
These two rules work independently within the Working Memory, which means both can match, activate and fire - there is no shortcutting.

The best way to think of the conditional element `or` is as a shortcut for generating two or more similar rules.
When you think of it that way, it's clear that for a single rule there could be multiple activations if two or more terms of the disjunction are true.

==== Conditional Element `not`

.not
image::LanguageReference/not.png[align="center"]


The CE `not` is first order logic's non-existential quantifier and checks for the non-existence of something in the Working Memory.
Think of "not" as meaning "there must be none of...".

The keyword `not` may be followed by parentheses around the CEs that it applies to.
In the simplest case of a single pattern (like below) you may optionally omit the parentheses.

.No Busses
====
[source]
----
not Bus()
----
====

.No red Busses
====
[source]
----
// Brackets are optional:
not Bus(color == "red")
// Brackets are optional:
not ( Bus(color == "red", number == 42) )
// "not" with nested infix and - two patterns,
// brackets are requires:
not ( Bus(color == "red") and
      Bus(color == "blue") )
----
====

==== Conditional Element `exists`

.exists
image::LanguageReference/exists.png[align="center"]


The CE `exists` is first order logic's existential quantifier and checks for the existence of something in the Working Memory.
Think of "exists" as meaning "there is at least one..". It is different from just having the pattern on its own, which is more like saying "for each one of...". If you use `exists` with a pattern, the rule will only activate at most once, regardless of how much data there is in working memory that matches the condition inside of the `exists` pattern.
Since only the existence matters, no bindings will be established.

The keyword `exists` must be followed by parentheses around the CEs that it applies to.
In the simplest case of a single pattern (like below) you may omit the parentheses.

.At least one Bus
====
[source]
----
exists Bus()
----
====

.At least one red Bus
====
[source]
----
exists Bus(color == "red")
// brackets are optional:
exists ( Bus(color == "red", number == 42) )
// "exists" with nested infix and,
// brackets are required:
exists ( Bus(color == "red") and
         Bus(color == "blue") )
----
====

=== Advanced conditional elements

==== Conditional Element `forall`

.forall
image::LanguageReference/forall.png[align="center"]


The Conditional Element `forall` completes the First Order Logic support in Drools.
The Conditional Element `forall` evaluates to true when all facts that match the first pattern match all the remaining patterns.
Example:

[source]
----
rule "All English buses are red"
when
    forall( $bus : Bus( type == 'english') 
                   Bus( this == $bus, color = 'red' ) )
then
    // all English buses are red
end
----


In the above rule, we "select" all Bus objects whose type is "english". Then, for each fact that matches this pattern we evaluate the following patterns and if they match, the forall CE will evaluate to true.

To state that all facts of a given type in the working memory must match a set of constraints, `forall` can be written with a single pattern for simplicity.
Example:

.Single Pattern Forall
====
[source]
----
rule "All Buses are Red"
when
    forall( Bus( color == 'red' ) )
then
    // all Bus facts are red
end
----
====


Another example shows multiple patterns inside the ``forall``:

.Multi-Pattern Forall
====
[source]
----
rule "all employees have health and dental care programs"
when
    forall( $emp : Employee()
            HealthCare( employee == $emp )
            DentalCare( employee == $emp )
          )
then
    // all employees have health and dental care
end
----
====


Forall can be nested inside other CEs.
For instance, `forall` can be used inside a `not` CE.
Note that only single patterns have optional parentheses, so that with a nested `forall` parentheses must be used:

.Combining Forall with Not CE
====
[source]
----
rule "not all employees have health and dental care"
when 
    not ( forall( $emp : Employee()
                  HealthCare( employee == $emp )
                  DentalCare( employee == $emp ) ) 
        )
then
    // not all employees have health and dental care
end
----
====


As a side note, `forall( p1 p2 p3...)` is equivalent to writing:

[source]
----
not(p1 and not(and p2 p3...))
----


Also, it is important to note that `forall` is a __scope delimiter__.
Therefore, it can use any previously bound variable, but no variable bound inside it will be available for use outside of it.

==== Conditional Element `from`

.from
image::LanguageReference/from.png[align="center"]


The Conditional Element `from` enables users to specify an arbitrary source for data to be matched by LHS patterns.
This allows the engine to reason over data not in the Working Memory.
The data source could be a sub-field on a bound variable or the results of a method call.
It is a powerful construction that allows out of the box integration with other application components and frameworks.
One common example is the integration with data retrieved on-demand from databases using hibernate named queries.

The expression used to define the object source is any expression that follows regular MVEL syntax.
Therefore, it allows you to easily use object property navigation, execute method calls and access maps and collections elements.

Here is a simple example of reasoning and binding on another pattern sub-field:

[source]
----
rule "validate zipcode"
when
    Person( $personAddress : address ) 
    Address( zipcode == "23920W") from $personAddress 
then
    // zip code is ok
end
----


With all the flexibility from the new expressiveness in the Drools engine you can slice and dice this problem many ways.
This is the same but shows how you can use a graph notation with the 'from':

[source]
----
rule "validate zipcode"
when
    $p : Person( ) 
    $a : Address( zipcode == "23920W") from $p.address 
then
    // zip code is ok
end
----


Previous examples were evaluations using a single pattern.
The CE `from` also support object sources that return a collection of objects.
In that case, `from` will iterate over all objects in the collection and try to match each of them individually.
For instance, if we want a rule that applies 10% discount to each item in an order, we could do:

[source]
----
rule "apply 10% discount to all items over US$ 100,00 in an order"
when
    $order : Order()
    $item  : OrderItem( value > 100 ) from $order.items
then
    // apply discount to $item
end
----


The above example will cause the rule to fire once for each item whose value is greater than 100 for each given order.

You must take caution, however, when using ``from``, especially in conjunction with the `lock-on-active` rule attribute as it may produce unexpected results.
Consider the example provided earlier, but now slightly modified as follows:

[source]
----
rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( state == "NC") from $p.address 
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person( ) 
    $a : Address( city == "Raleigh") from $p.address 
then
    modify ($p) {} // Apply discount to person in a modify block
end
----


In the above example, persons in Raleigh, NC should be assigned to sales region 1 and receive a discount; i.e., you would expect both rules to activate and fire.
Instead you will find that only the second rule fires.

If you were to turn on the audit log, you would also see that when the second rule fires, it deactivates the first rule.
Since the rule attribute `lock-on-active` prevents a rule from creating new activations when a set of facts change, the first rule fails to reactivate.
Though the set of facts have not changed, the use of `from` returns a new fact for all intents and purposes each time it is evaluated.

First, it's important to review why you would use the above pattern.
You may have many rules across different rule-flow groups.
When rules modify working memory and other rules downstream of your RuleFlow (in different rule-flow groups) need to be reevaluated, the use of `modify` is critical.
You don't, however, want other rules in the same rule-flow group to place activations on one another recursively.
In this case, the `no-loop` attribute is ineffective, as it would only prevent a rule from activating itself recursively.
Hence, you resort to ``lock-on-active``.

There are several ways to address this issue:

* Avoid the use of `from` when you can assert all facts into working memory or use nested object references in your constraint expressions (shown below).
* Place the variable assigned used in the modify block as the last sentence in your condition (LHS).
* Avoid the use of `lock-on-active` when you can explicitly manage how rules within the same rule-flow group place activations on one another (explained below).


The preferred solution is to minimize use of `from` when you can assert all your facts into working memory directly.
In the example above, both the Person and Address instance can be asserted into working memory.
In this case, because the graph is fairly simple, an even easier solution is to modify your rules as follows:

[source]
----
rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.state == "NC" )  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person(address.city == "Raleigh" )  
then
    modify ($p) {} //Apply discount to person in a modify block
end
----


Now, you will find that both rules fire as expected.
However, it is not always possible to access nested facts as above.
Consider an example where a Person holds one or more Addresses and you wish to use an existential quantifier to match people with at least one address that meets certain conditions.
In this case, you would have to resort to the use of `from` to reason over the collection.

There are several ways to use `from` to achieve this and not all of them exhibit an issue with the use of ``lock-on-active``.
For example, the following use of `from` causes both rules to fire as expected:

[source]
----
rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(state == "NC") from $addresses)  
then
    modify ($p) {} // Assign person to sales region 1 in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $p : Person($addresses : addresses)
    exists (Address(city == "Raleigh") from $addresses)  
then
    modify ($p) {} // Apply discount to person in a modify block
end
----


However, the following slightly different approach does exhibit the problem:

[source]
----
rule "Assign people in North Carolina (NC) to sales region 1"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses
    exists (Address( state == "NC") from $addresses) 
then
    modify ($assessment) {} // Modify assessment in a modify block
end

rule "Apply a discount to people in the city of Raleigh"
ruleflow-group "test"
lock-on-active true
when
    $assessment : Assessment()
    $p : Person()
    $addresses : List() from $p.addresses 
    exists (Address( city == "Raleigh") from $addresses)
then
    modify ($assessment) {} // Modify assessment in a modify block
end
----


In the above example, the $addresses variable is returned from the use of ``from``.
The example also introduces a new object, assessment, to highlight one possible solution in this case.
If the $assessment variable assigned in the condition (LHS) is moved to the last condition in each rule, both rules fire as expected.

Though the above examples demonstrate how to combine the use of `from` with `lock-on-active` where no loss of rule activations occurs, they carry the drawback of placing a dependency on the order of conditions on the LHS.
In addition, the solutions present greater complexity for the rule author in terms of keeping track of which conditions may create issues.

A better alternative is to assert more facts into working memory.
In this case, a person's addresses may be asserted into working memory and the use of `from` would not be necessary.

There are cases, however, where asserting all data into working memory is not practical and we need to find other solutions.
Another option is to reevaluate the need for ``lock-on-active``.
An alternative to `lock-on-active` is to directly manage how rules within the same rule-flow group activate one another by including conditions in each rule that prevent rules from activating each other recursively when working memory is modified.
For example, in the case above where a discount is applied to citizens of Raleigh, a condition may be added to the rule that checks whether the discount has already been applied.
If so, the rule does not activate.

==== Conditional Element `collect`

.collect
image::LanguageReference/collect.png[align="center"]


The Conditional Element `collect` allows rules to reason over a collection of objects obtained from the given source or from the working memory.
In First Oder Logic terms this is the cardinality quantifier.
A simple example:

[source]
----
import java.util.ArrayList

rule "Raise priority if system has more than 3 pending alarms"
when
    $system : System()
    $alarms : ArrayList( size >= 3 )
              from collect( Alarm( system == $system, status == 'pending' ) )
then
    // Raise priority, because system $system has
    // 3 or more alarms pending. The pending alarms
    // are $alarms.
end
----


In the above example, the rule will look for all pending alarms in the working memory for each given system and group them in ArrayLists.
If 3 or more alarms are found for a given system, the rule will fire.

The result pattern of `collect` can be any concrete class that implements the `java.util.Collection` interface and provides a default no-arg public constructor.
This means that you can use Java collections like ArrayList, LinkedList, HashSet, etc., or your own class, as long as it implements the `java.util.Collection` interface and provide a default no-arg public constructor.

Both source and result patterns can be constrained as any other pattern.

Variables bound before the `collect` CE are in the scope of both source and result patterns and therefore you can use them to constrain both your source and result patterns.
But note that `collect` is a scope delimiter for bindings, so that any binding made inside of it is not available for use outside of it.

Collect accepts nested `from` CEs.
The following example is a valid use of "collect":

[source]
----
import java.util.LinkedList;

rule "Send a message to all mothers"
when
    $town : Town( name == 'Paris' )
    $mothers : LinkedList() 
               from collect( Person( gender == 'F', children > 0 ) 
                             from $town.getPeople() 
                           )
then
    // send a message to all mothers
end
----

==== Conditional Element `accumulate`

.accumulate
image::LanguageReference/accumulate.png[align="center"]


The Conditional Element `accumulate` is a more flexible and powerful form of ``collect``, in the sense that it can be used to do what `collect` does and also achieve results that the CE `collect` is not capable of achieving.
Accumulate allows a rule to iterate over a collection of objects, executing custom actions for each of the elements, and at the end, it returns a result object.

Accumulate supports both the use of pre-defined accumulate functions, or the use of inline custom code.
Inline custom code should be avoided though, as it is harder for rule authors to maintain, and frequently leads to code duplication.
Accumulate functions are easier to test and reuse.

The Accumulate CE also supports multiple different syntaxes.
The preferred syntax is the top level accumulate, as noted bellow, but all other syntaxes are supported for backward compatibility.

==== Accumulate CE (preferred syntax)


The top level accumulate syntax is the most compact and flexible syntax.
The simplified syntax is as follows:

++++
<programlisting><literal>accumulate( </literal><replaceable>&lt;source pattern&gt;</replaceable><literal>; </literal><replaceable>&lt;functions&gt;</replaceable><literal> [;</literal><replaceable>&lt;constraints&gt;</replaceable><literal>] )</literal></programlisting>
++++


For instance, a rule to calculate the minimum, maximum and average temperature reading for a given sensor and that raises an alarm if the minimum temperature is under 20C degrees and the average is over 70C degrees could be written in the following way, using Accumulate:

[NOTE]
====
The DRL language defines "``acc``" as a synonym of "``accumulate``". The author might prefer to use "``acc``" as a less verbose keyword or the full keyword "``accumulate``" for legibility.
====

[source]
----
rule "Raise alarm"
when
    $s : Sensor()
    accumulate( Reading( sensor == $s, $temp : temperature );
                $min : min( $temp ),
                $max : max( $temp ),
                $avg : average( $temp );
                $min < 20, $avg > 70 )
then
    // raise the alarm
end
----


In the above example, min, max and average are Accumulate Functions and will calculate the minimum, maximum and average temperature values over all the readings for each sensor.

Drools ships with several built-in accumulate functions, including:

* average
* min
* max
* count
* sum
* collectList
* collectSet


These common functions accept any expression as input.
For instance, if someone wants to calculate the average profit on all items of an order, a rule could be written using the average function:

[source]
----
rule "Average profit"
when
    $order : Order()
    accumulate( OrderItem( order == $order, $cost : cost, $price : price );
                $avgProfit : average( 1 - $cost / $price ) )
then
    // average profit for $order is $avgProfit
end
----


Accumulate Functions are all pluggable.
That means that if needed, custom, domain specific functions can easily be added to the engine and rules can start to use them without any restrictions.
To implement a new Accumulate Function all one needs to do is to create a Java class that implements the `org.kie.api.runtime.rule.AccumulateFunction` interface.
As an example of an Accumulate Function implementation, the following is the implementation of the `average` function:

[source,java]
----
/**
 * An implementation of an accumulator capable of calculating average values
 */
public class AverageAccumulateFunction implements org.kie.api.runtime.rule.AccumulateFunction {

    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

    }

    public void writeExternal(ObjectOutput out) throws IOException {

    }

    public static class AverageData implements Externalizable {
        public int    count = 0;
        public double total = 0;

        public AverageData() {}

        public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
            count   = in.readInt();
            total   = in.readDouble();
        }

        public void writeExternal(ObjectOutput out) throws IOException {
            out.writeInt(count);
            out.writeDouble(total);
        }

    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#createContext()
     */
    public Serializable createContext() {
        return new AverageData();
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#init(java.io.Serializable)
     */
    public void init(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        data.count = 0;
        data.total = 0;
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#accumulate(java.io.Serializable, java.lang.Object)
     */
    public void accumulate(Serializable context,
                           Object value) {
        AverageData data = (AverageData) context;
        data.count++;
        data.total += ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#reverse(java.io.Serializable, java.lang.Object)
     */
    public void reverse(Serializable context, Object value) throws Exception {
        AverageData data = (AverageData) context;
        data.count--;
        data.total -= ((Number) value).doubleValue();
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#getResult(java.io.Serializable)
     */
    public Object getResult(Serializable context) throws Exception {
        AverageData data = (AverageData) context;
        return new Double( data.count == 0 ? 0 : data.total / data.count );
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#supportsReverse()
     */
    public boolean supportsReverse() {
        return true;
    }

    /* (non-Javadoc)
     * @see org.kie.api.runtime.rule.AccumulateFunction#getResultType()
     */
    public Class< ? > getResultType() {
        return Number.class;
    }

}
----


The code for the function is very simple, as we could expect, as all the "dirty" integration work is done by the engine.
Finally, to use the function in the rules, the author can import it using the "import accumulate" statement:

[source]
----
import accumulate <class_name> <function_name>
----


For instance, if one implements the class `some.package.VarianceFunction` function that implements the `variance` function and wants to use it in the rules, he would do the following:

.Example of importing and using the custom "``variance``" accumulate function
====
[source]
----
import accumulate some.package.VarianceFunction variance

rule "Calculate Variance"
when
    accumulate( Test( $s : score ), $v : variance( $s ) )
then
    // the variance of the test scores is $v
end
----
====

[NOTE]
====
The built in functions (sum, average, etc) are imported automatically by the engine.
Only user-defined custom accumulate functions need to be explicitly imported.
====

[NOTE]
====
For backward compatibility, Drools still supports the configuration of accumulate functions through configuration files and system properties, but this is a deprecated method.
In order to configure the variance function from the previous example using the configuration file or system property, the user would set a property like this:

[source]
----
drools.accumulate.function.variance = some.package.VarianceFunction
----

Please note that $$"$$``drools.accumulate.function.``$$"$$ is a prefix that must always be used, 
$$"$$`variance`$$"$$ is how the function will be used in the drl files, and 
$$"$$`some.package.VarianceFunction`$$"$$ is the fully qualified name of the class that implements the 
function behavior.
====

==== Alternate Syntax: single function with return type


The accumulate syntax evolved over time with the goal of becoming more compact and expressive.
Nevertheless, Drools still supports previous syntaxes for backward compatibility purposes.

In case the rule is using a single accumulate function on a given accumulate, the author may add a pattern for the result object and use the "from" keyword to link it to the accumulate result.
Example: a rule to apply a 10% discount on orders over $100 could be written in the following way:

[source]
----
rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue > 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              sum( $value ) )
then
    # apply discount to $order
end
----


In the above example, the accumulate element is using only one function (sum), and so, the rules author opted to explicitly write a pattern for the result type of the accumulate function (Number) and write the constraints inside it.
There are no problems in using this syntax over the compact syntax presented before, except that is is a bit more verbose.
Also note that it is not allowed to use both the return type and the functions binding in the same accumulate statement.

==== Accumulate with inline custom code

[WARNING]
====
The use of accumulate with inline custom code is not a good practice for several reasons, including difficulties on maintaining and testing rules that use them, as well as the inability of reusing that code.
Implementing your own accumulate functions is very simple and straightforward, they are easy to unit test and to use.
This form of accumulate is supported for backward compatibility only.
====


Another possible syntax for the accumulate is to define inline custom code, instead of using accumulate functions.
As noted on the previous warned, this is discouraged though for the stated reasons.

The general syntax of the `accumulate` CE with inline custom code is:

[source]
----
<result pattern> from accumulate( <source pattern>,
                                  init( <init code> ),
                                  action( <action code> ),
                                  reverse( <reverse code> ),
                                  result( <result expression> ) )
----


The meaning of each of the elements is the following:

* __<source pattern>__: the source pattern is a regular pattern that the engine will try to match against each of the source objects.
* __<init code>__: this is a semantic block of code in the selected dialect that will be executed once for each tuple, before iterating over the source objects.
* __<action code>__: this is a semantic block of code in the selected dialect that will be executed for each of the source objects.
* __<reverse code>__: this is an optional semantic block of code in the selected dialect that if present will be executed for each source object that no longer matches the source pattern. The objective of this code block is to undo any calculation done in the _<action code>_ block, so that the engine can do decremental calculation when a source object is modified or deleted, hugely improving performance of these operations.
* __<result expression>__: this is a semantic expression in the selected dialect that is executed after all source objects are iterated.
* __<result pattern>__: this is a regular pattern that the engine tries to match against the object returned from the __<result expression>__. If it matches, the `accumulate` conditional element evaluates to _true_ and the engine proceeds with the evaluation of the next CE in the rule. If it does not matches, the `accumulate` CE evaluates to _false_ and the engine stops evaluating CEs for that rule.


It is easier to understand if we look at an example:

[source]
----
rule "Apply 10% discount to orders over US$ 100,00"
when
    $order : Order()
    $total : Number( doubleValue > 100 ) 
             from accumulate( OrderItem( order == $order, $value : value ),
                              init( double total = 0; ),
                              action( total += $value; ),
                              reverse( total -= $value; ),
                              result( total ) )
then
    # apply discount to $order
end
----


In the above example, for each `Order` in the Working Memory, the engine will execute the _init
          code_ initializing the total variable to zero.
Then it will iterate over all `OrderItem` objects for that order, executing the _action_ for each one (in the example, it will sum the value of all items into the total variable). After iterating over all `OrderItem` objects, it will return the value corresponding to the _result
          expression_ (in the above example, the value of variable ``total``). Finally, the engine will try to match the result with the `Number` pattern, and if the double value is greater than 100, the rule will fire.

The example used Java as the semantic dialect, and as such, note that the usage of the semicolon as statement delimiter is mandatory in the init, action and reverse code blocks.
The result is an expression and, as such, it does not admit ';'. If the user uses any other dialect, he must comply to that dialect's specific syntax.

As mentioned before, the _reverse code_ is optional, but it is strongly recommended that the user writes it in order to benefit from the __improved performance on update
          and delete__.

The `accumulate` CE can be used to execute any action on source objects.
The following example instantiates and populates a custom object:

[source]
----
rule "Accumulate using custom objects"
when
    $person   : Person( $likes : likes )
    $cheesery : Cheesery( totalAmount > 100 )
                from accumulate( $cheese : Cheese( type == $likes ),
                                 init( Cheesery cheesery = new Cheesery(); ),
                                 action( cheesery.addCheese( $cheese ); ),
                                 reverse( cheesery.removeCheese( $cheese ); ),
                                 result( cheesery ) );
then
    // do something
end
----

=== Conditional Element `eval`

.eval
image::LanguageReference/eval.png[align="center"]


The conditional element `eval` is essentially a catch-all which allows any semantic code (that returns a primitive boolean) to be executed.
This code can refer to variables that were bound in the LHS of the rule, and functions in the rule package.
Overuse of eval reduces the declarativeness of your rules and can result in a poorly performing engine.
While `eval` can be used anywhere in the patterns, the best practice is to add it as the last conditional element in the LHS of a rule.

Evals cannot be indexed and thus are not as efficient as Field Constraints.
However this makes them ideal for being used when functions return values that change over time, which is not allowed within Field Constraints.

For folks who are familiar with Drools 2.x lineage, the old Drools parameter and condition tags are equivalent to binding a variable to an appropriate type, and then using it in an eval node.

[source]
----
p1 : Parameter()
p2 : Parameter()
eval( p1.getList().containsKey( p2.getItem() ) )
----

{empty}

[source]
----
p1 : Parameter()
p2 : Parameter()
// call function isValid in the LHS
eval( isValid( p1, p2 ) )
----

=== Railroad diagrams


image::LanguageReference/AccumulateAction.png[align="center"]



image::LanguageReference/AccumulateClause.png[align="center"]



image::LanguageReference/AccumulateFunction.png[align="center"]



image::LanguageReference/AccumulateInit.png[align="center"]



image::LanguageReference/AccumulateResult.png[align="center"]



image::LanguageReference/AccumulateReverse.png[align="center"]



image::LanguageReference/AccumulateSteps.png[align="center"]



image::LanguageReference/Accumulations.png[align="center"]



image::LanguageReference/AdditiveExpr.png[align="center"]



image::LanguageReference/Annotation.png[align="center"]



image::LanguageReference/Arguments.png[align="center"]



image::LanguageReference/ArrayCreatorRest.png[align="center"]



image::LanguageReference/ArrayInitializer.png[align="center"]



image::LanguageReference/AssignmentOperator.png[align="center"]



image::LanguageReference/BindingPattern.png[align="center"]



image::LanguageReference/Block.png[align="center"]



image::LanguageReference/BooleanLiteral.png[align="center"]



image::LanguageReference/CompilationUnit.png[align="center"]



image::LanguageReference/ConditionalAnd.png[align="center"]



image::LanguageReference/ConditionalElementAccumulate.png[align="center"]



image::LanguageReference/ConditionalElementEval.png[align="center"]



image::LanguageReference/ConditionalElementExists.png[align="center"]



image::LanguageReference/ConditionalElementForall.png[align="center"]



image::LanguageReference/ConditionalElementNot.png[align="center"]



image::LanguageReference/ConditionalElement.png[align="center"]



image::LanguageReference/ConditionalExpr.png[align="center"]



image::LanguageReference/ConditionalOrExpr.png[align="center"]



image::LanguageReference/ConditionalOr.png[align="center"]



image::LanguageReference/Constraints.png[align="center"]



image::LanguageReference/CreatedName.png[align="center"]



image::LanguageReference/Creator.png[align="center"]



image::LanguageReference/Definition.png[align="center"]



image::LanguageReference/Digit.png[align="center"]



image::LanguageReference/ExplicitGenericInvocationSuffix.png[align="center"]



image::LanguageReference/ExplicitGenericInvocation.png[align="center"]



image::LanguageReference/Exponent.png[align="center"]



image::LanguageReference/ExpressionList.png[align="center"]



image::LanguageReference/Expression.png[align="center"]



image::LanguageReference/Field.png[align="center"]



image::LanguageReference/Fraction.png[align="center"]



image::LanguageReference/FromAccumulateClause.png[align="center"]



image::LanguageReference/FromClause.png[align="center"]



image::LanguageReference/FromCollectClause.png[align="center"]



image::LanguageReference/FunctionDefinition.png[align="center"]



image::LanguageReference/GlobalDefinition.png[align="center"]



image::LanguageReference/IdentifierSuffix.png[align="center"]



image::LanguageReference/ImportDefinition.png[align="center"]



image::LanguageReference/InExpr.png[align="center"]



image::LanguageReference/InlineListExpr.png[align="center"]



image::LanguageReference/InlineMapExpr.png[align="center"]



image::LanguageReference/InnerCreator.png[align="center"]



image::LanguageReference/InstanceOfExpr.png[align="center"]



image::LanguageReference/IntLiteral.png[align="center"]



image::LanguageReference/Literal.png[align="center"]



image::LanguageReference/ModifyStatement.png[align="center"]



image::LanguageReference/NonWildcardTypeArguments.png[align="center"]



image::LanguageReference/OrRestriction.png[align="center"]



image::LanguageReference/OverClause.png[align="center"]



image::LanguageReference/Parameters.png[align="center"]



image::LanguageReference/Pattern.png[align="center"]



image::LanguageReference/Placeholders.png[align="center"]



image::LanguageReference/Primary.png[align="center"]



image::LanguageReference/PrimitiveType.png[align="center"]



image::LanguageReference/QualifiedName.png[align="center"]



image::LanguageReference/QueryDefinition.png[align="center"]



image::LanguageReference/QueryOptions.png[align="center"]



image::LanguageReference/RealLiteral.png[align="center"]



image::LanguageReference/RealTypeSuffix.png[align="center"]



image::LanguageReference/RelationalExpr.png[align="center"]



image::LanguageReference/RelationalOperator.png[align="center"]



image::LanguageReference/RhsStatement.png[align="center"]



image::LanguageReference/RuleAttributes.png[align="center"]



image::LanguageReference/RuleAttribute.png[align="center"]



image::LanguageReference/RuleDefinition.png[align="center"]



image::LanguageReference/RuleOptions.png[align="center"]



image::LanguageReference/Selector.png[align="center"]



image::LanguageReference/ShiftExpr.png[align="center"]



image::LanguageReference/SingleRestriction.png[align="center"]



image::LanguageReference/SourcePattern.png[align="center"]



image::LanguageReference/StringId.png[align="center"]



image::LanguageReference/SuperSuffix.png[align="center"]



image::LanguageReference/ThenPart.png[align="center"]



image::LanguageReference/TypeArguments.png[align="center"]



image::LanguageReference/TypeArgument.png[align="center"]



image::LanguageReference/TypeDefinition.png[align="center"]



image::LanguageReference/TypeOptions.png[align="center"]



image::LanguageReference/Type.png[align="center"]



image::LanguageReference/UnaryExprNotPlusMinus.png[align="center"]



image::LanguageReference/UnaryExpr.png[align="center"]



image::LanguageReference/Value.png[align="center"]



image::LanguageReference/VariableInitializer.png[align="center"]



image::LanguageReference/WhenPart.png[align="center"]


== The Right Hand Side (then)

=== Usage


The Right Hand Side (RHS) is a common name for the consequence or action part of the rule; this part should contain a list of actions to be executed.
It is bad practice to use imperative or conditional code in the RHS of a rule; as a rule should be atomic in nature - "when this, then do this", not "when this, maybe do this". The RHS part of a rule should also be kept small, thus keeping it declarative and readable.
If you find you need imperative and/or conditional code in the RHS, then maybe you should be breaking that rule down into multiple rules.
The main purpose of the RHS is to insert, delete or modify working memory data.
To assist with that there are a few convenience methods you can use to modify working memory; without having to first reference a working memory instance.

``update(``__object,
      handle__``);`` will tell the engine that an object has changed (one that has been bound to something on the LHS) and rules may need to be reconsidered.

``update(``__object__``);`` can also be used; here the Knowledge Helper will look up the facthandle for you, via an identity check, for the passed object.
(Note that if you provide Property Change Listeners to your Java beans that you are inserting into the engine, you can avoid the need to call `update()` when the object changes.). After a fact's field values have changed you must call update before changing another fact, or you will cause problems with the indexing within the rule engine.
The modify keyword avoids this problem.

``insert(new``__Something__``());`` will place a new object of your creation into the Working Memory.

``insertLogical(new``__Something__``());`` is similar to insert, but the object will be automatically deleted when there are no more facts to support the truth of the currently firing rule.

``delete(``__handle__``);`` removes an object from Working Memory.

These convenience methods are basically macros that provide short cuts to the `KnowledgeHelper` instance that lets you access your Working Memory from rules files.
The predefined variable `drools` of type `KnowledgeHelper` lets you call several other useful methods.
(Refer to the `KnowledgeHelper` interface documentation for more advanced operations).

* The call `drools.halt()` terminates rule execution immediately. This is required for returning control to the point whence the current session was put to work with ``fireUntilHalt()``.
* Methods ``insert(Object o)``, `update(Object o)` and `delete(Object o)` can be called on `drools` as well, but due to their frequent use they can be called without the object reference.
* `drools.getWorkingMemory()` returns the `WorkingMemory` object.
* `drools.setFocus( String s)` sets the focus to the specified agenda group.
* ``drools.getRule().getName()``, called from a rule's RHS, returns the name of the rule.
* `drools.getTuple()` returns the Tuple that matches the currently executing rule, and `drools.getActivation()` delivers the corresponding Activation. (These calls are useful for logging and debugging purposes.)


The full Knowledge Runtime API is exposed through another predefined variable, ``kcontext``, of type ``KieContext``.
Its method `getKieRuntime()` delivers an object of type ``KieRuntime``, which, in turn, provides access to a wealth of methods, many of which are quite useful for coding RHS logic.

* The call `kcontext.getKieRuntime().halt()` terminates rule execution immediately.
* The accessor `getAgenda()` returns a reference to this session's ``Agenda``, which in turn provides access to the various rule groups: activation groups, agenda groups, and rule flow groups. A fairly common paradigm is the activation of some agenda group, which could be done with the lengthy call:
+

[source,java]
----
// give focus to the agenda group CleanUp
kcontext.getKieRuntime().getAgenda().getAgendaGroup( "CleanUp" ).setFocus();
----
+
(You can achieve the same using ``drools.setFocus(
"CleanUp" )``.)
* To run a query, you call `getQueryResults(String query)`, whereupon you may process the results, as explained in section <<_querysection,Query>>. Using `kcontext.getKieRuntime().getQueryResults()` or using `drools.getKieRuntime().getQueryResults()` is the proper method of running a query from a rule's RHS, and the only supported way.
* A set of methods dealing with event management lets you, among other things, add and remove event listeners for the Working Memory and the Agenda.
* Method `getKieBase()` returns the `KieBase` object, the backbone of all the Knowledge in your system, and the originator of the current session.
* You can manage globals with ``setGlobal(...)``, `getGlobal(...)` and ``getGlobals()``.
* Method `getEnvironment()` returns the runtime's `Environment` which works much like what you know as your operating system's environment.


=== The `modify` Statement


This language extension provides a structured approach to fact updates.
It combines the update operation with a number of setter calls to change the object's fields.
This is the syntax schema for the `modify` statement:

[source]
----
modify ( <fact-expression> ) {
    <expression> [ , <expression> ]*
}
----


The parenthesized _<fact-expression>_ must yield a fact object reference.
The expression list in the block should consist of setter calls for the given object, to be written without the usual object reference, which is automatically prepended by the compiler.

The example illustrates a simple fact modification.

.A modify statement
====
[source]
----
rule "modify stilton"
when
    $stilton : Cheese(type == "stilton")
then
    modify( $stilton ){
        setPrice( 20 ),
        setAge( "overripe" )
    }
end
----
====


The advantages in using the modify statment are particularly clear when used in conjuction with fine grained property change listeners.
See the corresponding section for more details.

== Conditional named consequences


Sometimes the constraint of having one single consequence for each rule can be somewhat limiting and leads to verbose and difficult to be maintained repetitions like in the following example:

[source]
----
rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age > 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
when
    $customer : Customer( age > 60 )
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end
----


It is already possible to partially overcome this problem by making the second rule extending the first one like in:

[source]
----
rule "Give 10% discount to customers older than 60"
when
    $customer : Customer( age > 60 )
then
    modify($customer) { setDiscount( 0.1 ) };
end

rule "Give free parking to customers older than 60"
    extends "Give 10% discount to customers older than 60"
when
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
end
----


Anyway this feature makes it possible to define more labelled consequences other than the default one in a single rule, so, for example, the 2 former rules can be compacted in only one like it follows:

[source]
----
rule "Give 10% discount and free parking to customers older than 60"
when
    $customer : Customer( age > 60 )
    do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end
----


This last rule has 2 consequences, the usual default one, plus another one named "giveDiscount" that is activated, using the keyword do, as soon as a customer older than 60 is found in the knowledge base, regardless of the fact that he owns a car or not.
The activation of a named consequence can be also guarded by an additional condition like in this further example:

[source]
----
rule "Give free parking to customers older than 60 and 10% discount to golden ones among them"
when
    $customer : Customer( age > 60 )
    if ( type == "Golden" ) do[giveDiscount]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount]
    modify($customer) { setDiscount( 0.1 ) };
end
----


The condition in the if statement is always evaluated on the pattern immediately preceding it.
In the end this last, a bit more complicated, example shows how it is possible to switch over different conditions using a nested if/else statement:

[source]
----
rule "Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones"
when
    $customer : Customer( age > 60 )
    if ( type == "Golden" ) do[giveDiscount10]
    else if ( type == "Silver" ) break[giveDiscount5]
    $car : Car ( owner == $customer )
then
    modify($car) { setFreeParking( true ) };
then[giveDiscount10]
    modify($customer) { setDiscount( 0.1 ) };
then[giveDiscount5]
    modify($customer) { setDiscount( 0.05 ) };
end
----


Here the purpose is to give a 10% discount AND a free parking to Golden customers over 60, but only a 5% discount (without free parking) to the Silver ones.
This result is achieved by activating the consequence named "giveDiscount5" using the keyword break instead of do.
In fact do just schedules a consequence in the agenda, allowing the remaining part of the LHS to continue of being evaluated as per normal, while break also blocks any further pattern matching evaluation.
Note, of course, that the activation of a named consequence not guarded by any condition with break doesn't make sense (and generates a compile time error) since otherwise the LHS part following it would be never reachable.

== A Note on Auto-boxing and Primitive Types


Drools attempts to preserve numbers in their primitive or object wrapper form, so a variable bound to an int primitive when used in a code block or expression will no longer need manual unboxing; unlike Drools 3.0 where all primitives were autoboxed, requiring manual unboxing.
A variable bound to an object wrapper will remain as an object; the existing JDK 1.5 and JDK 5 rules to handle auto-boxing and unboxing apply in this case.
When evaluating field constraints, the system attempts to coerce one of the values into a comparable format; so a primitive is comparable to an object wrapper.

ifdef::backend-docbook[]
[index]
== Index
// Generated automatically by the DocBook toolchain.
endif::backend-docbook[]
