[id='configure-server']
= Configuring WAS for {KIE_SERVER}

Before you can deploy {KIE_SERVER} on WAS, you must configure the server to accept the deployable WAR files, which are provided as two deployable web application archives: `business-central.war` and `kie-execution-server.war`

.Prerequisites
Ensure that you have root access to WAS and that you are able to successfully access the IBM WebSphere's administrative console. Log in to your IBM WebSphere console using an administrative login before performing any of these steps. The usual login URL is `http://_TARGET_SERVER_:9060/ibm/console` (for example `http://localhost:9060/ibm/console`).

After you successfully log in to the IBM WebSphere console, the *IBM Integrated Solutions Console* with the welcome screen opens. The main menu on the left side of the console contains all the links necessary for configuring the application server.

.IBM Integrated Solutions Console
image::websphere_console.png[]

== Increasing JVM heap size

With the default JVM heap size, the WAS freezes or causes deployment errors when deploying {KIE_SERVER}. To increase the heap size:

. In the *Integrated Solutions Console*, go to *Servers* -> *Server Types* -> *WebSphere Application Servers*.
. In the list of application servers, click on the server on which you are going to deploy {KIE_SERVER}. For example `server1`.
+
The configuration page for that server opens.
. Under *Server Infrastructure* heading on the right side, click *Java and Process Management* -> *Process Definition*.
+
.Application server configuration page
image::process_definition.png[]
. Click *Java Virtual Machine* under the *Additional Properties* heading on the right.
+
.Process definition configuration page
image::process_definition2.png[]
+
This will open up the configuration properties for the JVM that is used to start the server.
. Change both the *Initial Heap Size* and *Maximum Heap Size* to `2048`. This is the configuration {KIE_SERVER} is tested with.
+
.JVM configuration page
image::process_definition3.png[]
. Click *Apply* at the bottom.
+
*Messages* pop-up window appears at the top of the *Application Servers* configuration page. You can choose to save these configuration settings to the master configuration at this stage.
+
.Messages pop-up
image::messages_popup.png[]
. Restart the server at this point or wait until other configuration changes have been made.

== Creating users and groups

. In the main menu on the left, click *Users and Groups* -> *Manage Groups*.

. Create the `kie-server` group by clicking *Create...*.
+
.Created groups
image::created_groups_brms.png[]

. In the main menu on the left, click *Users and Groups* -> *Manage Users*.

. Click *Create...* and fill in the user credentials.
+
[IMPORTANT]
====
Make sure that the selected *User ID* does _not_ conflict with any known title of a role or a group.

For example, if there is a role called `kie-server`, you should _not_ create a user with the user name `kie-server`.
====
+
.Create User Dialog Window
image::creating_user.png[]

. Click *Group Membership* and assign the user to the `kie-server` group that you created previously.
. Click *Create*.

== Setting up JMS resources

WAS must be configured to send and receive JMS messages through {KIE_SERVER}. However, before you do this, a service bus must be present. Follow the steps below to create a service bus if one does not already exist.

=== Creating the service bus

. In the main menu on the left, click *Service Integration* -> *Buses*.
. Click *New...*.
. Enter the name and make sure that the *Bus Security* option is _unchecked_.
. Click *Next* and then *Finish* to create the service bus.

==== Adding a bus member

Before you continue, add a new bus member. A bus member is a server or a cluster that has been added to this service bus.

. Go to *Service Integration* -> *Buses* and click on the service bus that you have created.
. Under the *Topology* heading on the right, click *Bus Members*.
. Click *Add*.
. In the *Add a New Bus Member* wizard, choose the server and the type of message store for the persistence in the first two steps. Depending on the previous selection, you can also specify the properties of the message store.
. Click *Finish* in the last step to add a new bus member.

=== Creating JMS connection factories

To send and receive messages from the {KIE_SERVER}, you have to create the JMS connection factories, which are needed for establishing connections used for sending messages into queues.

ifdef::BA[]
For Business Central, create the following connection factories: `KIE.SIGNAL`, `KIE.INPUT` (for queries), `KIE.RESPONSE.ALL` (for responses), and `KIE.EXECUTOR` (for the executor).

If you will be installing the {KIE_SERVER} as well, you need to create `KIE.SERVER.REQUEST`, `KIE.SERVER.RESPONSE`, and `KIE.SERVER.EXECUTOR` connection factories.
endif::BA[]

ifdef::DM[]
{KIE_SERVER} needs the Java Messaging Services. Use the procedure below to create the following connection factories: `KIE.SERVER.REQUEST` and `KIE.SERVER.RESPONSE`.
endif::DM[]

NOTE: The factory names shown above are suggestions only and you can change them to suit your needs and company guidelines.

. In the main menu on the left, go to *Resources* -> *JMS* -> *Connection Factories*.
. Make sure the correct scope is selected and click *New*.
. Select the *Default Messaging Provider* option and click *OK*.
ifdef::BA[]
. Enter the name and JNDI name of the factory. For example:
+
  ** *Name*: `KIE.SIGNAL`
  ** *JNDI name*: `jms/conn/KIE.SIGNAL`
+
[NOTE]
====
The JNDI names for `KIE.INPUT`, `KIE.RESPONSE.ALL`, and `KIE.EXECUTOR` are `jms/conn/KIE.INPUT`, `jms/conn/KIE.RESPONSE.ALL`, and `jms/conn/KIE.EXECUTOR` respectively.
====
endif::BA[]
ifdef::DM[]
. Enter the name and the JNDI name of the factory. For example:
+
  ** *Name*: `KIE.SERVER.REQUEST`
  ** *JNDI name*: `jms/conn/KIE.SERVER.REQUEST`
+
[NOTE]
====
The JNDI name for `KIE.SERVER.RESPONSE` is `jms/conn/KIE.SERVER.RESPONSE`.
====
endif::DM[]
. From the *Bus Name* drop-down list, select the service bus created earlier.
+
The rest of the options are not mandatory and can be left with default values.
. Click *Apply* and choose to save the changes to the master configuration.

=== Creating JMS queues

The next step is to create the JMS queues. These queues are the destination end points for point-to-point messaging.

ifdef::BA[]
For {PRODUCT}, create the following queues: `KIE.RESPONSE.ALL` (for responses), `KIE.AUDIT` (for asynchronous audit logs), `KIE.SESSION` (for `ksession`-based operations), `KIE.TASK` (for task-based operations), `KIE.EXECUTOR` (for Business Central executor services), and `KIE.SIGNAL` (for sending external global signals to processes).

For {KIE_SERVER}, create the following: `KIE.SERVER.REQUEST` (for requests), `KIE.SERVER.RESPONSE` (for responses), and `KIE.SERVER.EXECUTOR` (for executor services).
endif::BA[]

ifdef::DM[]
For {KIE_SERVER}, create the following queues: `KIE.SERVER.REQUEST` (for requests) and `KIE.SERVER.RESPONSE` (for responses).

//IMPORTANT: To prevent warnings in the log, create `KIE.EXECUTOR` queue as well.
endif::DM[]

To create these queues:

. In the main menu, go to *Resources* -> *JMS* -> *Queues*.
. Make sure the correct scope is selected and click *New*.
. Select the *Default Messaging Provider* radio button and click *OK*.
ifdef::BA[]
. Enter the name and the JNDI name of the queue, for example:
+
  ** *Name*: `KIE.RESPONSE.ALL`
  ** *JNDI name*: `jms/KIE.RESPONSE.ALL`
+
[NOTE]
====
All of the JNDI names of other queues follow the same convention as the example above.
====
endif::BA[]
ifdef::DM[]
. Enter the name and the JNDI name of the queue, for example:
+
  ** *Name*: `KIE.SERVER.REQUEST`
  ** *JNDI name*: `jms/KIE.SERVER.REQUEST`
+
[NOTE]
====
All of the JNDI names of other queues follow the same convention as the example above.
====
endif::DM[]
. From the *Bus Name* drop-down list, select the service bus created earlier.
. From the *Queue Name* drop-down list, make sure to select the *Create Service Integration Bus Destination*.
+
This will open up the *Create New Queue* form for creating a new service integration bus. In this form, enter a unique identifier and select the bus member created earlier in this section.
. Click *Apply* at the bottom and choose to save the changes to the master configuration.

=== Creating JMS activation specifications

A JMS activation specification is required to be the bridge between the queue and the message-driven bean.

ifdef::BA[]
For Business Central, create the following activation specifications: `KIE.RESPONSE.ALL` (for responses), `KIE.AUDIT` (for asynchronous audit logs), `KIE.SESSION` (for `ksession`-based operations), `KIE.TASK` (for task-based operations), `KIE.EXECUTOR` (for Business Central executor services), and `KIE.SIGNAL` (for sending external global signals to processes).

For {KIE_SERVER}, create the following: `KIE.SERVER.REQUEST` (for requests) and `KIE.SERVER.RESPONSE` (for responses), and `KIE.SERVER.EXECUTOR` (for executor services).
endif::BA[]

ifdef::DM[]
For {KIE_SERVER}, create the following activation specifications: `KIE.SERVER.REQUEST` (for requests) and  `KIE.SERVER.RESPONSE` (for responses).

//IMPORTANT: To prevent warnings in the log, create `KIE.EXECUTOR` activation specification as well.
endif::DM[]

. In the main menu, go to *Resources* -> *JMS* -> *Activation Specifications*.
. Make sure the correct scope is selected and click *New*.
. Check the *Default Messaging Provider* radio button and click *OK*.
ifdef::BA[]
. Enter the name and the JNDI name of the activation specification, for example:
+
  ** *Name*: `KIE.RESPONSE.ALL`
  ** *JNDI name*: `jms/activation/KIE.RESPONSE.ALL`
+
[NOTE]
====
All of the JNDI names of other activation specifications follow the same convention as the example above.
====
. From the *Destination Type* drop-down list, make sure to select *Queue*.
. Enter the *Destination JNDI Name* (as created in the previous procedure), for example `jms/KIE.RESPONSE.ALL`.
endif::BA[]
ifdef::DM[]
. Enter the name and the JNDI name of the activation specification, for example:
+
  ** *Name*: `KIE.SERVER.REQUEST`
  ** *JNDI name*: `jms/activation/KIE.SERVER.REQUEST`
+
[NOTE]
====
All of the JNDI names of other activation specifications follow the same convention as the example above.
====
. From the *Destination Type* drop-down list, make sure to select *Queue*.
. Enter the *Destination JNDI Name* (as created in the previous procedure), for example `jms/KIE.SERVER.REQUEST`.
endif::DM[]
. From the *Bus Name* drop-down list, choose the service bus created earlier.
. Click *OK* at the bottom with the rest of the field values as default and choose to save the changes to the master configuration.

You have now successfully completed the JMS configurations required for setting up {KIE_SERVER} on WAS.

=== Adding custom JVM properties

You must add custom properties to the JVM that is used to start WAS. These custom properties take into consideration the configuration changes that have been outlined in previous sections of this guide.

. In the main menu, go to *Servers* -> *Server Types* -> *WebSphere Application Servers*.
. In the list of application servers, choose the server on which you are going to deploy {KIE_SERVER}.
. Under the *Server Infrastructure* heading on the right, click *Java and Process Management* -> *Process Definition*.
. Click *Java Virtual Machine* under the *Additional Properties* heading.
+
This opens up the configuration properties for the JVM that is used to start WAS.
. Click *Custom Properties* under *Additional Properties*.
. Create the following properties by clicking *New...* -> *Custom JVM Properties*.

+
[cols="1,1,2a", options="header"]
.Required properties for {KIE_SERVER}
|===
|Name
|Value
|Description

|`org.jboss.logging.provider`
|`jdk`
|This property is only required where a `CA SiteMinder TAI (SMTAI)` is installed in the environment. Using this property forces Hibernate to use `JDK` instead of `log4j` for logging within Dashbuilder. `CA SiteMinder TAI (SMTAI)` contains an old version of `log4j`, which causes conflicts.

|`org.apache.wink.jaxbcontextcache`
|`off`
|This property ensures that the IBM WebSphere Apache Wink framework does not cache `JAXBContexts`, which negatively impacts the performance and interferes with the custom-type serialization for the REST API.

|`kie.server.jms.queues.response`
|`jms/conn/KIE.SERVER.RESPONSE`
|The JNDI name of connection factory for responses used by the {KIE_SERVER}.

|`org.kie.server.domain`
|`WSLogin`
|JAAS `LoginContext` domain used to authenticate users when using JMS.

ifdef::BA[]
|`org.kie.server.persistence.ds`
|Set according to database type and configuration.
|Datasource JNDI name.

|`org.kie.server.persistence.tm`
|`org.hibernate.service.jta.platform.internal.WebSphereExtendedJtaPlatform`
|Transaction manager platform for setting Hibernate properties.

|`org.kie.server.persistence.dialect`
|Set according to database type and configuration.
|Specifies the Hibernate dialect to be used.
endif::BA[]
|===

+

. Save these configuration settings to the master configuration.
. Restart WAS for these changes to take effect.

ifdef::BA[]
== Configuring unified execution servers

To configure Business Central to manage the {KIE_SERVER} and use the same data source, follow the instructions in the {URL_ADMIN_GUIDE}#unified_execution_servers[Unified Execution Servers] section of the _{ADMIN_GUIDE}_.
endif::BA[]
