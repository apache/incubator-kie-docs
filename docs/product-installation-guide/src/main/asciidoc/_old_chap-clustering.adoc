
You can create two types of {PRODUCT} clusters:

Design-Time Clustering::
Allows you to share assets in the Git repository, such as processes, rules, data objects, and others, with all the {PRODUCT} nodes in your cluster. It is suitable in case of concerns about a single point of failure and high availability during the development process. Design-time clustering makes use of _Apache Helix_ and _Apache ZooKeeper_.
+
Design-time clustering is not required for runtime execution.

Runtime Clustering::
Allows you to use the clustering capabilities of your container, such as Red Hat JBoss EAP. Runtime clustering does not require you to manage any Apache Helix or Apache ZooKeeper nodes. _Quartz Enterprise Job Scheduler_ is supported if you use timers in your application.

[NOTE]
====
If you use the Websphere Application Server, Quartz setup is not necessary. Instead, use clustered EJB Timers. For more information, see the https://access.redhat.com/solutions/2175471[How to setup BPM Suite Timers to work in Websphere Application Server clustering] support article.
====

You can cluster the following components of {PRODUCT}:

* Design-time cluster
** _Git repository_: virtual-file-system (VFS) repository that holds the business assets.
* Runtime cluster
ifdef::PAM[]
** _Intelligent Process Server, or web applications_: the web application nodes must share runtime data.
endif::PAM[]
ifdef::DM[]
** _RealTime Decision Server, or Web applications_: the web application nodes must share runtime data.
endif::DM[]
+
For instructions on clustering the
ifdef::PAM[]
Intelligent Process Server,
endif::PAM[]
ifdef::DM[]
RealTime Decision Server,
endif::DM[]
see <<_exec_server>>, or the  clustering documentation of your container.
ifdef::PAM[]
** _Back-end database_: database with the state data, such as process instances, KIE sessions, history log, and similar.
endif::PAM[]

== Git Repository Clustering Mechanism

To cluster the Git repository, {PRODUCT} uses:

// The additional info was requested by Alessandro. Please, do not delete as superfluous.

Apache Helix::
Provides cluster management functionality that allows you to synchronize and replicate data among the nodes in your cluster. Apache Helix cluster is managed by Apache ZooKeeper. With Apache Helix, you can define a cluster, add nodes to the cluster, remove nodes from the cluster, and perform other cluster-management tasks.
+
Additional information:

* Apache Helix needs to be configured on a single node only. The configuration is then stored and distributed by ZooKeeper.
* Apache Helix cluster is administered by the `helix-admin.sh` script. See Apache Helix http://helix.apache.org/0.6.5-docs/tutorial_admin.html[documentation] for the list of commands as well as alternative ways of managing Apache Helix cluster.
* Apache Helix cluster needs exactly one controller, which must be aware of all the nodes. See Apache Helix http://helix.apache.org/0.6.5-docs/tutorial_controller.html[controller] documentation and Apache Helix http://helix.apache.org/Architecture.html[architecture] documentation.

Apache ZooKeeper::
Allows you to synchronize and replicate data from the Apache Helix cluster. An Apache ZooKeeper cluster is known as an _ensemble_ and requires a majority of the servers to be functional for the service to be available.
+
However, an ensemble is not required for any type of clustering. Only a single instance of ZooKeeper is required to allow {PRODUCT} to replicate its data; the ZooKeeper ensemble serves to provide redundancy and protect against the failure of ZooKeeper itself.
+
Additional information:

* For more information about failure recovery, see Apache ZooKeeper https://zookeeper.apache.org/doc/r3.4.8/zookeeperAdmin.html#sc_dataFileManagement[Data File Management].
* For a list of commands, see Apache ZooKeeper https://zookeeper.apache.org/doc/r3.4.8/zookeeperAdmin.html#sc_zkCommands[ZooKeeper Commands: The Four Letter Words].

The relationship between Apache Helix and Apache ZooKeeper:

ifdef::PAM[]
.Schema of Red Hat JBoss BPM Suite Cluster
endif::PAM[]
ifdef::DM[]
.Schema of Red Hat JBoss BRMS Cluster
endif::DM[]
image::3639.png[]

A typical clustering setup involves the following:

. Configuring the cluster using Apache ZooKeeper and Apache Helix. This is required only for design-time clustering.
ifdef::PAM[]
. Configuring the back-end database with Quartz tables. This is required only for processes with timers.
endif::PAM[]
. Configuring clustering on your container. _{PRODUCT} Installation Guide_ provides only clustering instructions for Red Hat JBoss EAP 6.

[float]
== Clustering Maven Repositories

Various Business Central operations publish JAR files to the Business Central's internal Maven Repository.

This repository exists on the application server file-system as regular files and is not cluster aware. This folder is not synchronized across the various nodes in the cluster and must be synchronized using external tools like `rsync`.

An alternative to the use of an external synchronization tool is to set the system property `org.guvnor.m2repo.dir` on each cluster node to point to a SAN or NAS. In such case, clustering of the Maven repository folder is not needed.

[id='_configuring_clustering_on_red_hat_jboss_eap']
== Clustering on Red Hat JBoss EAP

To install {PRODUCT} in the clustered mode, the JAR installer provides a sample setup. You can configure clustering with the deployable ZIP for EAP as well.

[id='_clustering_jar_installer']
=== Clustering Using the JAR Installer

NOTE: The JAR installer provides sample setup only. Adjusting the configuration is necessary for it to suit your project's needs.

Using the JAR installer,
ifdef::PAM[]
described in <<_sect_the_red_hat_jboss_bpm_suite_installer_installation>>,
endif::PAM[]
you can set up a basic clustering configuration of {PRODUCT}.

The automatic configuration creates:

* ZooKeeper ensemble with three ZooKeeper nodes
* A Helix cluster
* Two Quartz datastores (one managed, one unmanaged)

This {PRODUCT} setup consists of two EAP nodes that share a Maven repository, use Quartz for coordinating timed tasks, and have `business-central.war`, `dashbuilder.war`, and `kie-server.war` deployed. To customize the setup to fit your scenario, or to use clustering with the deployable ZIP, see <<_clustering_custom_configuration>> and the clustering documentation of your container.

Follow the installation process described in <<_installing_red_hat_jboss_brmsbpm_suite_using_the_installer>>.

. In *Configure runtime environment*, select *Install clustered configuration* and click *Next*.
. Select the JDBC vendor for your database.
. Provide the corresponding driver JAR(s):
+
	* Select one or more files on the filesystem.
	* Provide one or more URLs. The installer downloads the files automatically.
+
The installer copies the JAR(s) into `_EAP_HOME_/modules` and creates corresponding `module.xml` file.
ifdef::PAM[]
+
.JDBC Driver Setup
image::7214.png[Configure JDBC provider and drivers]
endif::PAM[]

. Enter the url, username, and password for accessing the database used by Quartz.
+
The installer creates:

* The Quartz definition file in `_EAP_HOME_/domain/configuration/quartz-definition.properties`
* Two Quartz data sources in  `_EAP_HOME_/domain/domain.xml`
+
Edit the `domain.xml` file to customize the setup.
+
[NOTE]
====
During the installation, Quartz DDL scripts will be run on the database selected in this step. The scripts make changes needed for Quartz to operate, such as adding tables. You can view the scripts in `_EAP_HOME_/jboss-brms-bpmsuite-{PRODUCT_VERSION}-supplementary-tools/ddl-scripts`. No modifications should be necessary.
====
+
ifdef::PAM[]
.Quartz Database Configuration
image::7215.png[]
endif::PAM[]

. Click *Next* to initiate the installation.
+
[IMPORTANT]
====
When using the JAR installer, the `war` archives are automatically created from the applications in `_EAP_HOME_/standalone/deployments/`. That means additional space is necessary as the applications exist both in uncompressed and compressed state in the storage during the installation.
====
+
Three ZooKeeper instances are created in `_EAP_HOME_/jboss-brms-bpmsuite-{PRODUCT_VERSION}-supplementary-tools/` in directories `zookeeper-one`, `zookeeper-two`, and `zookeeper-three`.


After the installation finishes, do not start the server from the installer. To make Apache Helix aware of the cluster nodes, Apache ZooKeeper instances, and start the cluster:

. Change into `_EAP_HOME_/jboss-brms-bpmsuite-{PRODUCT_VERSION}-supplementary-tools/helix-core`.
. Execute the launch script:
+
On UNIX systems:
+
----
./startCluster.sh
----
+
On Windows:
+
----
./startCluster.bat
----
. Change into `_EAP_HOME_/bin`.
. Execute the following script to start Red Hat JBoss EAP:
+
On UNIX systems:
+
----
./domain.sh
----
+
On Windows:
+
----
./domain.bat
----

[id='starting_cluster']
=== Starting a Cluster

The `startCluster.sh` script in `_EAP_HOME_/jboss-brms-bpmsuite-{PRODUCT_VERSION}-supplementary-tools/helix-core` initializes and starts the cluster. Once initialized, further usage of `startCluster.sh` results in errors. If you installed {PRODUCT} cluster with the installer:

* `ZOOKEEPER_HOME` is located in `_EAP_HOME_/jboss-brms-bpmsuite-{PRODUCT_VERSION}-supplementary-tools/zookeeper-_NUMBER_`
* `HELIX_HOME` is located in  `_EAP_HOME_/jboss-brms-bpmsuite-{PRODUCT_VERSION}-supplementary-tools/helix-core`

To start a cluster:

. Start all your ZooKeeper servers, for example:
+
On UNIX systems:
+
----
./ZOOKEEPER_HOME_ONE/bin/zkServer.sh start &
./ZOOKEEPER_HOME_TWO/bin/zkServer.sh start &
./ZOOKEEPER_HOME_THREE/bin/zkServer.sh start &
----
+
On Windows:
+
----
ZOOKEEPER_HOME_ONE/bin/zkServer.cmd start
ZOOKEEPER_HOME_TWO/bin/zkServer.cmd start
ZOOKEEPER_HOME_THREE/bin/zkServer.cmd start
----

. Make the Helix Controller aware of the ZooKeeper instance(s). For example:
+
----
./HELIX_HOME/bin/run-helix-controller.sh --zkSvr localhost:2181,localhost:2182,localhost:2183 --cluster bpms-cluster 2>&1 > /tmp/controller.log &
----

. Change into `_EAP_HOME_/bin` and start Red Hat JBoss EAP:
+
On UNIX systems:
+
----
./domain.sh
----
+
On Windows:
+
----
./domain.bat
----
. You can access your {PRODUCT} nodes. For example, if you created {PRODUCT} cluster by using the installer, you can access your nodes at:
+
----
localhost:8080/business-central
localhost:8230/business-central
----

[id='_stop_the_cluster']
=== Stopping a Cluster

To stop your cluster, stop the components in the reversed order from starting it:

. Stop the instance of Red Hat JBoss EAP, or the container you are using.
. Stop the Helix Controller process.
+
On UNIX systems, find the PID of the process:
+
----
ps aux|grep HelixControllerMain
----
+
Once you have the PID, terminate the process:
+
----
kill -15 <pid of HelixControllerMain>
----
+
On Windows, use the Task Manager to stop the process.
+
. Stop the ZooKeeper server(s). For each server instance, execute:
+
On UNIX systems:
+
----
./ZOOKEEPER_HOME_ONE/bin/zkServer.sh stop
./ZOOKEEPER_HOME_TWO/bin/zkServer.sh stop
./ZOOKEEPER_HOME_THREE/bin/zkServer.sh stop
----
+
On Windows:
+
----
ZOOKEEPER_HOME_ONE/bin/zkServer.cmd stop
ZOOKEEPER_HOME_TWO/bin/zkServer.cmd stop
ZOOKEEPER_HOME_THREE/bin/zkServer.cmd stop
----


[id='_clustering_custom_configuration']
=== Custom Configuration (Deployable ZIP)

When using Red Hat JBoss EAP clustering, a single Red Hat JBoss EAP domain controller exists with other Red Hat JBoss EAP slaves connecting to it as management users. You can deploy Business Central and dashbuilder as a management user on a domain controller, and the WAR deployments will be distributed to other members of the Red Hat JBoss EAP cluster.

To configure clustering on Red Hat JBoss EAP 6, do the following:

. Configure ZooKeeper and Helix according to <<_setting_up_a_cluster>>.

ifdef::PAM[]
. Configure Quartz according to <<_setting_up_quartz>>.
endif::PAM[]

ifdef::PAM[]
		. Install the JDBC driver. See the https://access.redhat.com/documentation/en-US/JBoss_Enterprise_Application_Platform/6.4/html/Administration_and_Configuration_Guide/sect-JDBC_Drivers.html#Install_a_JDBC_Driver_with_the_Management_Console[Install a JDBC Driver with the Management Console] chapter of the _Red Hat JBoss EAP Administration and Configuration Guide_.
endif::PAM[]

ifdef::PAM[]
. Configure the data source for the server. Based on the mode you use, open `domain.xml` or `standalone.xml`, located at `_EAP_HOME_/_MODE_/configuration`.
.  Locate the `full` profile, and do the following:
+
.. Add the definition of the main data source used by {PRODUCT}.
ifdef::PAM[]
+
.PostgreSQL Data Source Defined as Main Red Hat JBoss BPM Suite Data Source
====
[source,xml]
----
<datasource jndi-name="java:jboss/datasources/psbpmsDS"
            pool-name="postgresDS" enabled="true" use-java-context="true">
  <connection-url>jdbc:postgresql://localhost:5432/jbpm</connection-url>
  <driver>postgres</driver>
  <security>
    <user-name>bpms</user-name>
    <password>bpms</password>
  </security>
</datasource>
----
====
endif::PAM[]
ifdef::DM[]
+
.PostgreSQL Data Source Defined as Main JBoss BRMS Data Source
====
[source,xml]
----
<datasource jndi-name="java:jboss/datasources/psbrmsDS"
            pool-name="postgresDS" enabled="true" use-java-context="true">
  <connection-url>jdbc:postgresql://localhost:5432/jbrm</connection-url>
  <driver>postgres</driver>
  <security>
    <user-name>brms</user-name>
    <password>brms</password>
  </security>
</datasource>
----
====
endif::DM[]
.. Add the definition of the data source for the Quartz service.
ifdef::PAM[]
+
.PostgreSQL Data Source Defined as Quartz Data Source
====
[source,xml]
----
<datasource jta="false" jndi-name="java:jboss/datasources/quartzNotManagedDS"
            pool-name="quartzNotManagedDS" enabled="true" use-java-context="true">
  <connection-url>jdbc:postgresql://localhost:5432/jbpm</connection-url>
  <driver>postgres</driver>
  <security>
    <user-name>bpms</user-name>
    <password>bpms</password>
  </security>
</datasource>
----
====
endif::PAM[]
ifdef::DM[]
+
.PostgreSQL Data Source Defined as Quartz Data Source
====
[source,xml]
----
<datasource jta="false" jndi-name="java:jboss/datasources/quartzNotManagedDS"
            pool-name="quartzNotManagedDS" enabled="true" use-java-context="true">
  <connection-url>jdbc:postgresql://localhost:5432/jbrm</connection-url>
  <driver>postgres</driver>
  <security>
    <user-name>brms</user-name>
    <password>brms</password>
  </security>
</datasource>
----
====
endif::DM[]
.. Define the data source driver.
+
.PostgreSQL Driver Definition
====
[source,xml]
----
<driver name="postgres" module="org.postgresql">
  <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>
</driver>
----
====

.. If you are deploying {PRODUCT} on Red Hat JBoss EAP 7.0, ensure that the data sources contain schemas. To create the data source schemas, you can use the DDL scripts located in `jboss-bpmsuite-brms-{PRODUCT_VERSION}-supplementary-tools.zip`. If your data source does not contain schemas, ensure your nodes start one at a time.
+
Additionally, when deploying on Red Hat JBoss EAP 7.0, open `_EAP_HOME_/domain/business-central.war/WEB-INF/classes/META-INF/persistence.xml` and change the property `hibernate.hbm2ddl.auto="update"` to `hibernate.hbm2ddl.auto="none"`.
endif::PAM[]
. Configure individual server nodes in the `main-server-group` element in the `_EAP_HOME_/domain/configuration/host.xml` file with properties defined in
ifdef::PAM[]
<<_cluster_properties_BPMS>>.
endif::PAM[]
ifdef::DM[]
<<_cluster_properties_BRMS>>.
endif::DM[]
+
When configuring a Red Hat JBoss EAP cluster with Apache ZooKeeper, a different number of Red Hat JBoss EAP nodes than Apache ZooKeeper nodes is possible. However, having the same node count for both ZooKeeper and Red Hat JBoss EAP is considered best practice.
+
[id='_cluster_properties_BPMS,_cluster_properties_BRMS']
.Cluster Node Properties
*jboss.node.name*::
+
--
A node name unique in a {PRODUCT} cluster.

[cols="1,1", options="header"]
|===
| Values
| Default

| String
| N/A
|===
--

*org.uberfire.cluster.id*::
+
--
The name of the Helix cluster, for example: `kie-cluster`. You must set this property to the same value as defined in the Helix Controller.

[cols="1,1", options="header"]
|===
| Values
| Default

| String
| N/A
|===
--

*org.uberfire.cluster.local.id*::
+
--
The unique ID of the Helix cluster node. Note that ':' is replaced with '_', for example `node1_12345`.

[cols="1,1", options="header"]
|===
| Values
| Default

| String
| N/A
|===
--

*org.uberfire.cluster.vfs.lock*::
+
--
The name of the resource defined on the Helix cluster, for example: `kie-vfs`.

[cols="1,1", options="header"]
|===
| Values
| Default

| String
| N/A
|===
--

*org.uberfire.cluster.zk*::
+
--
The location of the Zookeeper servers.

[cols="1,1", options="header"]
|===
| Values
| Default

| String of the form ``host1:port1``,``host2:port2``,``host3:port3``,...
| N/A
|===
--

*org.uberfire.metadata.index.dir*::
+
--
The location of the `$$.$$index` directory, which Apache Lucene uses when indexing and searching.

[cols="1,1", options="header"]
|===
| Values
| Default

| Path
| Current working directory
|===
--

*org.uberfire.nio.git.daemon.host*::
+
--
If the Git daemon is enabled, it uses this property as the localhost identifier.

[cols="1,1", options="header"]
|===
| Values
| Default

| URL
| `localhost`
|===
--

*org.uberfire.nio.git.daemon.hostport*::
+
--
When running in a virtualized environment, the host's outside port number for the Git daemon.

[cols="1,1", options="header"]
|===
| Values
| Default

| Port number
| 9418
|===
--

*org.uberfire.nio.git.daemon.port*::
+
--
If the Git daemon is enabled, it uses this property as the port number.

[cols="1,1", options="header"]
|===
| Values
| Default

| Port number
| `9418`
|===
--

*org.uberfire.nio.git.dir*::
+
--
The location of the directory ``$$.$$niogit``. Change the value for example for backup purposes.

[cols="1,1", options="header"]
|===
| Values
| Default

| Path
| Current working directory
|===
--

*org.uberfire.nio.git.ssh.host*::
+
--
If the SSH daemon is enabled, it uses this property as the localhost identifier.

[cols="1,1", options="header"]
|===
| Values
| Default

| URL
| `localhost`
|===
--

*org.uberfire.nio.git.ssh.hostport*::
+
--
When running in a virtualized environment, the host's outside port number for the SSH daemon.

[cols="1,1", options="header"]
|===
| Values
| Default

| Port number
| 8003
|===
--

*org.uberfire.nio.git.ssh.port*::
+
--
If the SSH daemon is enabled, it uses this property as the port number.

[cols="1,1", options="header"]
|===
| Values
| Default

| Port number
| `8001`
|===
--

ifdef::PAM[]
+
--
.Cluster nodeOne Configuration
====
[source,xml]
----
<system-properties>
  <property name="org.uberfire.nio.git.dir" value="/tmp/bpms/nodeone"
            boot-time="false"/>
  <property name="jboss.node.name" value="nodeOne" boot-time="false"/>
  <property name="org.uberfire.cluster.id" value="bpms-cluster" boot-time="false"/>
  <property name="org.uberfire.cluster.zk"
            value="server1:2181,server2:2182,server3:2183" boot-time="false"/>
  <property name="org.uberfire.cluster.local.id" value="nodeOne_12345"
            boot-time="false"/>
  <property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.host" value="nodeOne"/>
  <property name="org.uberfire.nio.git.daemon.port" value="9418" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.hostport" value="9418"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.port" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.hostport" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.host" value="nodeOne"/>
  <property name="org.uberfire.metadata.index.dir" value="/tmp/jbpm/nodeone"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.cert.dir" value="/tmp/jbpm/nodeone"
            boot-time="false"/>
  <property name="org.quartz.properties"
            value="/tmp/jbpm/quartz/quartz-db-postgres.properties" boot-time="false"/>
</system-properties>
----
====

.Cluster nodeTwo Configuration
====
[source,xml]
----
<system-properties>
  <property name="org.uberfire.nio.git.dir" value="/tmp/bpms/nodetwo"
            boot-time="false"/>
  <property name="jboss.node.name" value="nodeTwo" boot-time="false"/>
  <property name="org.uberfire.cluster.id" value="bpms-cluster" boot-time="false"/>
  <property name="org.uberfire.cluster.zk"
            value="server1:2181,server2:2182,server3:2183" boot-time="false"/>
  <property name="org.uberfire.cluster.local.id" value="nodeTwo_12346"
            boot-time="false"/>
  <property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.host" value="nodeTwo" />
  <property name="org.uberfire.nio.git.daemon.port" value="9419" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.hostport" value="9419"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.port" value="8004" boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.hostport" value="8004" boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.host" value="nodeTwo" />
  <property name="org.uberfire.metadata.index.dir" value="/tmp/jbpm/nodetwo"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.cert.dir" value="/tmp/jbpm/nodetwo"
            boot-time="false"/>
  <property name="org.quartz.properties"
            value="/tmp/jbpm/quartz/quartz-db-postgres.properties" boot-time="false"/>
</system-properties>
----
====
.Cluster nodeThree Configuration
====
[source,xml]
----
<system-properties>
  <property name="org.uberfire.nio.git.dir" value="/tmp/bpms/nodethree"
            boot-time="false"/>
  <property name="jboss.node.name" value="nodeThree" boot-time="false"/>
  <property name="org.uberfire.cluster.id" value="bpms-cluster" boot-time="false"/>
  <property name="org.uberfire.cluster.zk"
            value="server1:2181,server2:2182,server3:2183" boot-time="false"/>
  <property name="org.uberfire.cluster.local.id" value="nodeThree_12347"
            boot-time="false"/>
  <property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.host" value="nodeThree" />
  <property name="org.uberfire.nio.git.daemon.port" value="9420" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.hostport" value="9420"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.port" value="8005" boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.hostport" value="8005" boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.host" value="nodeThree" />
  <property name="org.uberfire.metadata.index.dir" value="/tmp/jbpm/nodethree"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.cert.dir" value="/tmp/jbpm/nodethree"
            boot-time="false"/>
  <property name="org.quartz.properties"
            value="/tmp/jbpm/quartz/quartz-db-postgres.properties" boot-time="false"/>
</system-properties>
----
====
--
endif::PAM[]
ifdef::DM[]
+
--
.Cluster nodeOne Configuration
====
[source,xml]
----
<system-properties>
  <property name="org.uberfire.nio.git.dir" value="/tmp/brms/nodeone"
            boot-time="false"/>
  <property name="jboss.node.name" value="nodeOne" boot-time="false"/>
  <property name="org.uberfire.cluster.id" value="brms-cluster" boot-time="false"/>
  <property name="org.uberfire.cluster.zk"
            value="server1:2181,server2:2181,server3:2181" boot-time="false"/>
  <property name="org.uberfire.cluster.local.id" value="nodeOne_12345"
            boot-time="false"/>
  <property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.port" value="9418" boot-time="false"/>
  <property name="org.uberfire.metadata.index.dir" value="/tmp/jbrm/nodeone"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.cert.dir" value="/tmp/jbpm/nodeone"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.port" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.host" value="nodeOne" />
  <property name="org.uberfire.nio.git.ssh.host" value="nodeOne" />
  <property name="org.uberfire.nio.git.ssh.hostport" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.hostport" value="9418"
            boot-time="false"/>
</system-properties>
----
====

.Cluster nodeTwo Configuration
====
[source,xml]
----
<system-properties>
  <property name="org.uberfire.nio.git.dir" value="/tmp/brms/nodetwo"
            boot-time="false"/>
  <property name="jboss.node.name" value="nodeTwo" boot-time="false"/>
  <property name="org.uberfire.cluster.id" value="brms-cluster" boot-time="false"/>
  <property name="org.uberfire.cluster.zk"
            value="server1:2181,server2:2182,server3:2183" boot-time="false"/>
  <property name="org.uberfire.cluster.local.id" value="nodeTwo_12346"
            boot-time="false"/>
  <property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.port" value="9418" boot-time="false"/>
  <property name="org.uberfire.metadata.index.dir" value="/tmp/jbrm/nodetwo"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.cert.dir" value="/tmp/jbpm/nodetwo"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.port" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.host" value="nodeTwo" />
  <property name="org.uberfire.nio.git.ssh.host" value="nodeTwo" />
  <property name="org.uberfire.nio.git.ssh.hostport" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.hostport" value="9418"
            boot-time="false"/>
</system-properties>
----
====

.Cluster nodeThree Configuration
====
[source,xml]
----
<system-properties>
  <property name="org.uberfire.nio.git.dir" value="/tmp/brms/nodethree"
            boot-time="false"/>
  <property name="jboss.node.name" value="nodeThree" boot-time="false"/>
  <property name="org.uberfire.cluster.id" value="brms-cluster" boot-time="false"/>
  <property name="org.uberfire.cluster.zk"
            value="server1:2181,server2:2182,server3:2183" boot-time="false"/>
  <property name="org.uberfire.cluster.local.id" value="nodeThree_12347"
            boot-time="false"/>
  <property name="org.uberfire.cluster.vfs.lock" value="vfs-repo" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.port" value="9418" boot-time="false"/>
  <property name="org.uberfire.metadata.index.dir" value="/tmp/jbrm/nodethree"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.cert.dir" value="/tmp/jbpm/nodethree"
            boot-time="false"/>
  <property name="org.uberfire.nio.git.ssh.port" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.host" value="nodeThree" />
  <property name="org.uberfire.nio.git.ssh.host" value="nodeThree" />
  <property name="org.uberfire.nio.git.ssh.hostport" value="8003" boot-time="false"/>
  <property name="org.uberfire.nio.git.daemon.hostport" value="9418"
            boot-time="false"/>
</system-properties>
----
====
--
endif::DM[]

. Add management users as instructed in the _Administration and Configuration Guide_ for Red Hat JBoss EAP and application users as instructed in _{PRODUCT} Administration and Configuration Guide_.
// change on purpose - cd = change directory
. Change to `_EAP_HOME_/bin` and start the application server in domain mode:
+
On UNIX systems:
+
----
./domain.sh
----
+
On Windows:
+
----
./domain.bat
----

. Check that the nodes are available.

Deploy the Business Central application to your servers:

ifdef::PAM[]
. Change the predefined persistence of the application to the required database (PostgreSQL): in `persistence.xml` change the following:
+
.. `jta-data-source` name to the source defined on the application server (`java:jboss/datasources/psbpmsDS`).
.. Hibernate dialect to be match the data source dialect (`org.hibernate.dialect.PostgreSQLDialect`).

. Log in as the management user to the server *Administration* console of your domain and add the new deployments using the *Runtime view* of the console. Once the deployment is added to the domain, assign it to the correct server group (`main-server-group`).
endif::PAM[]

ifdef::DM[]
. Log in as the management user to the server *Administration* console of your domain and add the new deployments using the *Runtime view* of the console. Once the deployment is added to the domain, assign it to the correct server group (`main-server-group`).
endif::DM[]

[NOTE]
====
It is important users explicitly check deployment unit readiness with every cluster member.

When a deployment unit is created on a cluster node, it takes some time before it is distributed among all cluster members. Deployment status can be checked using the UI and REST, however, if the query goes to the node where the deployment was originally issued, the answer is `deployed`. Any request targeting this deployment unit sent to a different cluster member fails with `DeploymentNotFoundException`.
====

ifdef::PAM[]
[id='_exec_server']
=== Clustering the Intelligent Process Server
endif::PAM[]
ifdef::DM[]
[id='_exec_server']
=== Clustering the Realtime Decision Server
endif::DM[]

The
ifdef::PAM[]
Intelligent Process Server
endif::PAM[]
ifdef::DM[]
Realtime Decision Server
endif::DM[]
is a lightweight and scalable component. Clustering it provides many benefits. For example:

* You can partition your resources based on deployed containers.
* You can scale individual instances independently from each other.
* You can distribute the cluster across network and manage it by a single controller.
** The controller can be clustered into a ZooKeeper ensemble.
* No further components are required.

The basic runtime cluster consists of:

* Multiple Red Hat JBoss EAP instances with
ifdef::PAM[]
Intelligent Process Server
endif::PAM[]
ifdef::DM[]
Realtime Decision Server
endif::DM[]
* A controller instance with Business Central

image::kieserver-arch.png[]

This section describes how to start
ifdef::PAM[]
Intelligent Process Server
endif::PAM[]
ifdef::DM[]
Realtime Decision Server
endif::DM[]
cluster on Red Hat JBoss EAP 6.4.

ifdef::PAM[]
.Creating an Intelligent Process Server Cluster
endif::PAM[]
ifdef::DM[]
.Creating a Realtime Decision Server Cluster
endif::DM[]
. Change into `_CONTROLLER_HOME_/bin`.
. Add a user with the `kie-server` role:
+
[source,bash]
----
$ ./add-user.sh -a --user kieserver --password kieserver1! --role kie-server
----
. Start your controller:
+
[source,bash]
----
$ ./standalone.sh
----
. Change into `_SERVER_1_HOME_`.
. Deploy `kie-server.war`. Clustered servers do not need `business-central.war` or other applications.
. See the `<servers>` part of the following `host.xml` as an example of required properties:
+
[source,xml]
----
<server name="server-one" group="main-server-group">
 <system-properties>
  <property name="org.kie.server.location" value="http://localhost:8180/kie-server/services/rest/server"></property> <1>
  <property name="org.kie.server.controller" value="http://localhost:8080/business-central/rest/controller"></property> <2>
  <property name="org.kie.server.controller.user" value="kieserver"></property> <3>
  <property name="org.kie.server.controller.pwd" value="kieserver1!"></property> <4>
  <property name="org.kie.server.id" value="HR"></property> <5>
 </system-properties>
 <socket-bindings port-offset="100"/>
</server>

<server name="server-two" group="main-server-group" auto-start="true">
 <system-properties>
  <property name="org.kie.server.location" value="http://localhost:8230/kie-server/services/rest/server"></property>
  <property name="org.kie.server.controller" value="http://localhost:8080/business-central/rest/controller"></property>
  <property name="org.kie.server.controller.user" value="kieserver"></property>
  <property name="org.kie.server.controller.pwd" value="kieserver1!"></property>
  <property name="org.kie.server.id" value="HR"></property>
 </system-properties>
 <socket-bindings port-offset="150"/>
</server>
----
<1> `org.kie.server.location`: URL of the server instance.
<2> `org.kie.server.controller`: Comma-separated list of the controller URL(s).
<3> `org.kie.server.controller.user`: Username you created for controller authentication. Uses `kieserver` by default.
<4> `org.kie.server.controller.pwd`: Password for controller authentication. Uses `kieserver1!` by default.
<5> `org.kie.server.id`: Server identifier that corresponds to template ID defined by the controller instance. Give the same ID to multiple server instances that represent one template.
+
The example above is defined for Red Hat JBoss EAP domain mode. For further list of bootstrap switches, see section
ifdef::PAM[]
https://access.redhat.com/documentation/en/red-hat-jboss-bpm-suite/6.4/paged/administration-and-configuration-guide/chapter-3-intelligent-process-server#bootstrap_switches[Bootstrap Switches] of the _{PRODUCT} Administration and Configuration Guide_.
endif::PAM[]
ifdef::DM[]
https://access.redhat.com/documentation/en/red-hat-jboss-brms/6.4/paged/administration-and-configuration-guide/chapter-3-realtime-decision-server#bootstrap_switches[Bootstrap Switches] of _{PRODUCT} Administration and Configuration Guide_.
endif::DM[]
. Repeat the previous step for as many servers as you need. To start Red Hat JBoss EAP in the domain mode, execute:
[source,bash]
----
$ ./SERVER_HOME/bin/domain.sh
----

After connecting the servers to your controller, check the controller log:
[source]
----
13:54:40,315 INFO  [org.kie.server.controller.impl.KieServerControllerImpl] (http-localhost/127.0.0.1:8080-1) Server http://localhost:8180/kie-server/services/rest/server connected to controller
13:54:40,331 INFO  [org.kie.server.controller.impl.KieServerControllerImpl] (http-localhost/127.0.0.1:8080-2) Server http://localhost:8230/kie-server/services/rest/server connected to controller
13:54:40,348 INFO  [org.kie.server.controller.rest.RestKieServerControllerImpl] (http-localhost/127.0.0.1:8080-1) Server with id 'HR' connected
13:54:40,348 INFO  [org.kie.server.controller.rest.RestKieServerControllerImpl] (http-localhost/127.0.0.1:8080-2) Server with id 'HR' connected
----

Alternatively, to verify in controller Business Central:

. Log into the controller Business Central.
. Click *Deploy* -> *Execution Servers*.
. View the remote servers connected to each template.


[id='_generic_bundle_clustering_setup']
== Generic Bundle Clustering

[id='_setting_up_a_cluster']
=== Setting a Cluster

[NOTE]
====
If you do not use Business Central, skip this section.
====

To cluster your Git (VFS) repository in Business Central:

. Download the `jboss-bpmsuite-brms-_VERSION_-supplementary-tools.zip`, which contains Apache ZooKeeper, Apache Helix, and Quartz DDL scripts.
. Unzip the archive: the `ZooKeeper` directory (`_ZOOKEEPER_HOME_`) and the `Helix` directory (`_HELIX_HOME_`) are created.

. Configure Apache ZooKeeper:
+
.. In the ZooKeeper directory, change to `conf` and execute:
+
[source]
----
cp zoo_sample.cfg zoo.cfg
----
.. Edit `zoo.cfg`:
+
[source]
----
# The directory where the snapshot is stored.
dataDir=$ZOOKEEPER_HOME/data/

# The port at which the clients connects.
clientPort=2181

# Defining ZooKeeper ensemble.
# server.{ZooKeeperNodeID}={server}:{port:range}
server.1=localhost:2888:3888
server.2=localhost:2889:3889
server.3=localhost:2890:3890
----
+
NOTE: Multiple ZooKeeper nodes are not required for clustering.
+

Make sure the `dataDir` location exists and is accessible.
.. Assign a node ID to each member that will run ZooKeeper. For example, use `1`, `2`, and `3` for node 1, node 2 and node 3 respectively.
+
The ZooKeeper node ID is specified in a field called `myid` under the data directory of ZooKeeper on each node. For example, on node 1, execute:
+
[source]
----
echo "1" > /zookeeper/data/myid
----

. Provide further ZooKeeper configuration if necessary.
+
. Change to `_ZOOKEEPER_HOME_/bin/` and start ZooKeeper:
+
[source]
----
./zkServer.sh start
----
+
You can check the ZooKeeper log in the `_ZOOKEEPER_HOME_/bin/zookeeper.out` file. Check this log to ensure that the ensemble (cluster) is formed successfully. One of the nodes should be elected as leader with the other two nodes following it.

. Once the ZooKeeper ensemble is started, configure and start Helix. Helix needs to be configured from a single node only. The configuration is then stored by the ZooKeeper ensemble and shared as appropriate.
+
Configure the cluster with the ZooKeeper server as the master of the configuration:
+
.. Create the cluster by providing the ZooKeeper Host and port as a comma-separated list:
+
[source]
----
$HELIX_HOME/bin/helix-admin.sh --zkSvr ZOOKEEPER_HOST:ZOOKEEPER_PORT --addCluster <clustername>
----
.. Add your nodes to the cluster:
+
[source]
----
HELIX_HOME/bin/helix-admin.sh --zkSvr ZOOKEEPER_HOST:ZOOKEEPER_PORT --addNode <clustername> <name_uniqueID>
----
ifdef::PAM[]
+
.Adding Three Cluster Nodes
====
[source]
----
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addNode bpms-cluster nodeOne:12345
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addNode bpms-cluster nodeTwo:12346
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addNode bpms-cluster nodeThree:12347
----
====
endif::PAM[]
ifdef::DM[]
+
.Adding Three Cluster Nodes
====
[source]
----
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addNode brms-cluster nodeOne:12345
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addNode brms-cluster nodeTwo:12346
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addNode brms-cluster nodeThree:12347
----
====
endif::DM[]

. Add resources to the cluster.
+
[source]
----
helix-admin.sh --zkSvr ZOOKEEPER_HOST:ZOOKEEPER_PORT  --addResource <clustername> <resourceName> <numPartitions> <stateModelName>
----
+
Learn more about state machine configuration at http://helix.apache.org/0.6.5-docs/tutorial_state.html[Helix Tutorial: State Machine Configuration].
ifdef::PAM[]
+
.Adding vfs-repo as Resource
====
[source]
----
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addResource bpms-cluster vfs-repo 1 LeaderStandby AUTO_REBALANCE
----
====
endif::PAM[]
ifdef::DM[]
+
.Adding vfs-repo as Resource
====
[source]
----
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --addResource brms-cluster vfs-repo 1 LeaderStandby AUTO_REBALANCE
----
====
endif::DM[]

. Rebalance the cluster with the three nodes.
+
[source]
----
helix-admin.sh --zkSvr ZOOKEEPER_HOST:ZOOKEEPER_PORT --rebalance <clustername> <resourcename> <replicas>
----
+
Learn more about rebalancing at http://helix.apache.org/0.6.5-docs/tutorial_rebalance.html[Helix Tutorial: Rebalancing Algorithms].
ifdef::PAM[]
+
.Rebalancing bpms-cluster
====
[source]
----
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --rebalance bpms-cluster vfs-repo 3
----
====
endif::PAM[]
ifdef::DM[]
+
.Rebalancing brms-cluster
====
[source]
----
./helix-admin.sh --zkSvr server1:2181,server2:2182,server3:2183 --rebalance brms-cluster vfs-repo 3
----
====
endif::DM[]
+
ifdef::PAM[]
In this command, `3` stands for three bpms-cluster nodes.
endif::PAM[]
ifdef::DM[]
In this command, `3` stands for three brms-cluster nodes.
endif::DM[]

. Start the Helix controller in all the nodes in the cluster.
ifdef::PAM[]
+
.Starting Helix Controller
====
[source]
----
./run-helix-controller.sh --zkSvr server1:2181,server2:2182,server3:2183 --cluster bpms-cluster 2>&1 > ./controller.log &
----
====
endif::PAM[]
ifdef::DM[]
+
.Starting Helix Controller
====
[source]
----
./run-helix-controller.sh --zkSvr server1:2181,server2:2182,server3:2183 --cluster brms-cluster 2>&1 > ./controller.log &
----
====
endif::DM[]

NOTE: In case you decide to cluster ZooKeeper, add an odd number of instances in order to recover from failure. After a failure, the remaining number of nodes still need to be able to form a majority. For example a cluster of five ZooKeeper nodes can withstand loss of two nodes in order to fully recover. One ZooKeeper instance is still possible, replication will work, however no recover possibilities are available if it fails.


=== Starting and Stopping a Cluster

To start your cluster, see <<starting_cluster>>. To stop your cluster, see <<_stop_the_cluster>>.

ifdef::PAM[]

[id='_setting_up_quartz']
=== Setting Quartz

NOTE: If you are not using Quartz (timers) in your business processes, or if you are not using the
ifdef::PAM[]
Intelligent Process Server,
endif::PAM[]
ifdef::DM[]
Realtime Decision Server,
endif::DM[]
skip this section. If you want to replicate timers in your business process, use the Quartz component.

Before you can configure the database on your application server, you need to prepare the database for Quartz to create Quartz tables, which will hold the timer data, and the Quartz definition file.

To configure Quartz:

. Configure the database. Make sure to use one of the supported non-JTA data sources. Since Quartz needs a non-JTA data source, you cannot use the Business Central data source. In the example code, PostgreSQL with the user
ifdef::PAM[]
`bpms`
endif::PAM[]
ifdef::DM[]
`brms`
endif::DM[]
and password
ifdef::PAM[]
`bpms`
endif::PAM[]
ifdef::DM[]
`brms`
endif::DM[]
is used.
ifdef::PAM[]
The database must be connected to your application server.
endif::PAM[]

. Create Quartz tables on your database to allow timer events synchronization. To do so, use the DDL script for your database, which is available in the extracted supplementary ZIP archive in `_QUARTZ_HOME_/docs/dbTables`.

. Create the Quartz configuration file `quartz-definition.properties` in `_JBOSS_HOME_/_MODE_/configuration/` directory and define the Quartz properties.
ifdef::PAM[]
+
.Quartz Configuration File for PostgreSQL Database
====
[source]
----
#============================================================================
# Configure Main Scheduler Properties
#============================================================================

org.quartz.scheduler.instanceName = jBPMClusteredScheduler
org.quartz.scheduler.instanceId = AUTO

#============================================================================
# Configure ThreadPool
#============================================================================

org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================

org.quartz.jobStore.misfireThreshold = 60000

org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreCMT
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate
org.quartz.jobStore.useProperties=false
org.quartz.jobStore.dataSource=managedDS
org.quartz.jobStore.nonManagedTXDataSource=notManagedDS
org.quartz.jobStore.tablePrefix=QRTZ_
org.quartz.jobStore.isClustered=true
org.quartz.jobStore.clusterCheckinInterval = 20000

#============================================================================
# Configure Datasources
#============================================================================
org.quartz.dataSource.managedDS.jndiURL=jboss/datasources/psbpmsDS
org.quartz.dataSource.notManagedDS.jndiURL=jboss/datasources/quartzNotManagedDS
----
Note the configured data sources that will accommodate the two Quartz schemes at the very end of the file.
====
endif::PAM[]
ifdef::DM[]
+
.Quartz Configuration File for PostgreSQL Database
====
[source]
----
#============================================================================
# Configure Main Scheduler Properties
#============================================================================

org.quartz.scheduler.instanceName = jBPMClusteredScheduler
org.quartz.scheduler.instanceId = AUTO

#============================================================================
# Configure ThreadPool
#============================================================================

org.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPool
org.quartz.threadPool.threadCount = 5
org.quartz.threadPool.threadPriority = 5

#============================================================================
# Configure JobStore
#============================================================================

org.quartz.jobStore.misfireThreshold = 60000

org.quartz.jobStore.class=org.quartz.impl.jdbcjobstore.JobStoreCMT
org.quartz.jobStore.driverDelegateClass=org.quartz.impl.jdbcjobstore.PostgreSQLDelegate
org.quartz.jobStore.useProperties=false
org.quartz.jobStore.dataSource=managedDS
org.quartz.jobStore.nonManagedTXDataSource=notManagedDS
org.quartz.jobStore.tablePrefix=QRTZ_
org.quartz.jobStore.isClustered=true
org.quartz.jobStore.clusterCheckinInterval = 20000

#============================================================================
# Configure Datasources
#============================================================================
org.quartz.dataSource.managedDS.jndiURL=jboss/datasources/psbrmsDS
org.quartz.dataSource.notManagedDS.jndiURL=jboss/datasources/quartzNotManagedDS
----
Note the configured datasources that will accommodate the two Quartz schemes at the very end of the file.
====
endif::DM[]
+
[NOTE]
====
For MicroSoft SQL Server, add the `acquireTriggersWithinLock` property to the `quartz-definition.properties` file:

`org.quartz.jobStore.acquireTriggersWithinLock=true`
====
+
[IMPORTANT]
.Cluster Node Check Interval
====
The recommended interval for cluster discovery is 20 seconds and is set in the `org.quartz.jobStore.clusterCheckinInterval` of the `quartz-definition.properties` file. Depending on your set up consider the performance impact and modify the setting as necessary.
====
+
The `org.quartz.jobStore.driverDelegateClass` property that defines the database dialect. If you use Oracle, set it to `org.quartz.impl.jdbcjobstore.oracle.OracleDelegate`.

. Provide the absolute path to your `quartz-definition.properties` file in the `org.quartz.properties` property. For further details, see <<_cluster_properties_BPMS>>.
endif::PAM[]

Note: To configure the number of retries and delay for the Quartz trigger, you can update the following system properties: 

* `org.jbpm.timer.quartz.retries` (default value is 5)
* `org.jbpm.timer.quartz.delay` in milliseconds  (default value is 1000) 
