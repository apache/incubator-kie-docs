[id='_chap_git']
= Git

Git is a distributed version control system and it implements revisions as commit objects. Every time when you commit your changes into a repository this creates a new commit object in the Git repository. Similarly, the user can also copy an existing repository. This copying process is typically called cloning and the resulting repository can be referred to as clone. Every clone contains the full history of the collection of files and a cloned repository has the same functionality as the original repository.

The local repository consists of three "trees" maintained by Git as shown in the following figure:

* _Working Directory_ which holds the actual files.
* _Index_ which acts as a staging area.
* _Head_ which points to the last commit the user has made.

The following table provides with a summary of important Git terminology.

.Git Terminology
[cols="1,4", options="header"]
|===
|Term
|Definition

|Branches
|A branch is a named pointer to a commit. Selecting a branch in Git terminology is called to checkout a branch. If you are working in a certain branch, the creation of a new commit advances this pointer to the newly created commit. Each commit knows their parents (predecessors). Successors are retrieved by traversing the commit graph starting from branches or other refs, symbolic reference (for example HEAD) or explicit commit objects. This way a branch defines its own line of descendants in the overall version graph formed by all commits in the repository. You can create a new branch from an existing one and change the code independently from other branches. One of the branches is the default (typically named `master`). The default branch is the one for which a local branch is automatically created when cloning the repository.

|Commit
|When you commit your changes into a repository this creates a new commit object in the Git repository. This commit object uniquely identifies a new revision of the content of the repository. This revision can be retrieved later, for example, if you want to see the source code of an older version. Each commit object contains the author and the committer, thus making it possible to identify who did the change. The author and committer might be different people. The author did the change and the committer applied the change to the Git repository.

|HEAD
|HEAD is a symbolic reference most often pointing to the currently checked out branch. Sometimes the HEAD points directly to a commit object, this is called detached HEAD mode. In that state creation of a commit will not move any branch. The first predecessor of HEAD can be addressed through `HEAD~1`, `HEAD~2` and so on. If you switch branches, the HEAD pointer moves to the last commit in the branch. If you checkout a specific commit, the HEAD points to this commit.

|Index
|Index is an alternative term for the staging area.

|Repository
|A repository contains the history, the different versions over time and all different branches and tags. In Git each copy of the repository is a complete repository. If the repository is not a bare repository, it allows you to checkout revisions into your working tree and to capture changes by creating new commits. Bare repositories are only changed by transporting changes from other repositories. This tutorial uses the term repository to talk about a non bare repository. If it talks about a bare repository, this is explicitly mentioned.

|Revision
|Represents a version of the source code. Git implements revisions as commit objects (or short commits). These are identified by an SHA-1 secure hash. SHA-1 IDs are 160 bits long and are represented in hexadecimal notation.

|Staging area
|The staging area is the place to store changes in the working tree before the commit. The staging area contains the set of the snapshots of changes in the working tree (change or new files) relevant to create the next commit and stores their mode (file type, executable bit).

|Tags
|A tag points to a commit which uniquely identifies a version of the Git repository. With a tag, you can have a named point to which you can always revert to. You can revert to any point in a Git repository, but tags make it easier. The benefit of tags is to mark the repository for a specific reason, for example with a release. Branches and tags are named pointers, the difference is that branches move when a new commit is created while tags always point to the same commit. Technically, a tag reference can also point to an annotated tag object.

|URL
|A URL in Git determines the location of the repository. Git distinguishes between fetchurl for getting new data from other repositories and pushurl for pushing data to another repository.

|Working tree
|The working tree contains the set of working files for the repository. You can modify the content and commit the changes as new commits to the repository.
|===

Import projects from an existing Git repository in Red Hat JBoss Developer Studio (see <<_connecting_jboss_developer_studio_to_the_asset_repository1>>).

[id='_cloning_an_existing_repository']
== Cloning Existing Repository

An existing Git repository can be cloned and used in {PRODUCT}.

.Procedure: Cloning Repository
. Open the *Administration* perspective: on the main menu, click *Authoring* -> *Administration*.

. On the perspective menu, click *Repository* -> *Clone repository*.
+
The *Clone Repository* pop-up window is displayed.
+
.Clone Repository Pop-up
image::installation-guide-4232.png[A screenshot of the Red Hat JBoss BRMS Administration menu -- the Clone repository pop-up window.]

. Enter the mandatory details:
+
* A repository name.
* Select an organizational unit in which the repository is to be created from the *Organizational Unit* drop-down option.
* Enter a Git URL.
* Enter a user name and a password.

. Click *Clone*.

[id='_migrating_a_repository_from_brms_5.3']
== Migrating Repository from {PRODUCT} 5.3

ifdef::DM[]
To migrate data from Red Hat JBoss BRMS 5, do the following:
endif::DM[]
ifdef::PAM[]
To migrate data from JBoss BPM Suite 5, do the following:
endif::PAM[]

. Download the migration tool from https://access.redhat.com[Red Hat Customer Portal] and unzip the downloaded ZIP archive.

. For https://access.redhat.com/site/articles/119933#Cert_5_3[production databases], copy the JDBC driver for the database that is used by the JCR repository into the `libs` directory of the migration tool.

. On the command line, move into the `bin/` directory of the exploded ZIP archive.
+
In a Unix environment, run:
+
----
./runMigration.sh -i SOURCE_PATH -o DESTINATION_PATH -r REPOSITORY_NAME
----
+
In a Windows environment, run:
+
----
./runMigration.bat -i SOURCE_PATH -o DESTINATION_PATH -r REPOSITORY_NAME
----
+
Where:
+
	* `SOURCE_PATH` is the path to the source JCR repository.
	* `DESTINATION_PATH` is the path to the destination Git VFS.
	* `REPOSITORY_NAME` is an arbitrary name for the new repository.
+
The repository is then migrated to the specified location.
