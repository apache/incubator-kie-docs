[id='_chap_process_designer']
= Process Designer


The [term]_Process Designer_ is the Red Hat JBoss BPM Suite process modeler.
The output of the modeler is a BPMN 2.0 process definition file, which is saved in the Knowledge Repository, under normal circumstances with a package of a project.
The definition then serves as input for JBoss BPM Suite Process Engine, which creates a process instance based on the definition.

The editor is delivered in two variants:

JBoss{nbsp}Developer{nbsp}Studio Process Designer::
Thick-client version of the Process Designer integrated in the JBoss{nbsp}Developer{nbsp}Studio
plug-in

Web Process Designer::
Thin-client version of the Process Designer integrated in BPM Central


The graphical user interface of the Process Designer is the same for both the JBoss{nbsp}Developer{nbsp}Studio
 Process Designer and the Web Process Designer.

.Process Designer environment
image::3410.png[]

. The canvas represents the process diagram. Here you can place the elements from the palette which will constitute the process.
Note that one process definition may contain exactly one process diagram; therefore a process definition equals to a process diagram (this may differ in other products).
. The Object Library (palette) contains groups of BPMN2 elements.
Details on execution semantics and properties of individual BPMN2 shapes are available in <<_appe_process_elements>>.
. The Properties panel displays the properties of the selected element. If no element is selected, the panel contains process properties.
+
. The editor toolbar enables you, for example, to select an operation to be applied to the Elements on the canvas. It also contains tools for validation, simulation, saving, and others.

[id='_configuring_automatic_saving']
== Configuring Automatic Saving


The automatic saving feature periodically commits every change in Process Designer into a Git repository.
To set an automatic saving, click the image:save-button.png[] button in Process Designer and choose *Enable autosave*.

.Enable Autosave Option in Process Designer
image::5216.png[Enable autosave feature in Process Designer.]


[id='_defining_process_properties']
== Defining Process Properties

To define process properties, do the following:

. Open your process in the Process Designer.
. Click anywhere on the canvas. Make sure that no process element is selected.
+
[IMPORTANT]
.Process Properties Restrictions
====
When creating a new process or copying an existing process with a name that uses a multibyte encoding (for example in Japanese, Chinese, Russian, or other), these characters are converted to their URL equivalent when the editor generates the process ID property.

Due to BPMN2 type restrictions, it is _not_ recommended to use multibyte encodings when manually changing the process ID.
====
. Click image:3140.png[] to expand the *Properties (BPMN-Diagram)* panel.
+
.Opening Variable Editor
image::3415.jpg[Variable definition input field with the arrow for calling the editor.]
. Define the process properties on the tab by clicking individual entries. For entries that require other input than just string input, the respective editors can be used by clicking the arrow icon. Note that editors for complex fields mostly provide validation and auto-completion features.
. To save your changes, click *Save* in the top right corner.

[id='_sect_designing_a_process']
== Designing a Process


To model a process, do the following:

. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
 . Click *Add Asset â†’ Business Process*.
 . In the *Create new Business Process* window, provide the *Business Process* name and select the correct *Package*.
+
The Process Designer opens.
. Add and edit the required shapes to the process diagram on the canvas.
+
.. Drag and drop the shapes from the *Object Library* palette to the required position on the canvas.
+

.Object Library in the Process Designer
image::5217.png[Object Library view panel.]
.. The quick linker menu appears after you select a shape already placed on the canvas. The menu displays elements that you can connect to the selected shape and connects them with a valid association element.

+

[NOTE]
====
It is possible to change the type of an already placed element.
To do so, select the element and click the *Morph shape* (image:3416.png[]) icon from the quick linker menu.
====
. Double-click an element to provide or change its name. For multiline names, define the element properties in the *Properties* view on the right side of the Process Designer.
. Repeat the previous steps until the process diagram defines the required workflow.

=== Copying Elements

You can copy individual elements and finished business processes. To copy your selection into a different package:

. On the canvas, click and drag the cursor to select the elements you want to copy.
. Click image:3417.png[] to copy your selection.
. Switch into the second business process where you want to your add the copied elements.
. In the second business process, create process variables that are used in the business process you want to copy. Variable `Name` and `Type` parameters must be identical in order to preserve variable mapping.
. Click image:3418.png[] to paste your selection.
. Click *Save*.

To copy a business process into the same package:

. Click *Copy*.
. The *Copy this item* dialogue window appears. Name your copy.
. Click *Create copy*.

[id='_aligning_elements']
=== Aligning Elements


To align diagram Elements, select the elements and click the respective button in the alignment toolbar:


image::5924.png[]

* *Bottom*: the selected elements will be aligned with the element located at the lowest position
* *Middle*: the selected elements will be aligned to the middle relative to the highest and lowest element
* *Top*: the selected elements will be aligned with the element located at the highest position
* *Left*: the selected elements will be aligned with the leftmost element
* *Center*: the selected elements will be aligned to the center relative to the leftmost and rightmost element
* *Right*: the selected elements will be aligned with the rightmost element


Note that dockers of Connection elements are not influenced by aligning and you might need to remove them.

[id='_solving_overlapping_of_elements']
=== Changing Element Layering


To change the element layering, select the required element or a group of elements and click the image:layering-button.png[]
 button in the Process Designer toolbar.
Choose one of the following options:

* image:bring-to-front.png[]*Bring To Front*: bring the selected element to the foreground of the uppermost layer.
* image:bring-to-back.png[]*Bring To Back*: send the selected element to the background of the lowest layer.
* image:bring-forward.png[]*Bring Forward*: bring the selected element to the foreground by one layer.
* image:bring-backward.png[]*Bring Backward*: send the selected element to the background by one layer.


Note that the connection elements are not influenced by the layering and remain always visible.

[id='_bending_connection_elements']
=== Bending Connection Elements


You can bend the connection elements and create angles in your business process. To do so, click and drag the connection element in the desired angle and direction. You can also straighten a bent connection in the same manner, that is clicking on the bent angle and dragging it back to make a straight line.

image:0011.png[]

[id='_resizing_elements']
=== Resizing Elements


To resize Elements on the canvas, select the element, and click and pull the blue arrow displayed in the upper left or lower right corner of the element.

To make the size of multiple elements identical, select the Elements and then click the image:5922.png[] icon in the toolbar and then click on *Alignment Same Size*: all Elements will be resized to the size of the largest selected Element.

Note that only Activity Elements can be resized.

[id='_grouping_elements']
=== Grouping Elements

To create and manage an element group:

. Select the elements on the canvas.
. Click *Groups all selected shapes* (image:5220.png[]) to group the elements.
. Click *Deletes the group of all selected shapes* (image:5221.png[]) to ungroup the elements.


[id='_locking_elements']
=== Locking Elements


When you lock process model elements, the elements cannot be edited or moved.

* To lock the elements, select the elements and click *Lock Elements* (image:5222.png[]).
* To unlock the elements, select the elements and click *Unlock Elements* (image:5223.png[]).


[id='_changing_the_color_scheme']
=== Changing Color Scheme


Color schemes define the colors used for individual process elements in a diagram.

Color schemes are stored in the `themes.json`
 file, which is located in the `global`
 directory of each repository.

.Procedure: Adding New Color Scheme
. Locate your project in the *Project Explorer* and switch to the *Repository View* by clicking the image:settings-button.png[] button.
. Open the `global` directory.
. Locate and open the `themes.json` file.
. Click *Download*.
+
The file is downloaded to your computer. You can now open the file in a text editor and update it locally. Note that it is not possible to update the file directly in {CENTRAL}.
. Upload the updated file. Click *Choose file...* (image:choose-file-button.png[]), select the `themes.json` file and click *Upload* (image:upload-button.png[]).
+
In order to be able to use the new color schemes, you have to reload the browser.


To apply a new color scheme or any other defined scheme, click the image:5224.png[] button in the Process Designer toolbar and select one of the available color schemes from the drop-down menu.

[id='_recording_local_history']
=== Recording local history


Local history keeps track of any changes you apply to your process model to allow you to restore any previous status of the process model. By default, this feature is turned off.

To turn on local history recording, click the *Local History* image:5225.png[] button and select *Enable Local History* entry.
From this menu, you can also display the local history records and apply the respective status to the process as well as disable the feature or clear the current local history log.

[id='_enlarging_and_shriking_canvas']
=== Enlarging and shrinking canvas


To change the size of the canvas, click the respective yellow arrow on the canvas edge.

[id='_validating_a_process']
=== Validating a Process


Process validation can be set up to be continuous or to be only immediate.

To validate your process model continuously, click the *Validate*
 (image:3137.png[]) button in the toolbar of the Process Designer with the process and click *Start Validating*.
If validation errors have been detected, the elements with errors are highlighted in orange.
Click on the invalid element on the canvas to display a dialog with the summary of its validation errors.
To disable continuous validation, click the *Validate*
 (image:3137.png[]) button in the toolbar of the Process Designer with the process and click *Stop Validating*.

Also note that errors on the element properties are visualized in further details in the Properties view of the respective element.

If you want to display the validation errors and not to keep the validation feature activated, click the *Validate*
 (image:3137.png[]) button in the toolbar of the Process Designer with the process and click *View all issues*.

Additionally after you save your process, any validation errors are also displayed in the *Messages* view.

.Stopping continuous validation
image::3138.png[]


=== Correcting Invalid Processes


If your process is invalid and the Process Designer is unable to render it in the designer canvas, you can open the process in XML format and make the necessary corrections.

. In the Project view of the Project Explorer, select your Project and open the process.
+
If the process is valid, the Process Designer opens process diagram on the canvas.
+
If the process is invalid, you will see the following prompt:
+
image::Invalid_Process_Error_Prompt.png[]
. Click *OK*.
+
The invalid process opens as XML in a text editor in the Process Designer.
. You can restore previous correct version of the process by selecting the version either from the *Latest Version* drop-down menu or from the *Overview* tab.
+
Alternatively, you can edit the XML to correct the business process and click *Save*.
+
You can now open the valid process and view it as a diagram on the canvas.


[id='_exporting_a_process1']
== Exporting Process


To export your process definition into one of the supported formats (PNG, PDF, BPMN2, JSON, SVG, or ERDF), do the following:

. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Open your process in *Process Designer*.
. Click the image:export-icon.png[] button and choose one of the following options:
+


image::5923.png[]

* *Share Process Image*: generates a PNG file into the repository and provides the ability to insert it in an HTML page using generated HTML tag.
* *Share Process PDF*: generates a PDF file into the repository and provides the ability to insert it in an HTML page using generated HTML tag.
+
Note that Internet Explorer 11 does not support PDF objects in HTML.
* *Download Process PNG*: generates a PNG file into the repository and the browser starts downloading the file.
* *Download Process PDF*: generates a PDF file into the repository and the browser starts downloading the file.
* *Download Process SVG*: generates an SVG file into the repository and the browser starts downloading the file.
* *View Process Sources*: opens the *Process Sources* dialog box that contains the BPMN2, JSON, SVG, and ERDF source codes. You can download BPMN2 files by clicking *Download BPMN2* at the top. Pressing CTRL+a enables you to select the source code in a particular format, while pressing CTRL+f enables the find tool (use `/re/_SYNTAX_` for a regexp search).
+


image::5925.png[]


[id='_sect_process_elements']
== Process Elements

[id='_process_elements']
=== Generic Properties of Visualized Process Elements


All process elements have the following visualization properties, which can be defined in their *Properties* tab:

Background::
The background color of the element in the diagram

Border color::
The border color of the element in the diagram

Font color::
The color of the font in the element name

Font size::
The size of the font in the element name

Name::
The element name displayed on the BPMN diagram

[id='_defining_process_elements_properties']
=== Defining Process Element Properties


All process elements, including the process, contain a set of properties that define the following:

* _Core_ properties, which include properties such as the name, data set, scripts, and others.
* _Extra_ properties, which include the properties necessary for element execution (see <<_appe_process_elements>>), data mapping (variable mapping) and local variable definitions (see <<_sect_globals>>), and properties that represent an extension of the jBPM engine, such as ``onExitAction``, documentation, and similar.
* _Graphical_ properties, which include graphical representation of elements (such as colors, or text settings).
* _Simulation_ properties, which are used by the simulation engine.


In element properties of the String type, use `#{expression}` to embed a value.
The value will be retrieved on element instantiation, and the substitution expression will be replaced with the result of calling the [method]``toString()`` method on the variable defined in the expression.

Note that the expression can be the name of a variable, in which case it resolves to the value of the variable, but more advanced MVEL expressions are possible as well, for example ``#{person.name.firstname}``.


To define element properties, do the following:

. Open the process definition in the Process Designer.
. On the canvas, select an element.
. Click image:3140.png[] in the upper right corner of the Process Designer to display the *Properties* view.
. In the displayed Properties view, click the property value fields to edit them. Note that where applicable, you can click the drop-down arrow and the relevant value editor appears in a new dialog box.
. Click *Save* in the upper right corner and fill out the *Save this item* dialogue to save your changes.


[id='_sect_save_point']
== Business Process Save Points


To ensure the engine will save the state of the process, a save point is created before the following nodes:

* Catch event
* Human tasks
* Every node marked `Is Async`

Asynchronous continuation allows process designers to decide what activities should be executed asynchronously without any additional work. To mark a node as asynchronous:

.Procedure: Define a Service Task as Asynchronous
. Open the *Properties* menu on the right side of the business process screen.
. Select Service Task you want to make asynchronous in the Process Modelling window.
. Under the *Extra Properties* menu, set the *Is Async* option to ``true``.


The `Is Async` feature is available for all task types (Service, Send, Receive, Business Rule, Script, and User Tasks), subprocesses (embedded and reusable), and multi-instance task and subprocesses. When marked `Is Async`, the node execution is started in a separate thread.

When the engine encounters one of the save point nodes, the transaction is commited into the database before continuing with the execution. This ensures that the state of the process is saved.

[NOTE]
====
Asynchronous processing relies on Executor Service component, which must be configured and running. If you are using {PRODUCT} in the embedded mode, additional steps will be required depending on how you utilize the {PRODUCT} API.

For fully asynchronous workflow execution, use the {KIE_SERVER} configured with JMS Queues.
====

[id='_sect_forms']
== Forms


A _form_ is a layout definition for a page (defined as HTML) that is displayed as a dialog window to the user on:

* Process instantiation
* Task instantiation


The form is then respectively called a _process form_ or a _task form_. Forms acquire data from a human user for both the process instance execution, or the task instance execution:

* A process form can take as its input and output process variables.
* A task form can take as its input Data Input Assignment variables with assignment defined, and as its output Data Output Assignments with assignment defined.

For example:

* With a process form, a user can provide the input parameters needed for process instantiation.
* With a task form, you can use a Human Task to provide input for further process execution.

The input is then mapped to the task using the data input assignment, which you can then use inside of a task. When the task is completed, the data is mapped as a data output assignment to provide the data to the parent process instance. For further information, see <<_sect_assignment>>.

=== Defining Process form


A process form is a form that is displayed at process instantiation to the user who instantiated the process.

To create a process form, do the following:

. Open your process definition in the Process Designer.
. In the editor toolbar, click the *Form*(image:3412.png[]) icon and then *Edit Process Form*.
. Select the editor to use to edit the form. Note that this document deals only with the *Graphical Modeler* option.


Note that the Form is created in the root of your current Project and is available from any other process definitions in the Projects.

[id='_defining_task_form']
=== Defining Task form


A task form is a form that is displayed at User Task instantiation, that is, when the execution flow reaches the task, to the Actor of the User Task.


To create a task form, do the following:

. Open your process definition with the User Task in the Process Designer.
. Select the task on the canvas and click the *Edit Task Form* (image:3412.png[]) in the User Task menu.
. In the displayed Form Editor, define the task form.


[id='_defining_forms']
=== Defining form fields


Once you have created a form definition, you need to define its content: that is its fields and the data they are bound to.
You can add either the pre-defined field types to your form, or define your own data origin and use the custom field types in your form definition.

[NOTE]
====
Automatic form generation is not recursive, which means that when custom data objects are used, only the top-level form is generated (no subforms). The user is responsible for creating forms that represent the custom data objects and link them to the parent form.
====

[id='_sect_form_modeler']
== Form Modeler

Red{nbsp}Hat JBoss{nbsp}BPM{nbsp}Suite provides a custom editor for defining forms called Form Modeler.

Form Modeler includes the following key features:

* Form Modeling WYSIWYG UI for forms
* Form autogeneration from data model / Java objects
* Data binding for Java objects
* Formula and expressions
* Customized forms layouts
* Forms embedding

Form Modeler comes with predefined field types, such as `Short Text`, `Long Text`, or `Integer`, which you place onto the canvas to create a form.
In addition to that, Form Modeler also enables you to create custom types based on data modeler classes, Java classes (must be on the classpath), or primitive Java data types.
For this purpose, the *Form data origin* tab contains three options: *From Basic type*, *From Data Model*, and *From Java Class*.


Use the *Add fields by origin* tab visible in the following figure to select fields based on their source.


.Adding fields by origin
image::5011.png[]

To view and add Java classes created in Data Modeler in Form Modeler, go to section *Form data origin* and select the *From Data Model* option shown in the following figure.




.Adding classes from data model
image::5010.png[]

You can adjust the form layout using the *Form Properties* tab that contains a *Predefined* layout selected by default, as well as a *Custom* option.

When a task or process calls a form, it sends the form a map of objects, which include local variables of the process or task.
Also, when the form is completed, a map is sent back to the process or task with the data acquired in the form.
The form assigns this output data to the local variables of the task or process, and the output data can therefore be further processed.

=== Creating a Form in Form Modeler


To create a new form in Form Modeler, do the following:

. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. On the perspective menu, select *New Item* -> *Form*.
. In the *Create New Form* dialog window, enter the name of your form in *Resource Name*, select the package, and click *OK*.
. Click *Add Asset* -> *Form*.
. In the *Create new Form* dialog window, enter the *Name* of your form, select the package, and click *OK*.

The newly created form will open up. You can add various fields to it when you select the *Add fields by type* option on the Form Modeler tab.
Use the image:4975.png[] button to place the field types onto the canvas, where you can modify them. To modify the field types, use the icons that display when you place the cursor over a field: *First*, *Move field*, *Last*, *Group with previous*, *Edit*, or *Clear*.
The icons enable you to change the order of the fields in the form, group the fields, or clear and edit their content.

The following figure shows a new form created in Form Modeler.



.New form
image::5424.png[]


[id='_opening_an_existing_form_in_form_modeler']
=== Opening an Existing Form in Form Modeler


To open an existing form in a project that already has a form defined, go to *Form Definitions*
 in Project Explorer and select the form you want to work with from the displayed list.



.Opening an Existing Form
image::5427.png[]


[id='_setting_properties_of_a_form_field_in_form_modeler']
=== Setting Properties of a Form Field in Form Modeler


To set the properties of a form field, do the following:

. In Form Modeler, select the *Add fields by type* tab and click the arrow image:4975.png[] button to the right of a field type. The field type is added to the canvas.
. On the canvas, place the cursor on the field and click the edit image:5012.png[] icon.
. In the *Properties* dialog window that opens on the right, set the form field properties and click *Apply* at the bottom of the dialog window for HTML Labels. For other form field properties, the properties change once you have removed focus from the property that you are modifying.


[id='_configuring_a_process_in_form_modeler']
=== Configuring a Process in Form Modeler


You can generate forms automatically from process variables and task definitions and later modify the forms using the form editor.
In runtime, forms receive data from process variables, display it to the user, capture user input, and update the process variables with the new values.
To configure a process in Form Modeler, do the following:

. Create process variables to store the form input. Variables can be of a simple type, like `String`, or a complex type. You can define complex variables using Data Modeler, or create them in any Java integrated development environment (Java IDE) as regular plain Java objects.
. Declare the process variables in the *Editor for Variable Property* window of the *variables definition* property of the business process.
. Determine which variables you want to set as input parameters for the task, which will receive response from the form. After you create the variables, map the variables to inputs by setting *Data Input Assignments* and *Data Output Assignments* for a Human Task. To do so, use the *Data I/O* form of the *Assignments* property.



.Defining a Variable using Data Modeler
====

image::5803.png[]

====

[id='_generating_forms_from_task_definitions']
=== Generating Forms from Task Definitions


In the Process Designer module, you can generate forms automatically from task and variable definitions, and easily open concrete forms from Form Modeler by using the following menu option:

.Generating Forms Automatically
image::5829.png[]

To open and edit a form directly, click the Edit Task Form icon (image:5831.png[]) located above a user task.

.Editing the Task Form
image::5830.png[]

Forms follow a naming convention that relates them to tasks. If you define a form named `_TASK_NAME_-taskform` in the same package as the process, the human task engine will use the form to display and capture information entered by the user. If you create a form named ``_PROCESS_ID_-task``, the application will use it as the initial form when starting the process.

[id='_editing_forms']
=== Editing Forms


After you generate a form, you can start editing it.
If the form has been generated automatically, the *Form data origin*
 tab contains the process variables as the origin of the data, which enables you to bind form fields with them and create data bindings.
Data bindings determine the way task input is mapped to form variables, and when the form is validated and submitted, the way values update output of the task.
You can have as many data origins as required, and use different colors to differentiate them in the *Render color*
 drop down menu.
If the form has been generated automatically, the application creates a data origin for each process variable.
For each data origin bindable item, there is a field in the form, and these automatically generated fields also have defined bindings.
When you display the fields in the editor, the color of the data origin is displayed over the field to give you quick information on correct binding and implied data origin.

To customize a form, you can for example move fields, add new fields, configure fields, or set values for object properties.

[id='_moving_a_field_in_form_modeler']
=== Moving a Field in Form Modeler


You can place fields in different areas of the form.
To move a field, access the field's contextual menu and select the *Move field*
 option shown on the following screenshot.
This option displays the different regions of the form where you can place the field.

.Moving a Form Field in Form Modeler
image::5832.png[]

After you click the *Move field* option, a set of rectangular contextual icons appears. To move a field, select one of them according to the desired new position of the field.

.Destination Areas to Move a Field
image::5833.png[]


[id='_adding_new_fields_to_a_form']
=== Adding New Fields to a Form


You can add fields to a form by their origin or by selecting the type of the form field.
The *Add fields by origin*
 tab enables you to add fields to the form based on defined data origins.

.Adding Fields by Origin
image::5834.png[]

The fields then have correct configuration of the `Input binding expression` and `Output binding expression` properties, so when the form is submitted, the values in the fields are stored in the corresponding data origin. The *Add fields by type* tab enables you to add fields to the form from the fields type palette of the Form Modeler. The fields do not store their value for any data origin until they have correct configuration of the `Input binding expression` and `Output binding expression` properties.

.Adding Fields by Type
image::6059.png[Adding a field by type screen for BRMS/BPMS User Guide 6.1 DR1]

There are three kinds of field types you can use to model your form: simple types, complex types, and decorators. The `simple types` are used to represent simple properties like texts, numeric values, or dates. The following table presents a complete list of supported simple field types:

.Simple Field Types
[cols="15%,45%,25%,15%", frame="all", options="header"]
|===
|
									Name

|
									Description

|
									Java Type

|
									Default on generated forms


|
									Short Text

|
									Simple input to enter short texts.

|
									java.lang.String

|
									yes


|
									Long Text

|
									Text area to enter long text.

|
									java.lang.String

|
									no


|
									Rich Text

|
									HTML Editor to enter formatted texts.

|
									java.lang.Srowing

|
									no


|
									Email

|
									Simple input to enter short text with email pattern.

|
									java.lang.String

|
									no


|
									Float

|
									Input to enter short decimals.

|
									java.lang.Float

|
									yes


|
									Decimal

|
									Input to enter number with decimals.

|
									java.lang.Double

|
									yes


|
									BigDecimal

|
									Input to enter big decimal numbers.

|
									java.math.BigDecimal

|
									yes


|
									BigInteger

|
									Input to enter big integers.

|
									java.math.BigInteger

|
									yes


|
									Short

|
									Input to enter short integers.

|
									java.lang.Short

|
									yes


|
									Integer

|
									Input to enter integers.

|
									java.lang.Integer

|
									yes


|
									Long Integer

|
									Input to enter long integers.

|
									java.lang.Long

|
									yes


|
									Checkbox

|
									Checkbox to enter true/false values.

|
									java.lang.Boolean

|
									yes


|
									Timestamp

|
									Input to enter date and time values.

|
									java.util.Date

|
									yes


|
									Short Date

|
									Input to enter date values.

|
									java.util.Date

|
									no


|
									Document

|
									Allows the user to upload documents to the form.

|
									org.jbpm.document.Document

|
									No

|===

``Complex field types`` are designed for work with properties that are not basic types but Java objects.
To use these field types, it is necessary to create extra forms in order to display and write values to the specified Java objects.

.Complex Field Types
[cols="20%,40%,20%,20%", frame="all", options="header"]
|===
|
									Name

|
									Description

|
									Java Type

|
									Default on generated forms


|
									Simple subform

|
									Renders the form; it is used to deal with 1:1 relationships.

|
									java.lang.Object

|
									yes


|
									Multiple subform

|
									This field type is used for 1:N relationships. It allows the user to create, edit, and delete a set child Objects.Text area to enter long text.

|
									java.util.List

|
									yes

|===

``Decorators`` are a kind of field types that does not store data in the object displayed in the form. You can use them for decorative purposes.

.Decorators
[cols="35%,65%", frame="all", options="header"]
|===
|
									Name

|
									Description


|
									HTML label

|
									Allows the user to create HTML code that will be rendered in the form.


|
									Separator

|
									Renders an HTML separator.

|===

[id='_configuring_fields_of_a_form']
=== Configuring Fields of a Form


Each field can be configured to enhance performance of the form.
There is a group of common properties called generic field properties and a group of specific properties that differs by field type.

Generic field properties:

* `Field Type` can change the field type to other compatible field types.
* `Field Name` is used as an identifier in calculating of formulas.
* `Label` is the text that is displayed as a field label.
* `Error Message` is a message displayed when there is a problem with a field, for example in validation.
* `Label CSS Class` enables you to enter a class css to apply in label visualization.
* `Label CSS Style` enables you to enter the style to be applied to the label.
* `Help Text` is the text displayed as an alternative attribute to help the user in data introduction.
* `Style Class` enables you to enter a class CSS to be applied in field visualization.
* `CSS Style` enables you to directly enter the style to be applied to the label.
* `Read Only` allows reading only, provides no write access to such field.
* `Input Binding Expression` defines the link between the field and the process task input variable. In runtime, it is used to set the field value to the task input variable data.
* `Output Binding Expression` defines the link between the field and the process task output variable. In runtime, it is used to set the task output variable.


[id='_creating_subforms_with_simple_and_complex_field_types']
=== Creating Subforms with Simple and Complex Field Types


Complex Field types is a category of fields in a form.
You can use the complex field types to model form properties that are Java Objects.
Simple subform and Multiple subform are the two types of complex field types.
A simple subform represents a single object and a multiple subform represents an object array inside a parent form.
Once you add one of these fields into a form, you must configure the form with information on how it must display these objects during execution.
For example, if your form has fields representing an object array, you can define a tabular display of these fields in the form.
You cannot represent them as simple inputs such as text box, checkbox, text area, and date selector.

.Procedure: To create and insert a subform containing a single object inside a parent form:
. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click *Add Asset* -> *Form*.
+
A new form opens in the Form Modeler. You must now configure the new form with information of the object it must contain.
. Enter the values for the required fields in the *Form data origin* tab and click *Add data holder*.
+

.Create Subform
image::7222.png[Creating Subform]
. Click *Add fields by origin* tab and add the listed fields to the form.
+

.Add fields by origin
image::7223.png[Adding fields by origin]
. Click the Edit icon on the field in the form to open the *Properties* tab.
. In the *Properties* tab, configure the form by providing required values to the fields and click *Save* to save the subform.
. Open the parent form to configure the properties of the object.
. In the parent form, click the *Add fields by type* tab. Select the object on the form and configure it in the *Properties* tab.
. In the *Properties* tab, select *Simple subform* for the *Field type* property. Then select the newly created subform for the *Default form* field property.
+

.Configure the Parent Form
image::7224.png[Parent Form]
. Click *Save* to save the parent form.
+
This inserts your subform containing a single Java object inside the parent form.


.Procedure: To insert a subform with multiple objects inside a parent form:
. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click *Add Asset* -> *Form*.
+
A new form opens in the Form Modeler.
You must now configure the new form with information on the object array it must contain.
. Enter the values for the required fields in the *Form data origin* tab and click *Add data holder*.
. Click *Add fields by origin* tab and add the listed fields to the form.
. Click the Edit icon on the field in the form to open the *Properties* tab.
. In the *Properties* tab, configure the form by providing required values to the fields. You can use the Formula Engine to automatically calculate field values.
. Click *Save* to save the subform.
. Open the parent form to configure the properties of each of the objects.
. In the parent form, click the *Add fields by type* tab. Select each object on the form one by one and configure them in the *Properties* tab.
. In the *Properties* tab, select *Multiple subform* for the *Field type* property. Then select the newly created subform for the *Default form* field property.
+

.Configure the Parent Form
image::7225.png[Parent Form]
. Click *Save* to save the parent form.
+
This inserts your subform containing an array of Java objects inside the parent form.


[id='_attaching_documents_to_a_form']
=== Attaching Documents to a Form


Red Hat JBoss BPM Suite enables you to attach documents to a form by using the `Document` form field. To attach a `Document` field to a form, you need to:

* Set the marshalling strategy.
* Create a document variable.
* Map the task inputs and outputs correctly to the variable.

.Setting the Marshalling Strategy
. Set the marshalling strategy in the `_PROJECT_HOME_/META_INF/kie-deployment-descriptor.xml`. You can do so in the {CENTRAL} or by editing the file directly. In {CENTRAL}:

.. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
 .. Click *Settings*.
 .. Click *Project Settings: Project General Settings* -> *Deployment descriptor*.
.. Under *Marshalling strategies*, click *Add*.
.. In the *Value* field, click on *Enter Value* and enter: `org.jbpm.document.marshalling.DocumentMarshallingStrategy`.
.. Set *Resolver type* to *reflection*.
.. Click *Save* and *Validate* to ensure correctness of your deployment descriptor file.
+
Alternatively, if you want to edit `kie-deployment-descriptor.xml` directly, add the `<marshalling-strategies>` tag:
+
[source,xml]
----
<deployment-descriptor
    xsi:schemaLocation="http://www.jboss.org/jbpm deployment-descriptor.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <persistence-unit>org.jbpm.domain</persistence-unit>
  <audit-persistence-unit>org.jbpm.domain</audit-persistence-unit>
  <audit-mode>JPA</audit-mode>
  <persistence-mode>JPA</persistence-mode>
  <runtime-strategy>SINGLETON</runtime-strategy>
  <marshalling-strategies>
    <marshalling-strategy>
      <resolver>reflection</resolver>
      <identifier>
        org.jbpm.document.marshalling.DocumentMarshallingStrategy
      </identifier>
    </marshalling-strategy>
  </marshalling-strategies>
----
+
After you correctly set the marshalling strategy, create a document process variable. This step is required for the document to be visible in the *Documents* tab of the *Process Management* -> *Process Instances* view in {CENTRAL}.

. In {CENTRAL}, navigate to your business proces and open it in the Business Process Designer.
. Click on the canvas and click image:3140.png[] to open the *Properties* tab.
. Next to *Variable Definition*, click on the empty space and click image:6563.png[]. The *Editor for Variable Definitions* dialog opens.
. Click *Add Variable* and enter the following values:
+
* Name: `document`
* Custom Type: `org.jbpm.document.Document`
+
. Click *Ok*.
+
image::6226.png[]

If you want to view or modify the attachments inside of the task forms, create assignments inside of the task inputs and outputs:

. In {CENTRAL}, navigate to your business proces and open it in the Business Process Designer.
. Click on a User Task and click image:3140.png[] to open the *Properties* tab.
. Next to *Assignments*, click on the empty space and click image:6563.png[]. The *Data I/O* dialog windowue opens.
. Next to *Data Inputs and Assignments*, click *Add* and enter the values:
+
--
* Name: `taskdoc_in`
* Data Type: `Object`
* Source: `document`
--
+
. Next to Data Outputs and Assignments, click *Add* and enter the values:
+
---
+
--
* Name: `taskdoc_out`
* Data Type: `Object`
* Target: `document`
--
---
+
Note that the `Source` and `Target` fields contain the name of the process variable you created earlier.
+
. Click *Save*.
. In the Process Designer, click image:development-guide-6565.png[] and select *Generate all Forms*.
. Click *Save* to save the process.

You can now build and deploy your project. You can see the `Document` attachment in the *Documents* tab of the *Process Management* -> *Process Instances* view.

image::6224.png[]

[float]
==== Pluggable Variable Persistence


New with this release is also the ability for you to store your document in a location of your choice.
This is defined as _Pluggable Variable Persistence_ and this enables you to store these documents automatically in a centralized content management system (CMS) of choice, behind the scenes.

To implement your custom persistence strategy, start by defining your __Marshaling Strategy__.
This strategy is declared to the Process Engine by the use of deployment descriptors (see [ref]_{ADMIN_GUIDE}_) using the `<marshalling-strategy>` element.
This element should name a type that provides an implementation of the `org.kie.api.marshalling`
 interface.

The following methods in this interface help you create your strategy.

* [method]``public boolean accept(Object object)``: Determines if the given object can be marshalled by the strategy.
* [method]``byte[] marshal(Context context, ObjectOutputStream os, Object object)``: Marshals the given object and returns the marshalled object as byte[].
* [method]``Object unmarshal(Context context, ObjectInputStream is, byte[] object, ClassLoader classloader)``: Reads the object received as byte[] and returns the unmarshalled object
* [method]``void write(ObjectOutputStream os, Object object)``: same as [method]``marshal`` method, provided for backwards compatibility.
* [method]``Object read(ObjectInputStream os)``: same as [method]``unmarshal``, provided for backwards compatibility.


For example, if you create a custom strategy that stores your uploaded documents in Google Drive, your implementation class should not only implement the methods of the `org.kie.api.marshalling`
 package, but this implementation should also be made available to the Process Engine, by putting the classes in its classpath (and declaring the type in the deployment descriptors).

There is a default marshalling strategy that simply saves the uploaded documents in the file system under a folder called `docs`.
This default implementation is defined by the [class]``DocumentStorageService`` class and is implemented through the [class]``DocumentStorageServiceImpl`` class.

[id='_sect_rendering_forms_for_external_use']
=== Rendering Forms for External Use


Forms generated by the Form Builder can be reused in other client applications with the help of the REST API and a JavaScript library.
The REST API defines the end points for the external client applications to call and the JavaScript library makes it easy to interact with these endpoints and to render these forms.

To use this API you will need to integrate the Forms REST JavaScript library in your client application.
The details of the library and the methods that it provides are given in the following section, along with a simple example.
Details of the REST API are present in the [ref]_Red Hat JBoss BPM Suite Developers Guide_, although you should probably only use the REST API via the JavaScript library described here.

==== JavaScript Library for Form Reuse


The JavaScript API for Form Reuse makes it easy to use forms created in one {CENTRAL} application to be used in remote applications and allows loading of these forms from different {CENTRAL} instances, submitting them, launching processes or task instances, and executing callback functions when the actions are completed.

[float]
===== Blueprint for using the JavaScript Library


A simple example of using this API would involve the following steps:

. Integrate the JavaScript library in the codebase for the external client application so that its functions are available.
. Create a new instance of the [class]``jBPMFormsAPI`` class in your own JavaScript code. This is the starting point for all interactions with this library.
+
[source]
----
var jbpmRestAPI = new jBPMFormsAPI();
----
. Call your desired methods on this instance. For example, if you want to show a form, you would use the following method:
+
[source]
----
jbpmRestAPI.showStartProcessForm(hostUrl, deploymentId, processId, divId, onsuccess, onerror);
----
and provide the relevant details (hostUrl, deploymentId, processId and so on. A full list of the methods and parameters follows after this section).
. Do post processing with the optional [parameter]``onsuccess`` and [parameter]``onerror`` methods.
. Work with the form, starting processes ([method]``startProcess()``), claiming tasks ([method]``claimTask()``) starting tasks ([method]``startTask()``) or completing tasks ([method]``completeTask``). Full list of available methods follows after this section.
. Once you're finished with the form, clear the container that displayed it using [method]``clearContainer()`` method.


[float]
===== Full list of available methods in the JavaScript Library


The JavaScript library is pretty comprehensive and provides several methods to render and process forms.

. `showStartProcessForm(hostUrl, deploymentId, processId, divId, onsuccessCallback, onerrorCallback):` Makes a call to the REST endpoint to obtain the form URL. If it receives a valid response, it embeds the process start form in the stated div. You need these parameters:
* ``hostURL``: The URL of the {CENTRAL} instance that holds the deployments.
* ``deploymentId``: The deployment identifier that contains the process to run.
* ``processId``: The identifier of the process to run.
* ``divId``: The identifier of the div that has to contain the form.
* `onsuccessCallback` (optional): A JavaScript function executed if the form is going to be rendered. This function will receive the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to render the form. This function will receive the server response as a parameter.
. `startProcess(divId, onsuccessCallback, onerrorCallback):` Submits the form loaded on the stated div and starts the process. You need these parameters:
* ``divId``: The identifier of the div that contains the form.
* ``onsuccessCallback``(optional): A JavaScript function executed after the process is started. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to start the process. This function receives the server response as a parameter.
. `showTaskForm(hostUrl, taskId, divId, onsuccessCallback, onerrorCallback):` Makes a call to the REST endpoint to obtain the form URL. If it receives a valid response, it embeds the task form in the stated div. You need these parameters:
* ``hostURL``: The URL of the {CENTRAL} instance that holds the deployments.
* ``taskId``: The identifier of the task to show the form.
* ``divId``: The identifier of the div that has to contain the form.
* `onsuccessCallback` (optional): A JavaScript function executed if the form is going to be rendered. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to render the form. This function receives the server response as a parameter.
. `claimTask(divId, onsuccessCallback, onerrorCallback):` Claims the task whose form is being rendered. You need these parameters:
* ``divId``: The identifier of the div that contains the form.
* `onsuccessCallback` (optional): A JavaScript function executed after the task is claimed. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to claim the task. This function receives the server response as a parameter.
. `startTask(divId, onsuccessCallback, onerrorCallback):` Starts the task whose form is being rendered. You need these parameters:
* ``divId``: The identifier of the div that contains the form.
* `onsuccessCallback` (optional): A JavaScript function executed after the task is claimed. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to claim the task. This function receives the server response as a parameter.
. `releaseTask(divId, onsuccessCallback, onerrorCallback):` Releases the task whose form is being rendered. You need these parameters:
* ``divId``: The identifier of the div that contains the form.
* `onsuccessCallback` (optional): A JavaScript function executed after the task is claimed. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to claim the task. This function receives the server response as a parameter.
. `saveTask(divId, onsuccessCallback, onerrorCallback):` Submits the form and saves the state of the task whose form is being rendered. You need these parameters:
* ``divId``: The identifier of the div that contains the form.
* `onsuccessCallback` (optional): A JavaScript function executed after the task is claimed. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to claim the task. This function receives the server response as a parameter.
. `completeTask(divId, onsuccessCallback, onerrorCallback):` Submits the form and completes task whose form is being rendered. You need these parameters:
* ``divId``: The identifier of the div that contains the form.
* `onsuccessCallback` (optional): A JavaScript function executed after the task is claimed. This function receives the server response as a parameter.
* `onerrorCallback` (optional): A JavaScript function executed if any error occurs and it is impossible to claim the task. This function receives the server response as a parameter.
. `clearContainer(divId):` Cleans the div content and the related data stored on the component. You need these parameters:
* ``divId``: The identifier of the div that contains the form.


[id='_sect_variables']
== Variables


Variables are elements that serve for storing a particular type of data during runtime.
The type of data a variable contains is defined by its data type.

Just like any context data, every variable has its scope that defines its visibility.
An element, such as a process, sub-process, or task can only access variables in its own and parent contexts: variables defined in the element's child elements cannot be accessed.
Therefore, when an elements requires access to a variable on runtime, its own context is searched first.
If the variable cannot be found directly in the element's context, the immediate parent context is searched.
The search continues to "level up" until the process context is reached; in case of global variables, the search is performed directly on the session container.
If the variable cannot be found, a read access request returns `null` and a write access produces an error message, and the process continues its execution.
Variables are searched for based on their ID.

In Red Hat JBoss BPM Suite, variables can live in the following contexts:

* Session context: _Global variables_ are visible to all process instances and assets in the given session and are intended to be used primarily by business rules and by constraints. These are created dynamically by the rules or constraints.
* Process context: _Process variables_ are defined as properties in the BPMN2 definition file and are visible within the process instance. They are initialized at process creation and destroyed on process finish.
* Element context: _Local variables_ are available within their process element, such as an activity. They are initialized when the element context is initialized, that is, when the execution workflow enters the node and execution of the `onEntry` action finished if applicable. They are destroyed when the element context is destroyed, that is, when the execution workflow leaves the element.
+
Values of local variables can be mapped to global or process variables using the assignment mechanism (for more information, see <<_sect_assignment>>
). This enables you to maintain relative independence of the parent element that accommodates the local variable.
Such isolation may help prevent technical exceptions.


[id='_sect_globals']
=== Global Variables


Global variables (also known as globals) exist in a knowledge session and can be accessed and are shared by all assets in that session.
Global variables belong to the particular session of the Knowledge Base and they are used to pass information to the engine.

Every global variable defines its ID and item subject reference.
The ID serves as the variable name and must be unique within the process definition.
The item subject reference defines the data type the variable stores.

[IMPORTANT]
====
The rules are evaluated at the moment the fact is inserted.
Therefore, if you are using a global variable to constrain a fact pattern and the global is not set, the system returns a ``NullPointerException``.
====

[id='_creating_global_variables']
==== Creating Global Variables


Global variables are initialized either when the process with the variable definition is added to the session or when the session is initialized with globals as its parameters.
Values of global variables can be changed typically during the assignment, which is a mapping between a process variable and an activity variable.
The global variable is then associated with the local activity context, local activity variable, or by a direct call to the variable from a child context.

.Procedure: Defining Globals in Process Designer

To define a global variable, do the following:

. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click image:left-arrow.png[] in the right hand corner of the *Process Designer* and in the *Properties (BPMN-Diagram)* panel that opens, locate the *Globals* property.
+

.Globals property in the Properties (BPMN-Diagram) panel
image::5226.png[]
. Click the empty value cell and expand the *Editor for Globals* window by clicking the arrow on the right side.
. In the *Editor for Globals* window, click *Add Global* at the top and define the variable details.
+

.Editor for Globals window
image::5227.png[]
. Click *Ok* to add the global variable.

[id='_process_variables']
==== Process variables


A process variable is a variable that exists in a process context and can be accessed by its process or its child elements. Process variables belong to a particular process instance and cannot be accessed by other process instances.
Every process variable defines its ID and item subject reference: the ID serves as the variable name and must be unique within the process definition.
The item subject reference defines the data type the variable stores.

Process variables are initialized when the process instance is created.
Their value can be changed by the process Activities using the Assignment, when the global variable is associated with the local Activity context, local Activity variable, or by a direct call to the variable from a child context.

.Procedure: Defining Process Variables
. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click on an empty space in the canvas and click image:3140.png[].
. Click on the text field next to *Variable Definitions* and click image:6563.png[].
. Define your variables in the *Editor for Variable Definitions* window.
. Click *Ok* and *Save* to save your process.

Note that process variables should be mapped to local variables. See <<_sect_local_variables>> for more information.

[id='_sect_local_variables']
=== Local Variables


A local variable is a variable that exists in a child element context of a process and can be accessed only from within this context: local variables belong to the particular element of a process.

For tasks, with the exception of the Script Task, the user can define [property]``Data Input Assignments`` and [property]``Data Output Assignments`` in the *Assignments* property. Data Input Assignment defines variables that enter the Task and therefore provide the entry data needed for the task execution. The Data Output Assignments can refer to the context of the Task after execution to acquire output data.

User Tasks present data related to the actor that is executing the User Task. Additionally, User Tasks also request the actor to provide result data related to the execution.

To request and provide the data, use task forms and map the data in the Data Input Assignment parameter to a variable. Map the data provided by the user in the Data Output Assignment parameter if you want to preserve the data as output. For further information, see <<_sect_assignment>>.

.Initialization of Local Variables
[NOTE]
====
Local variables are initialized when the process element instance is created.
Their value can be changed by their parent Activity by a direct call to the variable.
====

[id='_accessing_local_variables']
==== Accessing Local Variables


To set a variable value, call the respective setter on the variable field from the Script Activity; for example, `person.setAge(10)` sets the [var]``Age`` field of the [var]``person`` global variable to ``10``.

=== Setting Process Variables From Business Rule Task

Process variables and rule facts do not share the same context. If a rule has to manipulate a process variable, you must explicitly map process variable to rule fact. You can access and set process variables from a business rule task using the folowing approaches:

* Mapping process Variables through Business Rule Task *Assigments* field

* Mapping process Variables through `WorkflowProcessInstance`

==== Mapping Process Variables through Business Rule Task Assigments field

The following example of a domain class called `ValidationError` containing a boolean attribute `isValid` illustrates mapping through the *Assigments* field:

. Set a process variable called `validationError` of type `ValidationError`.
. Instantiate the `ValidationError` object in the `ON ENTRY ACTION` field or in the `Script Tasks` placed before the `Business Rule Task`:
[source]
----
//Instantiate the object and set the flag to false
demo1.hello1.ValidationError validationError1 = new demo1.hello1.ValidationError();
validationError1.setIsValid(false);

//Assign the object to the process variable
kcontext.setVariable("validationError",validationError1);
----

. In the Business Rule Task, click *Assignments* field and map the task variable in *DataInput* and *DataOutput*:
* *Name*: `myvar`
* *Data type*: `demo1.hello1.ValidationError`
* *Source*: `validationError`

. Edit the rules belonging to the `ruleflow-group` and assign it to the Business Rule Task:
[source]
----
rule "HelloAll"
dialect "mvel"
ruleflow-group "validate"
no-loop
when
    _myvar: ValidationError()
then
    _myvar.setIsValid( true );
    update( _myvar );
    System.out.println("The value returned is: " + _myvar.getIsValid());
end
----

Here, the rule is inserting the fact in the Business Rule Task through `DataInput` and binding it to `_myvar`. You can modify the `THEN` part of the rule and use it in your process as it is now mapped to `validationError` variable in `DataOutput`.

==== Mapping Process Variables through WorkflowProcessInstance

The following example of setting a process variable, which is used for group attribute in a Human Task, illustrates how you can map process variables through `WorkflowProcessInstance`:

. Create a process variable called `dynamicGroupId` with type `String`.
. In the Human Task, set *Groups* attribute as  `#{dynamicGroupId}`.
. Put the Business Rule Task ahead of the Human Task and set the ruleflow group value to `dynamic-group`.
. Create a rule under this ruleflow group. This rule sets the process variable `dynamicGroupId` dynamically based on its conditions. For example:
[source]
----
import org.kie.api.runtime.process.WorkflowProcessInstance;

    rule "sampleRule"
        no-loop true
        ruleflow-group "dynamic-group"
        when
            $process : WorkflowProcessInstance( )
        then
	    WorkflowProcessInstance $p = (WorkflowProcessInstance)kcontext.getKieRuntime().getProcessInstance($process.getId()); //casting to WorkflowProcessInstance is essential
	    $p.setVariable( "dynamicGroupId","analyst" );
	    retract($process);
----

The `WorkflowProcessInstance` object is not inserted into the ksession by default. You can insert it using the following:
[source]
----
kcontext.getKieRuntime().insert(kcontext.getProcessInstance());
----

[NOTE]
====
When a process instance is inserted into ksession as a fact, it can only be used to read values from it. This is because when using persistence, a process instance is considered read-only after a transaction is completed. You must reload the process instance before you attempt to modify it and once the work is done, retract it before the proces is completed.
====


[id='_action_scripts']
== Action Scripts


Action scripts are pieces of code that define the [property]``Script`` property of a Script Task or an Element's interceptor action.
They have access to globals, the process variables, and the predefined variable [var]``kcontext``.
Accordingly, [var]``kcontext`` is an instance of `ProcessContext` class and the interface content can be found at the following location: http://docs.jboss.org/jbpm/v7.0/javadocs/org/kie/api/runtime/process/ProcessContext.html[Interface ProcessContext].

Currently, dialects Java and MVEL are supported for action script definitions.
Note that MVEL accepts any valid Java code and additionally provides support for nested access of parameters, for example, the MVEL equivalent of Java call `person.getName()` is ``person.name``.
It also provides other improvements over Java and MVEL expressions are generally more convenient for the business user.

.Action script that prints out the name of the person
====
[source]
----
// Java dialect
System.out.println( person.getName() );

//  MVEL dialect
System.out.println( person.name );
----
====

[id='_interceptor_actions']
== Interceptor Actions


For every activity, you can define the following actions:

* ``On Entry Actions``, which are executed before the activity execution starts, after the activity receives the token.
* ``On Exit Actions``, which are executed after the activity execution, before the outgoing flow is taken.


You can define both types of actions in the *Properties*
 tab of the activity.
You can define them either in Java, Javascript, Drools, or MVEL, and set the language in the *Script Language*
 property.

[id='_sect_assignment']
== Assignment


The assignment mechanism enables you to pass data into, and retrieve data out of, Activities in business processes.
Assignments that pass data into Activities are executed before the Activity itself is executed.
Assignments map from Business process variables to local data items in activities, known as Data Input Assignments.
Assignments that retrieve data from Activities are executed after the Activity has executed.
They map from local data items in activities, known as Data Output Assignments, to business process variables.

=== Data I/O Editor


The Data I/O Editor is the dialog window used to define Activity DataInputs and DataOutputs, as well as the mappings between them and process variables.

Like process variables, DataInputs and DataOutputs have a name and data-type, such as Integer, String, or a subclass of Java Object, such as a user-defined Data Object created within JBoss BPM Suite.
The data-types of DataInputs and DataOutputs should match the data-types of the process variables which they are mapped to or from.
Their names may be the same as the corresponding process variables, but this is not a requirement.

Process Variables are defined in the *Variable Definitions*
 property of the business process.
Element DataInputs and DataOutputs are defined in one of three properties of Activities, depending on the element type:

* Elements such as [parameter]``User Tasks`` and [parameter]``Call Activities``, which have both DataInputs and DataOutputs, use a property called [parameter]``Assignments``.
* Elements such as [parameter]``Start Events`` and [parameter]``Intermediate Catch Events``, which have DataOutputs but do not have DataInputs, use a property called [parameter]``DataOutputAssociations``.
* Elements such as [parameter]``End Events`` and [parameter]``Intermediate Throw Events``, which have DataInputs but do not have DataOutputs, use a property called [parameter]``DataInputAssociations``.


The [parameter]``Assignments``, [parameter]``DataOutputAssociations``, and [parameter]``DataInputAssociations`` properties are all edited in the Data I/O Editor.
DataInputs can have values assigned to them either by mapping from process variables or by assigning constant values to them.
DataOutputs are mapped to process variables.

To define the DataInputs, DataOutputs and Assignments for an Element, select the Element in the Business process and click the image:dataio.png[]
			button to open the Data I/O Editor.
Data Input Assignments and Data Output Assignments can be added by clicking the *Add*
 button.


image::BasicIOEditor.png[]


You can also open the Data I/O Editor to edit the Data Inputs and/or Outputs by editing the appropriate property for the activity: [parameter]``Assignments``, [parameter]``DataOutputAssociations``, or [parameter]``DataInputAssociations``.


=== Data I/O Editor Example

In the following example, the Data I/O Editor has been used to create some Data Inputs and Data Outputs for the user activity ``Check Invoice``.
The example makes use of two process variables that have been defined in the process:

* `invoice` with the type [class]``org.kie.test.Invoice;``
* `reason` with the type ``String``



image::CheckInvoiceDataIO.png[]


The following Data Inputs have been added:

* `invoice`
* `reason`
* `maxamount`
* `myvar`

The Data Inputs and Data Outputs are linked to the corresponding process variables by setting the *Source*
 and *Target* fields in the dialog window.

The Data I/O Editor enables you to create and assign a constant to a Data Input when setting the *Source*
 column for a Data Input.
This is demonstrated by the `maxamount` Data Input, that has the constant ``1000.00``, which will be assigned to it at runtime.

The `myvar` Data Input and Data Output demonstrates a custom *Data Type*``com.test.MyType``, which is entered in the dialog window by the user.

[id='_constraints2']
== Constraints


A constraint is a boolean expression that is evaluated when the element with the constraint is executed.
The workflow depends on the result of the evaluation, that is `true` or ``false``.

There are two types of constraints:

* ``Code constraints``, which are defined in Java, Javascript, Drools, or MVEL, and have access to the data in the working memory, including the global and process variables.
+

.Java Code Constraint
====
[source,java]
----
return person.getAge() > 20;
----
====
+

.MVEL Code Constraint
====
[source,mvel]
----
return person.age > 20;
----
====
+

.Javascript Code Constraint
====
[source,javascript]
----
kcontext.setVariable('surname', "tester");
var text = 'Hello ';
print(text + kcontext.getVariable('name') + '\n');
----
====

* ``Rule constraints``, which are defined in the form of DRL rule conditions. They have access to data in the working memory, including the global variables. However, they cannot access the variables in the process directly, but through the process instance. To retrieve the reference of the parent process instance, use the [var]``processInstance`` variable of the type [class]``WorkflowProcessInstance``. Note that you need to insert the process instance into the session and update it if necessary, for example, using Java code or an on-entry, on-exit, or explicit action in your process.
+

.Rule Constraint with Process Variable Assignment
====
[source,java]
----
import org.kie.api.runtime.process.ProcessInstance;
import org.kie.api.runtime.process.WorkflowProcessInstance;
...
processInstance : WorkflowProcessInstance()
Person( name == ( processInstance.getVariable("name") ) )
----

This rule constraint condition retrieves the process variable [var]``name``.
====


Red Hat JBoss BPM Suite includes a script editor for Java expressions.
The constrain condition allows code constraints for scripts in Java as demonstrated by the editor below.

.Script Editor
image::6086.png[Script editor for BPM Suite 6.3 constraints.]


When a Java script cannot be represented by the editor, the following alert appears:


image::6087.png[]

[id='_sect_domain_specific_tasks']
== Domain-Specific Tasks


A domain-specific task is a task with custom properties and handling for a given domain or company.
You can use it repeatedly in different business processes and accommodate interactions with other technical system.

In Red Hat JBoss BPM Suite, domain-specific task nodes are referred to as `custom work items` or ``custom service nodes``.

When creating custom work items, define the following:

Work Item Handler::
A work item handler is a Java class that defines how to execute a custom task.
Tasks are executed in the Execution Engine, which contains a work item handler class, that defines how to handle the particular work item.
For the Execution Engine to execute your custom work item, you need to:
+
* Create a work item handler class for the custom work item.
* Register the work item handler with the Execution Engine.

Work Item Definition::
A work item definition defines how the custom task is presented (its name, icon, parameters, and similar attributes).

[id='_sect_work_item_definition']
=== Work Item Definition


You can define a work item definition in:

* Red Hat JBoss Developer Studio Process Designer
* Web Process Designer


A work item has the following properties:

name::
A unique name of a service in the given work item set.

description::
The description of a service.

version::
A version number.

parameters::
Defines service data inputs by specifiyng a name and a type. To define service data outputs, you can add a new property `results` that follows the same structure.

displayName::
The name displayed in a palette.

icon::
Refers to a file with the specified name that must be located in the same directory as the work item configuration file to be used by the import wizard. Icons are used in process diagrams. Icon is a GIF or PNG file with a size of 16x16 px.

category::
Defines a category under which a service is placed when browsing the repository. If the defined category does not exit, a new category is created.

defaultHandler::
--
Defines the default handler implementation, for example a Java class that implements the `WorkItemHandler` interface and can be used to execute the service. The class can be automatically registered as a handler when importing the service from a repository.

It is also possible to use MVEL to resolve the expression. MVEL provides the additional benefit of resolving handler's parameters. For example:

[source]
----
"defaultHandler" : "mvel: new org.jbpm.process.workitem.twitter.TwitterHandler(ksession)"
----

Available parameters are for example: `ksession`, `taskService`, `runtimeManager`, `classLoader`, and `entityManagerFactory`.
--

documentation::
Refers to an HTML file with the specified name that must be located in the same directory as the work item configuration file. The file contains a description of the service.

dependencies::
--
The dependencies for the `defaultHandler` class. It is usually the handler's implementation JAR, but the list can contain additional external dependencies as well.

Make sure you provide correct path to the files: use relative path to the directory where the work item configuration file is located.

If the dependencies are located in a Maven repository, you can define them in the `mavenDependencies` property:

[source]
----
"mavenDependencies" : [
  "org.jbpm:jbpm-twitter:1.0",
  "org.twitter4j:twitter4j-core:2.2.2" ]
----
--


[id='_creating_a_work_item']
=== Creating Custom Work Item Definition

[float]
==== JBoss Developer Studio Process Designer


To create a custom work item definition (WID) in JBoss Developer Studio Process Designer, follow these steps:

. Create `WID_NAME.wid` in `META-INF`. For example, `$PROJECT_HOME/src/main/resources/META-INF/WID_NAME.wid`.
+
This file is identical to a work item definition file created in {CENTRAL}.
. Copy all the icons you want to use into `$PROJECT_HOME/src/main/resources/icons`.


[float]
==== Web Process Designer


To create a custom work item definition (WID) in the Web Process Designer, follow these steps:

. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click *WORK ITEM DEFINITIONS* -> *WorkDefinitions*.
+
The *WorkDefinitions* asset is created by default and contains a number of pre-set work item definitions.
. The *Work Item Definitions* editor opens. Add your WID at the end, for example:
+
[source,json]
----

[
"name" : "Google Calendar",
"description" : "Create a meeting in Google Calendar",
"version" : "1.0",
"parameters" : [
	"FilePath" : new StringDataType(),
	"User" : new StringDataType(),
	"Password" : new StringDataType(),
	"Body" : new StringDataType()
],
"displayName" : "Google Calendar",
"icon" : "calendar.gif"
]
----
+

[NOTE]
====
The process designer allows you to assign pre-defined ListDataType or EnumDataType to your Work Item Definitions. For more information, see xref:pre_defined_list_enum[Assign Pre-Defined ListDataType or Enumeration to Work Item Definitions].


Additionally, The icon defined in the WID must be set and exist in your project. Otherwise, Red Hat JBoss Developer Studio does not display the custom task.
====
. Click *Validate* to make sure your definition is correct.
. Click *Save*.


[float]
[id='pre_defined_list_enum']
==== Assign Pre-Defined ListDataType or Enumeration to Work Item Definitions
The process designer allows you to add service task list of predefined values for assignments:

* To assign pre-defined strings to your work item definition, use a comma separated parameter values as shown in the following example:
[source]
----
[
    "name" : "Email",
    "parameters" : [
      "From" : new StringDataType(),
      "To" : new StringDataType(),
      "Subject" : new StringDataType(),
      "Body" : new StringDataType()
    ],
    "parameterValues" : [
      "To": "John, Petr, Ivan"
    ],
    "displayName" : "Email",
    "icon" : "defaultemailicon.gif"
 ]
----

* To assign pre-defined enumerators to your work item definition, upload a built maven project containing the enumerators, add the uploaded jar to the project dependencies and use it. See the following example:
[source]
----
[
    "name" : "Email",
    "parameters" : [
      "From" : new StringDataType(),
      "To" : new StringDataType(),
      "Subject" : new StringDataType(),
      "Body" : new StringDataType()
    ],
    "parameterValues" : [
      "To" : new EnumDataType("com.redhat.documentation.example.Department")
    ],
    "displayName" : "Email",
    "icon" : "defaultemailicon.gif"
 ]
----

For more information on how to add dependencies to your project, See <<dependencies_add_proc,Adding Dependencies>>.

[float]
==== Upload Custom Icon to Work Item Definition

To upload a custom icon for your work item definition, follow these steps:

. Click *New Item* -> *Uploaded file*.
. In the *Create new Uploaded file* dialog box, define the resource name, including file extension.
. Click *Choose File* and upload the file (``png`` or ``gif``, 16x16 pixels).
. Click *Ok*.


You can now refer to your icon in your WID. Your WID is in the Process Designer, in the *Service Tasks* section by default.

[id='_work_item_handler']
=== Work Item Handler


A work item handler is a Java class used to execute or abort (during asynchronous execution) work items.
The class defines the business logic of the work item, for example how to contact another system and request information, which is then parsed into the custom task parameters.
Every work item handler must implement [class]``org.kie.api.runtime.process.WorkItemHandler``, which is a part of the KIE API.

For more information about work item handlers, see {URL_USER_GUIDE}#appe_service_tasks[Appendix B. Service Tasks: WS Task, Email Task, REST Task] from {USER_GUIDE}.

.Different work item handler for every system
[NOTE]
====
You can customize the behavior of your work item by registering different work item handlers on different systems.
====

Red Hat JBoss BPM Suite comes with multiple work item handlers in the following modules:

* The `org.jbpm.bpmn2.handler` package in the `jbpm-bpm2` module contains:
 ** ReceiveTaskHandler (for the BPMN <receiveTask> element)
 ** SendTaskHandler (for the BPMN <sendTask> element)
 ** ServiceTaskHandler (for the BPMN <serviceTask> element)
 +
 * The `org.jbpm.process.workitem` package in the `jbpm-workitems` module contains:
 ** ArchiveWorkItemHandler
 ** WebServiceWorkItemHandler
 ** TransformWorkItemHandler
 ** RSSWorkItemHandler
 ** RESTWorkItemHandler
 ** JavaInvocationWorkItemHandler
 ** JabberWorkItemHandler
 ** JavaHandlerWorkItemHandler
 ** FTPUploadWorkItemHandler
 ** ExecWorkItemHandler
 ** EmailWorkItemHandler

The work item handlers must define the `executeWorkItem()` and `abortWorkItem()` methods as defined by the [class]``WorkItemHandler`` interface.
These are called during runtime on work item execution.

When a work item is executed, the following is performed:

. Information about the task is extracted from the WorkItem instance.
. The work item business logic is performed.
. The process instance is informed that the work item execution finished (as completed or aborted) using the respective method of the WorkItemManager:
+

[source,java]
----

public class GoogleCalendarHandler implements WorkItemHandler {
 @Override
 public void executeWorkItem(WorkItem workItem, WorkItemManager manager) {
   Map<String, Object> results = new HashMap<String, Object>();
   // obtain parameters
   String filePath = (String) workItem.getParameter("FilePath");
   String user = (String) workItem.getParameter("User");
   // execute the custom logic here
   // pass results to next processing, for example
   Object result;
   results.put("Result", result);
   manager.completeWorkItem(workItem.getId(), results)
 }
 @Override
 public void abortWorkItem(WorkItem workItem, WorkItemManager manager) {
   manager.abortWorkItem(workItem.getId());
  }

}
----
+
If you use the work item in a maven project, you need to declare the following dependency:
+

[source,xml]
----
<dependency>
	<groupId>org.jbpm</groupId>
	<artifactId>jbpm-workitems</artifactId>
	<version>7.0.0.Final-redhat-2</version>
</dependency>
----

To abort the work item, use the `WorkItemHandler.abortWorkItem()` before it is completed.
For more information about asynchronous execution, see _{DEVELOPMENT_GUIDE}_.

[id='_registering_a_work_item_handler']
=== Registering Work Item handler in {CENTRAL}


To register a work item handler in {CENTRAL}, follow these steps:

.Procedure: Uploading JAR File
. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click *Settings*.
. Click *Project Settings: Project General Settings* and select *Dependencies* from the menu.
. Click *Add from repository* and select the file you have uploaded.
. Click *Upload* and select the JAR file of your work item handler.
. Click *Upload*.


.Procedure: Adding Dependencies
. In {CENTRAL}, go to *Menu -> Design -> Projects* and click the project name. For example, *Evaluation*.
. Click *Settings*.
. Click *Project Settings: Project General Settings* and select *Deployment descriptor*.
. Scroll down to *Work Item handlers* and click *Add*.
. Double-click the *Name* field and enter the name of your custom work item definition. For example, __GoogleCalendar__.


.Procedure: Registering Work Item Handler
. Click *Authoring* -> *Project Authoring*.
. Click *Open Project Editor*.
. Click *Project Settings: Project General Settings* and select *Deployment descriptor* from the menu.
. Navigate to *Work Item handlers* and click *Add*.
. Enter the name of your custom work item definition into the first `Value` field with no white spaces. For example, __GoogleCalendar__.
. Instantiate your work item handler in the second field. For example, if your work item is in the `com.sample` package, `new com.sample.GoogleCalendarHandler()`.
. Click *Save*.

[NOTE]
====
If you want your work item handler to be available for all your projects, place the JAR file in `DEPLOY_DIR/business-central.war/WEB-INF/lib/`.

If you want to register your work item handler for all your projects, you can do so in `{SERVER_HOME}/business-central.war/WEB-INF/classes/META-INF/kie-wb-deployment-descriptor.xml`.
====

=== Registering Work Item Handler Outside of {CENTRAL}

To register your Work Item Handler in the `kie-deployment-descriptor.xml` file:

. Open the `_PROJECT_HOME_/META_INF/kie-deployment-descriptor.xml` file.
. Locate the `<work-item-handlers>` tag.
. Add your Work Item Handler, for example:
+
[source,xml]
----
<work-item-handler>
  <resolver>mvel</resolver>
  <identifier>
    new org.jbpm.process.workitem.rest.RESTWorkItemHandler(classLoader)
  </identifier>
  <parameters/>
  <name>Rest</name>
</work-item-handler>
----
. If your Work Item Handler uses a custom `JAR` file, include it in your `pom.xml` as a dependency.


Alternatively, if you use [class]``RuntimeManager`` directly, see the following example:

[source,java]
----
import java.util.Map;

import org.kie.api.KieServices;
import org.kie.api.io.ResourceType;
import org.kie.api.runtime.process.WorkItemHandler;
import org.kie.api.runtime.manager.RuntimeEngine;
import org.kie.api.runtime.manager.RuntimeEnvironment;
import org.kie.api.runtime.manager.RuntimeEnvironmentBuilder;
import org.kie.api.runtime.manager.RuntimeManagerFactory;
import org.jbpm.executor.impl.wih.AsyncWorkItemHandler;
import org.jbpm.runtime.manager.impl.DefaultRegisterableItemsFactory;

...

RuntimeEnvironment environment = RuntimeEnvironmentBuilder.Factory.get().newDefaultBuilder()
  .userGroupCallback(userGroupCallback)
  .addAsset(ResourceFactory.newClassPathResource("BPMN2-ScriptTask.bpmn2"), ResourceType.BPMN2)
  .registerableItemsFactory(new DefaultRegisterableItemsFactory() {

    @Override
    public Map<String, WorkItemHandler> getWorkItemHandlers(RuntimeEngine runtime) {
      Map<String, WorkItemHandler> handlers = super.getWorkItemHandlers(runtime);
      handlers.put("async", new AsyncWorkItemHandler(executorService, "org.jbpm.executor.commands.PrintOutCommand"));
      return handlers;
    }
  })
  .get();

manager = RuntimeManagerFactory.Factory.get().newSingletonRuntimeManager(environment);

----


* Implementations of the `org.kie.api.task.UserGroupCallback` interface are in the `org.jbpm.services.task.identity` package.
* Use CDI injection to get an instance of the `org.kie.api.executor.ExecutorService` interface. If your container does not support CDI injection, use factory `org.jbpm.executor.ExecutorServiceFactory`.


To include a custom [class]``WorkItemHandler``, implement the [interface]``RegisterableItemsFactory`` interface.
Alternatively, you can  extend the following existing implementation and add your handlers:

* [class]``org.jbpm.runtime.manager.impl.SimpleRegisterableItemsFactory``
* [class]``org.jbpm.runtime.manager.impl.DefaultRegisterableItemsFactory``
* [class]``org.jbpm.runtime.manager.impl.KModuleRegisterableItemsFactory``
* [class]``org.jbpm.runtime.manager.impl.cdi.InjectableRegisterableItemsFactory``


For further information about the implementation, see the `org.jbpm.runtime.manager.impl.*` package.

For a list of Maven dependencies, see example _Embedded jBPM Engine Dependencies_ in chapter {URL_DEVELOPMENT_GUIDE}#dependency_management[Dependency Management] of the _{DEVELOPMENT_GUIDE}_.

[NOTE]
====
The recommended practice is to use the https://github.com/droolsjbpm/jbpm/tree/7.0.x/jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api[Service API] and register your work item handlers in KJAR in `kie-deployment-descriptor.xml`.
====

[id='_sect_service_repository']
== Service Repository

The service repository feature enables you to import an already existing service from a repository directly into your project. It allows multiple users to reuse generic services, such as work items allowing integration with Twitter, performing file system operations, and similar. Imported work items are automatically added to your palette and ready to use.

If you connect to a service repository using its URL, a list of available provided services opens. Each of the listed services can then be installed into your project. If you install a service:

* The service configuration (work item definition file, `.wid`) is installed into the project as well. This file can later be edited. If there is already a work item definition file present, it will _not_ be overwritten.
* A service icon defined in the service configuration is installated as well. If the icon does not exist, a default one is provided.
* The service's Maven dependencies are added into the project's `pom.xml` file.
* The service default handler is added into the project's deployment descriptor.

[IMPORTANT]
.Public Service Repository
====
A public service repository with various predefined work items is available at http://docs.jboss.org/jbpm/v6.4/repository/.
====

NOTE: Although you can import any work items, only the following work items are available by default (and supported) in {PRODUCT}: Log, Email, Rest, and WS. You can still import the other work items, but they are _not_ supported by Red Hat.

[id='_connecting_to_a_service_repository1']
=== Installing Services from Service Repository

There are two ways of installing services from a service repository: using Process Designer in {CENTRAL} or during the {CENTRAL} startup process.

[float]
==== Installing Services in Process Designer

To import a work item from a service repository directly in {CENTRAL}, do the following:

. Open your process in Process Designer.
. In the editor menu, click *Connect to a Service Repository* (image:5346.png[]).
. In the *Service Repository Connection* window, define the location of the repository on the location input line and click *Connect*.
+
.Establishing Connection to Service Repository
image::3394.png[Service Repository Connection window with loaded content.]
. To install an asset, click image:install.png[] next to the asset you want to install.
+
After the service is successfully installed, a notification will appear on the screen. To start using the service, save and reopen your process.

[float]
==== Installing Services During {CENTRAL} Startup

The automatic installation enables you to specify the repository URL and a list of services to be installed during the {CENTRAL} startup process. The services are then ready for use after you create or open a process in Process Designer.

NOTE: Make sure you have the correct service names specified in the service's `.wid` file ready.

To install a service (for example Twitter) from the repository located at http://docs.jboss.org/jbpm/v6.4/repository/, start the server using the following command:

[source]
----
./standalone.sh -Dorg.jbpm.service.repository=http://docs.jboss.org/jbpm/v7.0/repository/ -Dorg.jbpm.service.servicetasknames=Twitter
----

You can specify more services at once by separating them with a comma. Install-all option is not currently available.

[source]
----
./standalone.sh -Dorg.jbpm.service.repository=http://docs.jboss.org/jbpm/v7.0/repository/ -Dorg.jbpm.service.servicetasknames=Twitter,Jabber
----

[IMPORTANT]
.Work Items May Not Appear in Your Palette
====
Every work item must be registered in the `_DEPLOY_DIRECTORY_/business-central.war/WEB-INF/classes/META-INF/CustomWorkItemHandler.conf` file. If a work item is not registered in the file, it will not be available for use.
====

[id='_setting_up_a_service_repository']
=== Setting up Service Repository

A service repository can be any repository, local or remote, with the `index.conf` file in its root directory.

[float]
==== Repository Configuration File

The `index.conf` file must be located in the root directory of the service repository. It contains a list of folders to be processed when searching for services in the service repository.

.index.conf
====
[source]
----
Email
FileSystem
ESB
FTP
Google
Java
Jabber
Rest
RSS
Transform
Twitter
----
====

Each directory can contain another `index.conf` file. In that case, a new hierarchical structure is created and additional subfolders are scanned. Note that the hierarchical structure of the repository is not shown when browsing the repository using the import wizard, as the `category` property in the configuration file is used for that.

[float]
==== Work Item Configuration File

Directories with work items must contain:

* A work item configuration file.
* All resources referenced in the work item configuration file: icon, documentation, and dependencies.

A _work item configuration file_ is a file with the same name as the parent directory, for example `Twitter.wid`, that contains details about the work item resources in the service repository. The file is an extension of the work item definition file (see <<_sect_work_item_definition>>). Note that the configuration file must contain references to any dependencies the work item handler requires. Optionally, it can define the documentation property with a path to documentation and category which defines the category the custom work item is placed under in the repository.

.Work Item Configuration File (MVEL)
====
[source]
----
import org.drools.core.process.core.datatype.impl.type.StringDataType;
[
  [
    "name" : "Twitter",
    "description" : "Send a Twitter message.",
    "parameters" : [
      "Message" : new StringDataType() ],
    "displayName" : "Twitter",
    "eclipse:customEditor" : "org.drools.eclipse.flow.common.editor.editpart.work.SampleCustomEditor",
    "icon" : "twitter.gif",
    "category" : "Communication",
    "defaultHandler" : "org.jbpm.process.workitem.twitter.TwitterHandler",
    "documentation" : "index.html",
    "dependencies" : [
      "file:./lib/jbpm-twitter.jar",
      "file:./lib/twitter4j-core-2.2.2.jar" ]
  ]
]
----
====

When creating a work item configuration file, it is also possible to use JSON instead of MVEL. See the previous example written in JSON:

.Work Item Configuration File (JSON)
====
[source]
----
[
  [
    "java.util.HashMap",
     {
      "name":"TestServiceFour",
      "displayName":"Twitter",
      "description":"Send a Twitter message",
      "parameters":[
        "java.util.HashMap",
         { "Message":["org.drools.core.process.core.datatype.impl.type.StringDataType", {}] } ],
      "eclipse:customEditor":"org.drools.eclipse.flow.common.editor.editpart.work.SampleCustomEditor",
      "defaultHandler" : "org.jbpm.process.workitem.twitter.TwitterHandler",
      "documentation" : "index.html",
      "dependencies":[
        "java.util.ArrayList", ["file:./lib/jbpm-twitter.jar", "file:./lib/twitter4j-core-2.2.2.jar"] ]
     }
  ]
]
----
====

[id='_interacting_with_service_repository']
=== Retrieving Service Repository Information

Classes provided in the `org.jbpm.process.workitem` package allow you to connect to the service and retrieve service information. For example, to list all the services contained in a repository and declared in `index.conf`, use:

[source,java]
----
Map<String, WorkDefinitionImpl> workitemsFromRepo = WorkItemRepository.getWorkDefinitions("http://docs.jboss.org/jbpm/v7.0/repository/");
----

NOTE: In the following text, Twitter is used as an example service. To interact with a different service, replace `Twitter` with a name declared in the service `.wid` file.

To get more detailed information about a service, use:

[source,java]
----
workitemsFromRepo.get("Twitter").getName();           // "Twitter"
workitemsFromRepo.get("Twitter").getDescription();    // "Send a Twitter message."
workitemsFromRepo.get("Twitter").getDefaultHandler(); // "org.jbpm.process.workitem.twitter.TwitterHandler"
workitemsFromRepo.get("Twitter").getDependencies();   // String["file:./lib/jbpm-twitter.jar","file:./lib/twitter4j-core-2.2.2.jar"]
...
----

To check whether the correct version of a service is contained in the repository:

[source,java]
----
if(workitemsFromRepo.containsKey("Twitter") && workitemsFromRepo.get("Twitter").getVersion().equals("1.0")) {
  // Do something here.
}
----

IMPORTANT: All operations are read-only. It is not possible to update the service repository automatically.


[id='_sect_actor_assignment_calls']
== Actor assignment calls


User Tasks must define either the [parameter]``ActorID`` or the [parameter]``GroupID`` parameter, which define the users who can or should execute the User Tasks.
It is in the Task List of these users the Task appears.

If the User Task element defines exactly one user, the User Task appears only in the Task List of that particular user.
If a User Task is assigned to more than one user, that is, to multiple actors or to a group, it appears in the Task List of all the users and any of the users can claim and execute the User Task.
End users define these properties in the Process Designer.

.Predefined Administrator user
[IMPORTANT]
====
The Administrator can manipulate the life cycle of all Tasks, even if not being their potential owner. By default, a special user with userId `Administrator` is the administrator of each Task. It is therefore recommended to always define at least user Administrator when registering the list of valid users with the User Task service.
====


[id='_sect_ldap_connection']
== LDAP connection


A dedicated [interface]``
					UserGroupCallback
				`` implementation for LDAP servers is provided with the product to allow the User Task service to retrieve information on users, and groups and roles directly from an LDAP service.

The LDAP UserGroupCallback implementation takes the following properties:

* [property]``ldap.bind.user``: username used to connect to the LDAP server (optional if LDAP server accepts anonymous access)
* [property]``ldap.bind.pwd``: password used to connect to the LDAP server (optional if LDAP server accepts anonymous access)
* [property]``ldap.user.ctx``: context in LDAP with user information (mandatory)
* [property]``ldap.role.ctx``: context in LDAP with group and role information (mandatory)
* [property]``ldap.user.roles.ctx``: context in LDAP with user group and role membership information (optional; if not specified, ldap.role.ctx is used)
* [property]``ldap.user.filter``: filter used to search for user information; usually contains substitution keys {0}, which are replaced with parameters (mandatory)
* [property]``ldap.role.filter``: filter used to search for group and role information, usually contains substitution keys {0}, which are replaced with parameters (mandatory)
* [property]``ldap.user.roles.filter``: filter used to search for user group and role membership information, usually contains substitution keys {0}, which are replaced with parameters (mandatory)
* [property]``ldap.user.attr.id``: attribute name of the user ID in LDAP (optional; if not specified, `uid` is used)
* [property]``ldap.roles.attr.id``: attribute name of the group and role ID in LDAP (optional; if not specified `cn` is used)
* [property]``ldap.user.id.dn``: user ID in a DN, instructs the callback to query for user DN before searching for roles (optional, by default ``false``)
* [property]``java.naming.factory.initial``: initial context factory class name (by default ``com.sun.jndi.ldap.LdapCtxFactory``)
* [property]``java.naming.security.authentication``: authentication type (possible values are ``none``, ``simple``, ``strong``; by default ``simple``)
* [property]``java.naming.security.protocol``: security protocol to be used; for instance `ssl`
* [property]``java.naming.provider.url``: LDAP url (by default ``ldap://localhost:389``; if the protocol is set to `ssl` then ``ldap://localhost:636``)


[id='_connecting_to_ldap']
=== Connecting to LDAP


To be able to use the LDAP UserGroupCallback implementation configure the respective LDAP properties (see <<_sect_ldap_connection>>) in one of the following ways:

* _programatically_: build a [class]``Properties`` object with the respective LDAPUserGroupCallbackImpl properties and create [class]``LDAPUserGroupCallbackImpl`` with the [class]``Properties`` object as its parameter.
+

====
[source,java]
----
import org.kie.api.PropertiesConfiguration;
import org.kie.api.task.UserGroupCallback;
...
Properties properties = new Properties();
properties.setProperty(LDAPUserGroupCallbackImpl.USER_CTX, "ou=People,dc=my-domain,dc=com");
properties.setProperty(LDAPUserGroupCallbackImpl.ROLE_CTX, "ou=Roles,dc=my-domain,dc=com");
properties.setProperty(LDAPUserGroupCallbackImpl.USER_ROLES_CTX, "ou=Roles,dc=my-domain,dc=com");
properties.setProperty(LDAPUserGroupCallbackImpl.USER_FILTER, "(uid={0})");
properties.setProperty(LDAPUserGroupCallbackImpl.ROLE_FILTER, "(cn={0})");
properties.setProperty(LDAPUserGroupCallbackImpl.USER_ROLES_FILTER, "(member={0})");

UserGroupCallback ldapUserGroupCallback = new LDAPUserGroupCallbackImpl(properties);

UserGroupCallbackManager.getInstance().setCallback(ldapUserGroupCallback);
----
====
* _declaratively_: create the `jbpm.usergroup.callback.properties` file in the root of your application or specify the file location as a system property: `-Djbpm.usergroup.callback.properties=FILE_LOCATION_ON_CLASSPATH`
+
Make sure to register the LDAP callback when starting the User Task server.
+

[source,java]
----
#ldap.bind.user=
#ldap.bind.pwd=
ldap.user.ctx=ou\=People,dc\=my-domain,dc\=com
ldap.role.ctx=ou\=Roles,dc\=my-domain,dc\=com
ldap.user.roles.ctx=ou\=Roles,dc\=my-domain,dc\=com
ldap.user.filter=(uid\={0})
ldap.role.filter=(cn\={0})
ldap.user.roles.filter=(member\={0})
#ldap.user.attr.id=
#ldap.roles.attr.id=
----


[id='_exception_management']
== Exception Management


When an unexpected event, that deviates from the normative behavior, occurs in a process instance, it is referred to as an exception.
There are two types of exceptions: business exceptions and technical exceptions.

[float]
=== Business exceptions


Business exceptions relate to the possible incorrect scenarios of the particular process, for example, trying to debit an empty bank account.
Handling of such exceptions is designed directly in the process model using BPMN process elements.

When modeling business exception management, the following mechanisms are to be used:

Errors::
An Error is a signal that an unexpected situation occurred (see <<_errors>>). The mechanism can be used immediately when the problem arises and does not allow for any compensation. Note that the Error Start Event is only available for an event sub-process.

Compensation::
Compensation is equivalent to the Error mechanism; however, it can be used only on sub-processes when it is required that the execution flow continues after the compensation using the "regular" outgoing Flow (execution continues after the compensation as if no compensation occurred).



[float]
=== Technical exceptions


Technical components used in a process fail in a way that cannot be described using BPMN (for further information, see _{DEVELOPMENT_GUIDE}_). For other technical issues, such as failure to connect to an external system, should be escalated to the system administrator.
