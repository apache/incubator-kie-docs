[NOTE]
====
For {PRODUCT_PAM}, the server is called _{KIE_SERVER_BA}_. For {PRODUCT_DM}, the server is called _{KIE_SERVER_DM}_. In the following text, only {KIE_SERVER_BA} is used.
====

The {KIE_SERVER} is a standalone component that can be used to instantiate and execute rules and processes. The {KIE_SERVER_BA} and the {KIE_SERVER_DM} are created as a WAR file that can be deployed on any web container.

This server has a low footprint with minimal memory consumption; therefore, it can be deployed easily on a cloud instance.
Each instance of this server can open and instantiate multiple KIE containers, which allows you to execute multiple rules and processes in parallel.

[NOTE]
====
Red Hat JBoss BPM Suite supports two execution servers for processes: {KIE_SERVER} (kie-server) and Business Central (business-central), and has Remote APIs for both. The process engine in Business Central and its Remote API are supported for Red Hat JBoss BPMS 6.x releases only. However, the {KIE_SERVER} is being enhanced over releases. Hence, {KIE_SERVER} is recommended to instantiate and execute your processes.
====

This chapter describes the {KIE_SERVER} APIs and extensions.

[id='_extensions']
= {KIE_SERVER} Extensions

{KIE_SERVER_BA} and {KIE_SERVER_DM} contain extensions that enable certain execution capabilities.

The default {KIE_SERVER_BA} includes the following components.

* {PRODUCT_PAM}
* {PRODUCT_DM}
* {PLANNER}

The default {KIE_SERVER_DM} includes the following components.

* {PRODUCT_DM}
* {PLANNER}

For further information about the planner capabilities of the {KIE_SERVER_BA} and {KIE_SERVER_DM}, see the {URL_PLANNER_GUIDE}[{PLANNER}] guide.

Each of the product components consists of one or more execution server extensions that provide greater control over your execution environment. You can disable or enable certain extensions. For more information about setting extensions, see the {URL_ADMIN_GUIDE}#bootstrap_switches[Bootstrap Switches] chapter of the _{ADMIN_GUIDE}_.

Below is the list of extensions:

Common Extensions::
+
--
KieServer::
Provides the core capability of the execution server, such as to deploy and undeploy containers on your server instance. It is always present.
--

{PRODUCT_PAM} Extensions::
+
--
BPM::
Provides process, task, and job execution capability.

BPM-UI::
Provides the UI extension capability. See <<_intelligent_process_server_ui_extension>> for further information.

CaseMgmt::
Provides the case management capability.

BPMQueries::
Provides the capability to perform complex search and filtering queries for tasks and processes.
--

{PRODUCT_DM} Extensions::
+
--
BRM::
Provides the rule execution capability.

DMN::
Provides the Decision Model and Notation support.
--

{PLANNER} Extensions::
+
--
BRP::
Provides the {PLANNER} capability.
--

== Extending {KIE_SERVER} Extensions

{PRODUCT} enables you to extend the REST and JMS API functionality of each extension. You can extend the following extensions:

* `KieServer` - equivalent to the `KieServer` capability.
* `Drools` - equivalent to the `BRM` capability.
* `jBPM` - equivalent to the `BPM` capability.
* `jBPM-UI` - equivalent to the `BPM-UI` capability.
* `jBPMSearch` - equivalent to the `BPMQueries` capability.
* `Case-Mgmt` - equivalent to the `CaseMgmt` capability.
* `OptaPlanner` - equivalent to the `BRP` capability.
* `DMN` - equivalent to the `DMN` capability.

To extend {A_KIE_SERVER} extension, implement the following steps:

. Implement the `org.kie.server.services.api.KieServerApplicationComponentsService` interface.
. Implement the custom resource logic.
. Make your custom extension discoverable.

[float]
== Hello World {KIE_SERVER} Extension

See the following steps to implement a hello world example custom {KIE_SERVER} extension:

. Create an empty Maven project with the following dependencies.
+
[source,xml]
----
<properties>
  <version.org.kie>7.1.0.Final</version.org.kie>
</properties>
<dependencies>
  <dependency>
    <groupId>org.kie.server</groupId>
    <artifactId>kie-server-rest-common</artifactId>
    <version>${version.org.kie}</version>
  </dependency>

  <!-- Replace with logger of your choice -->
  <dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.2</version>
  </dependency>
</dependencies>
----

. Implement the `KieServerApplicationComponentsService` interface.
+
[source,java]
----
package brq.redhat.documentation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;

import org.kie.server.services.api.KieServerApplicationComponentsService;
import org.kie.server.services.api.SupportedTransports;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


public class CustomKieServerApplicationComponentsService implements KieServerApplicationComponentsService {

    private static final String OWNER_EXTENSION = "Drools";
    private static final Logger logger = LoggerFactory.getLogger(CustomKieServerApplicationComponentsService.class);


    public Collection<Object> getAppComponents(String extension, SupportedTransports type, Object... services) {
        // Skip calls from extensions other than the one you want to extend
        if ( !OWNER_EXTENSION.equals(extension) ) {
            return Collections.emptyList();
        }

        List<Object> components = new ArrayList<Object>(1);
        if( SupportedTransports.REST.equals(type) ) {
            components.add(new CustomResource());
            logger.warn("Extended the {} extension",extension);
        }
        return components;
    }
}
----
+
Note that each extension enabled on your {KIE_SERVER} instance calls the `getAppComponents` method. That is why the `if(!OWNER_EXTENSION.equals(extension))` call checks for equality on the component name, and returns an empty collection for extensions that you do not want to extend.

. Implement the resource class, which is the `CustomResource` class. In this example, it is a dummy implementation that contains one `GET` endpoint and returns a simple message.
+
[source,java]
----
package brq.redhat.documentation;

import static org.kie.server.remote.rest.common.util.RestUtils.createResponse;
import static org.kie.server.remote.rest.common.util.RestUtils.getVariant;

import javax.ws.rs.GET;
import javax.ws.rs.Path;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.Variant;

@Path("server/helloworld")
public class CustomResource {

    @GET()
    @Produces(MediaType.APPLICATION_XML)
    public Response testMe(@Context HttpHeaders headers) {
    	String result = new String("<message>Hello from a Custom Resource</message>");
    	Variant v = getVariant(headers);
    	return createResponse(result, v, Response.Status.OK);
    }
}
----

. Make the `CustomKieServerApplicationComponentsService` class discoverable by the {KIE_SERVER}. To do so, create the `META-INF/services/org.kie.server.services.api.KieServerApplicationComponentsService` file with the fully qualified class name of the  `KieServerApplicationComponentsService` implementation class. For example:
+
[source]
----
brq.redhat.documentation.CustomKieServerApplicationComponentsService
----

. Package the class into the `JAR` format, and copy the resulting `JAR` file into the `kie-server.war/WEB-INF/lib` directory. For example, on {EAP}, the path is `_EAP_HOME_/standalone/deployments/kie-server.war/WEB-INF/lib`.

When you start the {KIE_SERVER}, the `server/helloworld` endpoint becomes available, for example `http://localhost:8080/kie-server/services/rest/server/helloworld`.

[id='_realtime_decision_server']
= The REST API for {KIE_SERVER} Execution

You can communicate with the {KIE_SERVER} through the REST API.

* The base URL for sending requests is the endpoint defined earlier, for example `http://_SERVER:PORT_/kie-execution-server/services/rest/server/`.
* All requests require basic HTTP Authentication or token-based authentication for the role [property]``kie-server``.

Following methods support three formats of the requests: JSON, JAXB, and XSTREAM.
You must provide following HTTP headers:

* `Accept`: set to `application/json` or `application/xml`.
+
When specifying more than one accepted content type in the Accept header, be sure to include the qualifiers of preference (qvalues as defined in the https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html[HTML 1.1 standard]).
If you do not, unexpected behaviour may occur. This is an example of a well-formed header with multiple accepted content types:
+
[source]
----
Accept: application/xml; q=0.5, application/json; q=0.9
----

* `X-KIE-ContentType` is required when using the XSTREAM marshaller. In such case, set the header to `XSTREAM`. Values `JSON` and `JAXB` are allowed, but not required. When you set the `Content-type` to `application/xml`, the `JAXB` value is used by default.
* `Content-type`: set to `application/json` or `application/xml`. This header corresponds with the format of your payload.
* `--data`: your payload. If the payload is in a file, start the name with an ampersand `@`. For example:
+
[source]
----
--data @commandsRequest.json
----


To ensure both the request and the response are in the same format, always specify both the `Content-Type` and `Accept` HTTP headers in your application's requests.
Otherwise, you can receive a marshalling-related error from the server.

The examples use the Curl utility. You can use any REST client. Curl commands use the following parameters:

* ``-u``: specifies username:password for the {KIE_SERVER} authentication.
* ``-H``: specifies HTTP headers.
* ``-X``: specifies the HTTP method of the request, that is [GET], [POST], [PUT], or [DELETE].


[NOTE]
====
<<_brms_commands,BRMS Commands endpoints>> will work only if your {KIE_SERVER} has BRM capability.
The rest of the endpoints will work only if your {KIE_SERVER} has BPM capabilities.
Check the following URI for capabilities of your {KIE_SERVER} : __http://_SERVER:PORT_/kie-execution-server/services/rest/server__.
====

[id='_brms_commands']
== BRMS Commands

[POST] /containers/instances/_CONTAINER_ID_::
+
--
Request Type::
A single `org.kie.api.command.Command` command or multiples commands in `BatchExecutionCommand` wrapper.

Response Type::
`org.kie.server.api.model.ServiceResponse<String>`

Description::
Executes the commands sent to the specified `_CONTAINER_ID_` and returns the commands execution results. For more information, See the supported commands below.
--

List of supported commands:

* `AgendaGroupSetFocusCommand`
* `ClearActivationGroupCommand`
* `ClearAgendaCommand`
* `ClearAgendaGroupCommand`
* `ClearRuleFlowGroupCommand`
* `DeleteCommand`
* `InsertObjectCommand`
* `ModifyCommand`
* `GetObjectCommand`
* `InsertElementsCommand`
* `FireAllRulesCommand`
* `QueryCommand`
* `SetGlobalCommand`
* `GetGlobalCommand`
* `GetObjectsCommand`
* `BatchExecutionCommand`
* `DisposeCommand`

For more information about the commands, see the `org.drools.core.command.runtime` package.
Alternatively, see {URL_DEVELOPMENT_GUIDE}#sect_supported_jboss_brms_commands[Supported Red Hat JBoss BRMS Commands] from the {DEVELOPMENT_GUIDE}.

.[POST] Drools Commands Execution
====
. Change into a directory of your choice and create `commandsRequest.json` :
+
[source,javascript]
----
{
      "lookup" : null,
      "commands" : [ {
        "insert" : {
          "object" : "testing",
          "disconnected" : false,
          "out-identifier" : null,
          "return-object" : true,
          "entry-point" : "DEFAULT"
        }

      }, {
        "fire-all-rules" : { }
      } ]
    }
----
. Execute the following command:
+
[source]
----
$ curl -X POST -H 'X-KIE-ContentType: JSON' -H 'Content-type: application/json' -u 'kieserver:kieserver1!' --data @commandsRequest.json http://localhost:8080/kie-execution-server/services/rest/server/containers/instances/myContainer
----
+
The command generates a request that sends the Insert Object and Fire All Rules commands to the server. `Lookup` specifies a ksession configured in your kjar.
If you use a null lookup value, the default KIE session will be used.

An example response:
[source,javascript]
----
    {
      "type" : "SUCCESS",
      "msg" : "Container hello successfully called.",
      "result" : "{\n  \"results\" : [ ],\n  \"facts\" : [ ]\n}"
    }
----
====
ifdef::PAM[]

[id='_managing_processes']
== Managing Processes


Use the following entry point: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/containers/_CONTAINER_ID_/processes`. See the list of endpoints:

[DELETE] /instances::
+
--
Description::
 Aborts multiple process instances specified by the query parameter `instanceId`.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/signals::
+
--
Response Type::
A list of Strings.

Description::
Returns all the available signal names for `_PROCESS_INSTANCE_ID_` as a list of Strings.
--

[PUT] /instances/_PROCESS_INSTANCE_ID_/variable/_VARIABLE_NAME_::
+
--
Request Type::
The variable marshalled value.

Description::
Sets the value of the `_VARIABLE_NAME_` variable for the `_PROCESS_INSTANCE_ID_` process instance. If successful, the return value is HTTP code 201.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/variable/_VARIABLE_NAME_::
+
--
Response Type::
The variable value.

Description::
Returns the marshalled value of the `_VARIABLE_NAME_` variable for the `_PROCESS_INSTANCE_ID_` process instance.
--

[POST] /instances/_PROCESS_INSTANCE_ID_/variables::
+
--
Request Type::
A map with variable names and values.

Description::
Sets multiple variables that belong to a `_PROCESS_INSTANCE_ID_` process instance. The request is a map, in which the key is the name of the variable and the value is the new value of the variable.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/variables::
+
--
Response Type::
A map with the variable names and values.

Description::
Gets all variables for the `_PROCESS_INSTANCE_ID_` process instance as a map, in which the key is the name of the variable and the value is the value of the variable.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/processes::
+
--
Description::
Returns a list of process instances for which the specified process instance is a parent process instance.
+
Additional parameters you can use: `status`, `sort`, `sortOrder`.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/workitems::
+
--
Response Type::
A list of https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/WorkItemInstance.java[WorkItemInstance] objects.

Description::
Gets all the work items of the given `_PROCESS_INSTANCE_ID_` process instance.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/workitems/_WORK_ITEM_ID_::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/WorkItemInstance.java[WorkItemInstance] object.

Description::
Gets the `_WORK_ITEM_ID_` work item of the given `_PROCESS_INSTANCE_ID_` process instance.
--

[PUT] /instances/_PROCESS_INSTANCE_ID_/workitems/_WORK_ITEM_ID_/aborted::
+
--
Description::
Aborts the `_WORK_ITEM_ID_` work item of the given `_PROCESS_INSTANCE_ID_` process instance. If successful, the return value is HTTP code 201.
--

[PUT]  /instances/_PROCESS_INSTANCE_ID_/workitems/_WORK_ITEM_ID_/completed::
+
--
Description::
Completes the `_WORK_ITEM_ID_` work item of the given `_PROCESS_INSTANCE_ID_` process instance. If successful, the return value is HTTP code 201.
--

[POST] /_PROCESS_ID_/instances::
+
--
Request Type::
A map with variables used to start the process.

Response Type::
Plain text with the process instance id.

Description::
Creates a `_PROCESS_ID_` business process instance. Accepted input is a map with the process variables and its values.
--

[POST] /instances/signal/_SIGNAL_NAME_::
+
--
Request Type::
A marshalled object.

Description::
Signals multiple process instances of a query parameter `instanceId` with the `_SIGNAL_NAME_` signal. You can provide the signal payload marshalled in the request body.
--

[DELETE] /instances/_PROCESS_INSTANCE_ID_::
+
--
Description::
Aborts the `_PROCESS_INSTANCE_ID_` process instance. If successful, the return value is HTTP code 204.
--

[GET] /instances/_PROCESS_INSTANCE_ID_::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/ProcessInstance.java[process instance] object.

Description::
Returns the details of the `_PROCESS_INSTANCE_ID_` process instance. To request variable information, set the `withVars` query parameter to `true`.
--

[GET] /instances::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/ProcessInstanceList.java[process instance list] object.

Description::
Returns the details of active process instances.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/nodes/instances::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/NodeInstanceList.java[node instance list] object.

Description::
Returns node instances for the specified process instance.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/variables/instances::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/VariableInstanceList.java[variable instance list] object.

Description::
Returns the current variable values of the specified process instance.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/variables/instances/_VARIABLE_ID_::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/VariableInstance.java[variable instance list] object.

Description::
Returns the value of the variable in the specified process instance.
--

[POST] /instances/_PROCESS_INSTANCE_ID_/signal/_SIGNAL_NAME_::
+
--
Request Type::
A marshalled object.

Description::
Signals the `_PROCESS_INSTANCE_ID_` process instance with `_SIGNAL_NAME_` signal. You can provide the signal payload marshalled in the request body.
--

[POST] /_PROCESS_ID_/instances/correlation/_CORRELATION_KEY_::
+
--
Request Type::
A map with variables used to start the process.

Response Type::
 Plain text with the process instance id.

Description::
Creates the `_PROCESS_ID_` business process instance with the `_CORRELATION_KEY_` correlation key. Accepted input is a map with the process variables and its values.
--


.Managing Processes
====
* Create `person.json`:
+
[source,javascript]
----
{
  "p" : { "org.kieserver.test.Person": { "id" : 13, "name": "William" } }
}
----
+
Start a process using a custom object (Person) as a parameter:
+
[source]
----
$ curl -X POST  -u 'kieserver:kieserver1!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data @person.json 'http://localhost:8080/kie-execution-server/services/rest/server/containers/person/processes/proc-with-pojo.p-proc/instances'
----
* Create a new process instance of process definition `com.sample.rewards-basic` with parameters:
+
[source]
----
$ curl -X POST  -u 'kieserver:kieserver1!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data '{"employeeName": "William"}' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/rewards/processes/com.sample.rewards-basic/instances'
----
+
Returns process instance ID.
* Get the variables of process instance `3`
+
[source]
----
$ curl -u 'kieserver:kieserver1!' -H 'Accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/rewards/processes/instances/3/variables'
----
+
Example response:
+
[source,javascript]
----
{
  "employeeName" : "William"
}
----
* Send a TEST signal to the process instance with ID `5`
+
[source]
----
$ curl -X POST  -u 'kieserver:kieserver1!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data '"SIGNAL DATA"' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/test/processes/instances/signal/TEST?instanceId=5'
----

====
endif::PAM[]

[id='_process_queries']
== Managing Process Definitions

Use this base URI: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/containers/_CONTAINER_ID_/processes/definitions`. To use pagination, use the `page` and `pageSize` query parameters. See the list of endpoints:

[GET] /_PROCESS_ID_/variables::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/VariablesDefinition.java[VariablesDefinition] object.


Description::
Returns a map of the variable definitions for the `_PROCESS_ID_` process. The map contains the variable name and its type.
--


[GET] /_PROCESS_ID_/tasks/service::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/ServiceTasksDefinition.java[ServiceTaskDefinition] object.

Description::
Returns all service tasks for the `_PROCESS_ID_` process. The return value is a map with the names and types of the service tasks. If no tasks are found, the return value is an empty list.
--

[GET] /_PROCESS_ID_/tasks/users::
+
--
Response Type::
A list of https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/UserTaskDefinition.java[UserTaskDefinition] objects.

Description::
Returns all the user tasks for the `_PROCESS_ID_` process. The response also contains maps of the input and output parameters. The key is the name and the value is the type of a parameter.
--

[GET] /_PROCESS_ID_/subprocesses::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/SubProcessesDefinition.java[SubProcessDefinition] object.

Description::
Returns a list of reusable sub-process IDs for the `_PROCESS_ID_` process.
--

[GET] /_PROCESS_ID_/entities::
+
--
Response Type::
An https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/AssociatedEntitiesDefinition.java[AssociatedEntitiesDefinition] object.

Description::
Returns a map with the entities associated with the `_PROCESS_ID_` process.
--

[GET] /_PROCESS_ID_/tasks/users/_TASK_NAME_/inputs::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/TaskInputsDefinition.java[TaskInputsDefinition] object.

Description::
Returns a map with all the task input parameter definitions for the _TASK_NAME_ task of the _PROCESS_ID_ process. The key is the name of the input and the value is its type.
--

[GET] /_PROCESS_ID_/tasks/users/_TASK_NAME_/outputs::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/definition/TaskOutputsDefinition.java[TaskOutputsDefinition] object.

Description::
Returns a map with all the task output parameter definitions for the _TASK_NAME_ task of the _PROCESS_ID_ process. The key is the name of the input and the value is its type.
--



.[GET] User Tasks for a Specified Process
====
The following command displays user tasks for the the `com.sample.rewards-basic` process in the `rewards` container:
[source]
----
$ curl -u 'kieserver:kieserver1!' -H 'accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/rewards/processes/definitions/com.sample.rewards-basic/tasks/users'
----

An example response:
[source,javascript]
----
{
  "task" : [ {
    "task-name" : "Approval by PM",
    "task-priority" : 0,
    "task-skippable" : false,
    "associated-entities" : [ "PM" ],
    "task-inputs" : {
      "Skippable" : "Object",
      "TaskName" : "java.lang.String",
      "GroupId" : "Object"
    },
    "task-outputs" : {
      "_approval" : "Boolean"
    }
  }, {
    "task-name" : "Approval by HR",
    "task-priority" : 0,
    "task-skippable" : false,
    "associated-entities" : [ "HR" ],
    "task-inputs" : {
      "Skippable" : "Object",
      "TaskName" : "java.lang.String",
      "GroupId" : "Object"
    },
    "task-outputs" : {
      "_approval" : "Boolean"
    }
  } ]
}
----
====

.[GET] Variable Definitions for Specified Process
====
The following command displays the variable definitions of the `com.sample.rewards-basic` process in the `rewards` container:
[source]
----
$ curl -u 'kieserver:kieserver1!' -H 'accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/rewards/processes/definitions/com.sample.rewards-basic/variables'
----

An example response:
[source,javascript]
----
{
  "variables" : {
    "result" : "String",
    "hrApproval" : "Boolean",
    "pmApproval" : "Boolean",
    "employeeName" : "String"
  }
}
----
====

[id='_user_tasks']
== Managing User Tasks


=== Managing Task Instances

Use this base URI: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/containers/_CONTAINER_ID_/tasks/_TASK_ID_/states`. See the list of endpoints:

[PUT] /activated::
+
--
Description::
Activates the `_TASK_ID_` task.
--

[PUT] /claimed::
+
--
Description::
Claims the `_TASK_ID_` task.
--

[PUT] /started::
+
--
Description::
Starts the `_TASK_ID_` task.
--

[PUT] /stopped::
+
--
Description::
Stops the `_TASK_ID_` task.
--

[PUT] /completed::
+
--
Request Type::
A map with the output parameters name and value.

Description::
Completes the `_TASK_ID_` task. You can provide the output parameters as a map, where the key is the parameter name and the value is the value of the output parameter. You can also use the `auto-progress` parameter. If set to true, it will claim, start, and complete a task at once.
--

[PUT] /delegated::
+
--
Description::
Delegates the `_TASK_ID_` task to a user provided by the `targetUser` query parameter.
--

[PUT] /exited::
+
--
Description::
Exits the `_TASK_ID_` task.
--

[PUT] /failed::
+
--
Description::
Fails the `_TASK_ID_` task.
--

[PUT] /forwarded::
+
--
Description::
Forwards the `_TASK_ID_` task to the user provided by the `targetUser` query parameter.
--

[PUT] /released::
+
--
Description::
Releases the `_TASK_ID_` task.
--

[PUT] /resumed::
+
--
Description::
Resumes the `_TASK_ID_` task.
--

[PUT] /skipped::
+
--
Description::
Skips the `_TASK_ID_` task.
--

[PUT] /suspended::
+
--
Description::
Suspends the `_TASK_ID_` task.
--

[PUT] /nominated::
+
--
Description::
Nominates the `_TASK_ID_` task to the potential owners by the `potOwner` query parameter. You can use the parameter multiple times, for example: `potOwner=usr1&potOwner=usr2`.
--


.Task Instances
====
* Start task with `taskId` 4 in the container `test`:
+
[source]
----
$ curl -X PUT -u 'kieserver:kieserver1!' http://localhost:8080/kie-execution-server/services/rest/server/containers/test/tasks/4/states/started
----
* Complete the task 1 by passing an output parameter:
+
[source]
----
$ curl -X PUT -u 'kieserver:kieserver1!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data '{ "_approval" : true }' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/test/tasks/1/states/completed'
----

====

Some operations are illegal, such as starting a completed task, or disallowed for security reasons, such as claiming a task for another user. Having different sets of users for authentication and task management can be a security concern. Making such requests will result in one of the following exceptions:
[source]
----
Unexpected error during processing User '[UserImpl:'{USER ID}']' does not have permissions to execute operation OPERATION on task id {$TASK_ID}
----

[source]
----
Unexpected error during processing: User '[UserImpl:'{USER ID}']' was unable to execute operation OPERATION on task id {$TASK_ID} due to a no 'current status' match
----

Ensure the operation you are executing is allowed for the current task status. You can disable the security settings by using the `org.kie.server.bypass.auth.user` property.

For example, on Red Hat JBoss EAP, open `_EAP_HOME_/standalone/configuration/standalone.xml` and enter the following:

[source,xml]
----
<system-properties>
  ...
  <property name="org.kie.server.bypass.auth.user" value="true"/>
  ...
</system-properties>
----

Alternatively, use `-Dorg.kie.server.bypass.auth.user=true` to set the property. If you use the {KIE_SERVER} Java client API, set the property on your client as well:

[source,java]
----
System.setProperty("org.kie.server.bypass.auth.user", "true");
----

When you turn on the security settings, you can provide a user with sufficient permissions to execute the operation using the query parameter `?user=$USER_NAME`. If you do not use the parameter, the authenticated user will be used to perform the action.


If you disabled the security settings and still experience authentication issues, configure the {KIE_SERVER} callback:

[id='_configuring_usergroupcallback']
.Configuring UserGroupCallback
. Override the default JAAS UserGroupCallback on the server side:
+
[source,xml]
----
<property name="org.jbpm.ht.callback" value="props"/>
<!-- If necessary, override the userinfo configuration as well. -->
<property name="org.jbpm.ht.userinfo" value="props"/>
----
+
See the https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-runtime-manager/src/main/java/org/jbpm/runtime/manager/impl/identity/UserDataServiceProvider.java#L42-L47[source code] for other possible values.
. For the `props` value, specify the location of the `application-roles.properties` file:
+
[source,xml]
----
<property name="jbpm.user.group.mapping" value="file:///EAP_HOME/standalone/configuration/application-roles.properties"/>
<!-- If no other file is specified, the business-central.war/WEB-INF/classes/userinfo.properties file is used.
You can specify a file with the following property:
<property name="jbpm.user.info.properties" value="file:///path" /> -->
----


You can also use a different callback object. The Human Task callback is instantiated by a CDI producer configured in `_EAP_HOME_/standalone/business-central.war/WEB-INF/beans.xml`:

[source,xml]
----
<beans xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://docs.jboss.org/cdi/beans_1_0.xsd">
  <alternatives>
    <class>org.jbpm.services.cdi.producer.JAASUserGroupInfoProducer</class>
  </alternatives>
</beans>
----

{PRODUCT} provides out-of-the-box producer and callback objects you can use. See the source code for a list of additional setting required for each callback implementation:

* DBUserGroupCallback:
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-services/jbpm-services-cdi/src/main/java/org/jbpm/services/cdi/producer/DBUserGroupInfoProducer.java[DBUserGroupInfoProducer]
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-human-task/jbpm-human-task-core/src/main/java/org/jbpm/services/task/identity/DBUserGroupCallbackImpl.java[DBUserGroupCallbackImpl]
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-human-task/jbpm-human-task-core/src/main/java/org/jbpm/services/task/identity/DBUserInfoImpl.java[DBUserInfoImpl]
* LDAPUserGroupCallback:
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-services/jbpm-services-cdi/src/main/java/org/jbpm/services/cdi/producer/LDAPUserGroupInfoProducer.java[LDAPUserGroupInfoProducer]
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-human-task/jbpm-human-task-core/src/main/java/org/jbpm/services/task/identity/LDAPUserGroupCallbackImpl.java[LDAPUserGroupCallbackImpl]
** https://github.com/droolsjbpm/jbpm/blob/6.4.x/jbpm-human-task/jbpm-human-task-core/src/main/java/org/jbpm/services/task/identity/LDAPUserInfoImpl.java[LDAPUserInfoImpl]
* MvelUserGroupCallbackImpl:
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-services/jbpm-services-cdi/src/main/java/org/jbpm/services/cdi/producer/DefaultUserGroupInfoProducer.java[DefaultUserGroupInfoProducer]
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-human-task/jbpm-human-task-core/src/main/java/org/jbpm/services/task/identity/MvelUserGroupCallbackImpl.java[MvelUserGroupCallbackImpl]
** https://github.com/droolsjbpm/jbpm/blob/6.5.x/jbpm-human-task/jbpm-human-task-core/src/main/java/org/jbpm/services/task/identity/DefaultUserInfo.java[DefaultUserInfo]



=== Managing Task Instance Data

Use this base URI: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/containers/_CONTAINER_ID_/tasks/_TASK_ID_`. See the list of endpoints:


[GET] /::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskInstance.java[TaskInstance] object.

Description::
Gets the `_TASK_ID_` task instance details.
--


[PUT] /::
+
--
Request Type::
A map of a  https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskInstance.java[TaskInstance] object in `xml-jaxb`, `xml-xstream`, or `json` format that defines TaskInstance properties and input and output parameters.

Description::
Updates the TaskInstance object and returns HTTP 201 if successful. Provide the TaskInstance properties and input and output parameters to be updated.
--


[POST] /attachments::
+
--
Request Type::
The content of the attachment.

Response Type::

Description::
Adds a new attachment for the `_TASK_ID_` task. The ID of the created content is returned in the response, which is HTTP code 201. The name of the attachment is set using the query parameter `name`. If you make multiples request, you create multiple attachments.
--


[GET] /attachments::
+
--
Response Type::
A list of https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskAttachment.java[TaskAttachment] objects.

Description::
Gets all task attachments for the `_TASK_ID_` task.
--


[GET] /attachments/_ATTACHMENT_ID_::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskAttachment.java[TaskAttachment] object.

Description::
Gets the `_ATTACHMENT_ID_` task attachment.
--

[DELETE] /attachments/_ATTACHMENT_ID_::
+
--
Description::
Removes the `_ATTACHMENT_ID_` task attachment.
--

[GET] /attachments/_ATTACHMENT_ID_/content::
+
--
Response Type::
An attachment-type object.

Description::
Gets the `_ATTACHMENT_ID_` task attachment content.
--

[POST] /comments::
+
--
Request Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskComment.java[TaskComment] object.

Response Type::
Long.

Description::
Adds a new comment for the `_TASK_ID_` task. The ID of the created content is returned in the response, which HTTP code is 201. If you make multiples request, you create multiple comments.
--

[GET] /comments::
+
--
Response Type::
A list of https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskComment.java[TaskComment] objects.

Description::
Gets all task comments for the `_TASK_ID_` task.
--

[GET] /comments/_COMMENT_ID_::
+
--
Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskComment.java[TaskComment] object.

Description::
Gets the `_COMMENT_ID_` task comment of the `_TASK_ID_` task.
--

[DELETE] /comments/_COMMENT_ID_::
+
--
Description::
Deletes the `_COMMENT_ID_` task comment of the `_TASK_ID_` task.
--

[GET] /contents/input::
+
--
Response Type::
A map with the input parameters name and value.

Description::
Gets the `_TASK_ID_` task input content in form of a map, where the key is the parameter name and the value is the value of the output parameter.
--

[PUT] /contents/output::
+
--
Request Type::
A map with the output parameters name and value.

Description::
Updates the `_TASK_ID_` task output parameters and returns HTTP 201 if successful. Provide the output parameters as a map, where the key is the parameter name and the value is the value of the output parameter.
--

[GET] /contents/output::
+
--
Response Type::
A map with the output parameters name and value.

Description::
Gets the `_TASK_ID_` task output content in form of a map, where the key is the parameter name and the value is the value of the output parameter.
--

[DELETE] /contents/_CONTENT_ID_::
+
--
Description::
Deletes the `_CONTENT_ID_` content and returns HTTP code 204.
--

[PUT] /description::
+
--
Request Type::
Marshalled String value.

Description::
Updates the `_TASK_ID_` task description and returns HTTP code 201 if successful. Provide the new value for description in the request body.
--

[PUT] /expiration::
+
--
Request Type::
Marshalled Date value.

Description::
Updates the `_TASK_ID_` task expiration date and returns HTTP 201 if successful. Provide the new value for the expiration date in the request body.
--

[PUT] /name::
+
--
Request Type::
Marshalled String value.

Description::
Updates the `_TASK_ID_` task name and returns HTTP code 201 if successful. Provide the new value for name in the request body.
--

[PUT] /priority::
+
--
Request Type::
Marshalled int value.

Description::
Updates the `_TASK_ID_` task priority and returns HTTP code 201 if successful. Provide the new value for priority in the request body.
--

[PUT] /skipable::
+
--
Request Type::
Marshalled Boolean value.

Description::
Updates the `_TASK_ID_` task property `skipable` and returns HTTP code 201 if successful. Provide the new value for priority in the request body.
--

[GET] /events::
+
--
Description::
Returns a list of task events in the form of a https://github.com/kiegroup/droolsjbpm-integration/blob/6.5.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/TaskEventInstanceList.java[task event instance list] object.
--

.User Task Instance Data
====
* Get a user task instance for container ``test``:
+
[source]
----
$ curl -X GET -u 'kieserver:kieserver1!' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/test/tasks/1'
----
+
Example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-instance>
    <task-id>1</task-id>
    <task-priority>0</task-priority>
    <task-name>Approval by PM</task-name>
    <task-subject></task-subject>
    <task-description></task-description>
    <task-form>ApprovalbyPM</task-form>
    <task-status>Ready</task-status>
    <task-actual-owner></task-actual-owner>
    <task-created-by></task-created-by>
    <task-created-on>2016-02-15T13:31:10.624-02:00</task-created-on>
    <task-activation-time>2016-02-15T13:31:10.624-02:00</task-activation-time>
    <task-skippable>false</task-skippable>
    <task-workitem-id>1</task-workitem-id>
    <task-process-instance-id>1</task-process-instance-id>
    <task-parent-id>-1</task-parent-id>
    <task-process-id>com.sample.rewards-basic</task-process-id>
    <task-container-id>rewards</task-container-id>
</task-instance>
----
* Set priority to 3 for task 1:
+
[source]
----
$ curl -X PUT -u 'kieserver:kieserver1!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data '3' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/test/tasks/1/priority'
----
* Add a comment to a task 2:
+
[source]
----
$ curl -X POST -u 'kieserver:kieserver1!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data '{ "comment" : "One last comment", "comment-added-by": "kieserver"}' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/test/tasks/2/comments'
----
* Get all task comments:
+
[source]
----
$ curl -u 'kieserver:kieserver1!' -H 'Accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/containers/test/tasks/2/comments'
----
+
Example response:
+
[source,javascript]
----
{
  "task-comment" : [ {
    "comment-id" : 1,
    "comment" : "Some task comment",
    "comment-added-by" : "kieserver"
  }, {
    "comment-id" : 3,
    "comment" : "One last comment",
    "comment-added-by" : "kieserver"
  } ]
}
----

====

== Querying Process Instances

Use this base URI: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/queries/`.
To use pagination, use the `page` and `pageSize` parameters. See the list of endpoints:

[GET] processes/instances::
Returns a list of process instances.
+
Additional parameters you can use: ``status``, ``initiator``, ``processName``.
+
.Server Response
[source,xml]
----
<process-instance-list>
 <process-instance>
  <process-instance-id>4</process-instance-id>
  <process-id>evaluation</process-id>
  <process-name>Evaluation</process-name>
  <process-version>1</process-version>
  <process-instance-state>1</process-instance-state>
  <container-id>myContainer</container-id>
  <initiator>kiesu</initiator>
  <start-date>2016-04-05T09:23:29.428+02:00</start-date>
  <process-instance-desc>Evaluation</process-instance-desc>
  <correlation-key/>
  <parent-instance-id>-1</parent-instance-id>
 </process-instance>
 <process-instance>
 <process-instance-id>5</process-instance-id>
  <process-id>evaluation</process-id>
  <process-name>Evaluation</process-name>
  <process-version>1</process-version>
  <process-instance-state>1</process-instance-state>
  <container-id>myContainer</container-id>
  <initiator>kiesu</initiator>
  <start-date>2016-04-05T09:40:39.772+02:00</start-date>
  <process-instance-desc>Evaluation</process-instance-desc>
  <correlation-key/>
  <parent-instance-id>-1</parent-instance-id>
 </process-instance>
</process-instance-list>
----

[GET] processes/_PROCESS_ID_/instances::
Returns a list of process instances for the specified process.
+
Additional parameters you can use: ``status``, ``initiator``.
+
.Server Response
[source,xml]
----
<process-instance-list>
 <process-instance>
 <process-instance-id>4</process-instance-id>
   <process-id>evaluation</process-id>
   <process-name>Evaluation</process-name>
   <process-version>1</process-version>
   <process-instance-state>1</process-instance-state>
   <container-id>myContainer</container-id>
   <initiator>kiesu</initiator>
   <start-date>2016-04-05T09:23:29.428+02:00</start-date>
   <process-instance-desc>Evaluation</process-instance-desc>
   <correlation-key/>
   <parent-instance-id>-1</parent-instance-id>
  </process-instance>
 </process-instance-list>
----

[GET] containers/_CONTAINER_ID_/process/instances::
Returns a list of process instances for the specified container.
+
Additional parameters you can use: ``status``.
+
.Server Response
[source,xml]
----
<process-instance-list>
 <process-instance>
  <process-instance-id>4</process-instance-id>
  <process-id>evaluation</process-id>
  <process-name>Evaluation</process-name>
  <process-version>1</process-version>
  <process-instance-state>1</process-instance-state>
  <container-id>myContainer</container-id>
  <initiator>kiesu</initiator>
  <start-date>2016-04-05T09:23:29.428+02:00</start-date>
  <process-instance-desc>Evaluation</process-instance-desc>
  <correlation-key/>
  <parent-instance-id>-1</parent-instance-id>
 </process-instance>
 <process-instance>
 <process-instance-id>5</process-instance-id>
  <process-id>evaluation</process-id>
  <process-name>Evaluation</process-name>
  <process-version>1</process-version>
  <process-instance-state>1</process-instance-state>
  <container-id>myContainer</container-id>
  <initiator>kiesu</initiator>
  <start-date>2016-04-05T09:40:39.772+02:00</start-date>
  <process-instance-desc>Evaluation</process-instance-desc>
  <correlation-key/>
  <parent-instance-id>-1</parent-instance-id>
 </process-instance>
</process-instance-list>
----

[GET] processes/instance/correlation/_CORRELATION_KEY_::
Returns an instance with the specified correlation key.

[GET] processes/instances/correlation/_CORRELATION_KEY_::
Returns a list of instances with the specified correlation key.

[GET] processes/instances/_PROCESS_INSTANCE_ID_::
Returns information about the specified process instance.
+
Additional parameters you can use: ``withVars``.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<process-instance>
    <process-instance-id>5</process-instance-id>
    <process-id>evaluation</process-id>
    <process-name>Evaluation</process-name>
    <process-version>1</process-version>
    <process-instance-state>1</process-instance-state>
    <container-id>myContainer</container-id>
    <initiator>kiesu</initiator>
    <start-date>2016-04-05T09:40:39.772+02:00</start-date>
    <process-instance-desc>Evaluation</process-instance-desc>
    <correlation-key></correlation-key>
    <parent-instance-id>-1</parent-instance-id>
    <active-user-tasks>
        <task-summary>
            <task-id>5</task-id>
            <task-name>Self Evaluation</task-name>
            <task-description>Please perform a self-evalutation.</task-description>
            <task-priority>0</task-priority>
            <task-actual-owner>Kartik</task-actual-owner>
            <task-created-by>Kartik</task-created-by>
            <task-created-on>2016-04-05T09:40:39.778+02:00</task-created-on>
            <task-activation-time>2016-04-05T09:40:39.778+02:00</task-activation-time>
            <task-proc-inst-id>5</task-proc-inst-id>
            <task-proc-def-id>evaluation</task-proc-def-id>
            <task-container-id>myContainer</task-container-id>
        </task-summary>
    </active-user-tasks>
</process-instance>
----


[GET] processes/instances/variables/_VARIABLE_NAME_::
Returns process instance with the specified variable.
+
Additional parameters you can use: ``status``, ``varValue``.
+
Note that you can use wildcard characters with ``varValue``, for example `varValue=waiting%` to list all the values that start with `waiting`.
+
.Example Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<process-instance-list>
    <process-instance>
        <process-instance-id>4</process-instance-id>
        <process-id>evaluation</process-id>
        <process-name>Evaluation</process-name>
        <process-version>1</process-version>
        <process-instance-state>1</process-instance-state>
        <container-id>myContainer</container-id>
        <initiator>kiesu</initiator>
        <start-date>2016-04-05T09:23:29.428+02:00</start-date>
        <process-instance-desc>Evaluation</process-instance-desc>
        <correlation-key></correlation-key>
        <parent-instance-id>-1</parent-instance-id>
    </process-instance>
    <process-instance>
        <process-instance-id>5</process-instance-id>
        <process-id>evaluation</process-id>
        <process-name>Evaluation</process-name>
        <process-version>1</process-version>
        <process-instance-state>1</process-instance-state>
        <container-id>myContainer</container-id>
        <initiator>kiesu</initiator>
        <start-date>2016-04-05T09:40:39.772+02:00</start-date>
        <process-instance-desc>Evaluation</process-instance-desc>
        <correlation-key></correlation-key>
        <parent-instance-id>-1</parent-instance-id>
    </process-instance>
</process-instance-list>
----

[GET] containers/_CONTAINER_ID_/processes/definitions::
Returns a list of process definitions available for the container.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<process-definitions>
    <processes>
        <process-id>evaluation</process-id>
        <process-name>Evaluation</process-name>
        <process-version>1</process-version>
        <package>Evaluation.src.main.resources</package>
        <container-id>myContainer</container-id>
    </processes>
</process-definitions>
----

[GET] processes/definitions::
Returns list of process definitions.
+
Additional parameters you can use: `filter`.
+
Note that the `filter` parameter filters all the process definitions that contain the given substring.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<process-definitions>
    <processes>
        <process-id>evaluation</process-id>
        <process-name>Evaluation</process-name>
        <process-version>1</process-version>
        <package>Evaluation.src.main.resources</package>
        <container-id>myContainer</container-id>
    </processes>
</process-definitions>
----

[GET] containers/_CONTAINER_ID_/processes/definitions/_PROCESS_ID_::
Returns process definition of the specified process instance in the specified container.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<process-definitions>
    <processes>
        <process-id>evaluation</process-id>
        <process-name>Evaluation</process-name>
        <process-version>1</process-version>
        <package>Evaluation.src.main.resources</package>
        <container-id>myContainer</container-id>
    </processes>
</process-definitions>
----

[GET] processes/definitions/_PROCESS_ID_::
Returns a list of process definitions of the specified process.
+
.Server Response
[source,xml]
----

<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<process-definitions>
    <processes>
        <process-id>evaluation</process-id>
        <process-name>Evaluation</process-name>
        <process-version>1</process-version>
        <package>Evaluation.src.main.resources</package>
        <container-id>myContainer</container-id>
    </processes>
</process-definitions>
----

[GET] processes/instances/_PROCESS_INSTANCE_ID_/nodes/instances::
Returns node instances for the specified process instance.
+
Additional parameters you can use: ``activeOnly``, ``completedOnly``.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<node-instance-list>
    <node-instance>
        <node-instance-id>0</node-instance-id>
        <node-name> </node-name>
        <process-instance-id>5</process-instance-id>
        <container-id>myContainer</container-id>
        <start-date>2016-04-05T09:40:39.797+02:00</start-date>
        <node-id>_ED165B85-E65D-42A6-B0EF-8A160356271E</node-id>
        <node-type>StartNode</node-type>
        <node-connection>_B8F3E49D-2C7A-4056-BF49-C61987044DB4</node-connection>
        <node-completed>true</node-completed>
    </node-instance>
    <node-instance>
        <node-instance-id>1</node-instance-id>
        <node-name>Self Evaluation</node-name>
        <process-instance-id>5</process-instance-id>
        <work-item-id>5</work-item-id>
        <container-id>myContainer</container-id>
        <start-date>2016-04-05T09:40:39.773+02:00</start-date>
        <node-id>_D3E17247-1D94-47D8-93AD-D645E317B736</node-id>
        <node-type>HumanTaskNode</node-type>
        <node-connection>_B8F3E49D-2C7A-4056-BF49-C61987044DB4</node-connection>
        <node-completed>false</node-completed>
    </node-instance>
    <node-instance>
        <node-instance-id>0</node-instance-id>
        <node-name> </node-name>
        <process-instance-id>5</process-instance-id>
        <container-id>myContainer</container-id>
        <start-date>2016-04-05T09:40:39.772+02:00</start-date>
        <node-id>_ED165B85-E65D-42A6-B0EF-8A160356271E</node-id>
        <node-type>StartNode</node-type>
        <node-completed>false</node-completed>
    </node-instance>
</node-instance-list>
----

[GET] processes/instances/_PROCESS_INSTANCE_ID_/wi-nodes/instances/_WORK_ITEM_ID_::
Returns node instances for the specified work item in the specified process instance.

[GET] processes/instances/_PROCESS_INSTANCE_ID_/variables/instances::
Returns current variable values of the specified process instance.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<variable-instance-list>
    <variable-instance>
        <name>employee</name>
        <old-value></old-value>
        <value>Kartik</value>
        <process-instance-id>5</process-instance-id>
        <modification-date>2016-04-05T09:40:39.771+02:00</modification-date>
    </variable-instance>
    <variable-instance>
        <name>reason</name>
        <old-value></old-value>
        <value>Job Opening</value>
        <process-instance-id>5</process-instance-id>
        <modification-date>2016-04-05T09:40:39.771+02:00</modification-date>
    </variable-instance>
</variable-instance-list>
----

[GET] processes/instances/_PROCESS_INSTANCE_ID_/variables/instances/_VARIABLE_NAME_::
Returns the value of the given variable in the specified process instance.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<variable-instance-list>
    <variable-instance>
        <name>employee</name>
        <old-value></old-value>
        <value>Kartik</value>
        <process-instance-id>5</process-instance-id>
        <modification-date>2016-04-05T09:40:39.771+02:00</modification-date>
    </variable-instance>
</variable-instance-list>
----

== Querying Tasks


Use the following entry point: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/queries/`.
To use pagination, use the `page` and `pageSize` parameters. See the list of endpoints:

[GET] tasks/instances/pot-owners::
Returns a list of tasks where the actual user is defined as a potential owner.
+
Additional parameters you can use: ``status``, ``groups``, ``user``. Use the `filter` (regular expression) query parameter to get only the results matching the specified regular expression.
+
Note that the `user` filter is applicable only when the request is sent without authentication.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-summary-list>
    <task-summary>
        <task-id>2</task-id>
        <task-name>Self Evaluation</task-name>
        <task-subject></task-subject>
        <task-description>Please perform a self-evalutation.</task-description>
        <task-status>Ready</task-status>
        <task-priority>0</task-priority>
        <task-is-skipable>false</task-is-skipable>
        <task-created-by>Kartik</task-created-by>
        <task-created-on>2016-04-05T15:09:14.206+02:00</task-created-on>
        <task-activation-time>2016-04-05T15:09:14.206+02:00</task-activation-time>
        <task-proc-inst-id>2</task-proc-inst-id>
        <task-proc-def-id>evaluation</task-proc-def-id>
        <task-container-id>myContainer</task-container-id>
        <task-parent-id>-1</task-parent-id>
    </task-summary>
    <task-summary>
        <task-id>1</task-id>
        <task-name>Self Evaluation</task-name>
        <task-subject></task-subject>
        <task-description>Please perform a self-evalutation.</task-description>
        <task-status>InProgress</task-status>
        <task-priority>0</task-priority>
        <task-is-skipable>false</task-is-skipable>
        <task-actual-owner>kiesu</task-actual-owner>
        <task-created-by>Kartik</task-created-by>
        <task-created-on>2016-04-05T15:05:06.508+02:00</task-created-on>
        <task-activation-time>2016-04-05T15:05:06.508+02:00</task-activation-time>
        <task-proc-inst-id>1</task-proc-inst-id>
        <task-proc-def-id>evaluation</task-proc-def-id>
        <task-container-id>myContainer</task-container-id>
        <task-parent-id>-1</task-parent-id>
    </task-summary>
</task-summary-list>
----

[GET] tasks/instances/admins::
Returns a list of tasks assigned to the Business Administrator.
+
Additional parameters you can use: ``status``, ``user``.

[GET] tasks/instances/owners::
Returns a list of tasks that the querying user owns.
+
Additional parameters you can use: ``status``, ``user``.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-summary-list>
    <task-summary>
        <task-id>1</task-id>
        <task-name>Self Evaluation</task-name>
        <task-subject></task-subject>
        <task-description>Please perform a self-evalutation.</task-description>
        <task-status>InProgress</task-status>
        <task-priority>0</task-priority>
        <task-is-skipable>false</task-is-skipable>
        <task-actual-owner>kiesu</task-actual-owner>
        <task-created-by>Kartik</task-created-by>
        <task-created-on>2016-04-05T15:05:06.508+02:00</task-created-on>
        <task-activation-time>2016-04-05T15:05:06.508+02:00</task-activation-time>
        <task-proc-inst-id>1</task-proc-inst-id>
        <task-proc-def-id>evaluation</task-proc-def-id>
        <task-container-id>myContainer</task-container-id>
        <task-parent-id>-1</task-parent-id>
    </task-summary>
</task-summary-list>
----

[GET] tasks/instances::
Returns a list of instances available for the querying user.
+
Additional parameters you can use: ``user``.

[GET] tasks/instances/_TASK_INSTANCE_ID_/events::
Returns a list of events for the specified task instance.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-event-instance-list>
    <task-event-instance>
        <task-event-id>1</task-event-id>
        <task-id>1</task-id>
        <task-event-type>ADDED</task-event-type>
        <task-event-user>evaluation</task-event-user>
        <task-event-date>2016-04-05T15:05:06.655+02:00</task-event-date>
        <task-process-instance-id>1</task-process-instance-id>
        <task-work-item-id>1</task-work-item-id>
    </task-event-instance>
    <task-event-instance>
        <task-event-id>1</task-event-id>
        <task-id>1</task-id>
        <task-event-type>STARTED</task-event-type>
        <task-event-user>kiesu</task-event-user>
        <task-event-date>2016-04-05T15:13:35.062+02:00</task-event-date>
        <task-process-instance-id>1</task-process-instance-id>
        <task-work-item-id>1</task-work-item-id>
    </task-event-instance>
</task-event-instance-list>
----

[GET] tasks/instances/_TASK_INSTANCE_ID_::
Returns information about the specified task instance.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-instance>
    <task-id>1</task-id>
    <task-priority>0</task-priority>
    <task-name>Self Evaluation</task-name>
    <task-description>Please perform a self-evalutation.</task-description>
    <task-status>InProgress</task-status>
    <task-actual-owner>kiesu</task-actual-owner>
    <task-created-by>Kartik</task-created-by>
    <task-created-on>2016-04-05T15:05:06.508+02:00</task-created-on>
    <task-activation-time>2016-04-05T15:05:06.508+02:00</task-activation-time>
    <task-process-instance-id>1</task-process-instance-id>
    <task-process-id>evaluation</task-process-id>
    <task-container-id>myContainer</task-container-id>
</task-instance>
----

[GET] tasks/instances/workitem/_WORK_ITEM_ID_::
Returns a list of task instances that use the specified work item.

[GET] tasks/instances/process/_PROCESS_INSTANCE_ID_::
Returns a list of tasks attached to the specified process instance.
+
Additional parameters you can use: ``status``.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-summary-list>
    <task-summary>
        <task-id>1</task-id>
        <task-name>Self Evaluation</task-name>
        <task-subject></task-subject>
        <task-description>Please perform a self-evalutation.</task-description>
        <task-status>InProgress</task-status>
        <task-priority>0</task-priority>
        <task-is-skipable>false</task-is-skipable>
        <task-actual-owner>kiesu</task-actual-owner>
        <task-created-by>Kartik</task-created-by>
        <task-created-on>2016-04-05T15:05:06.508+02:00</task-created-on>
        <task-activation-time>2016-04-05T15:05:06.508+02:00</task-activation-time>
        <task-proc-inst-id>1</task-proc-inst-id>
        <task-proc-def-id>evaluation</task-proc-def-id>
        <task-container-id>myContainer</task-container-id>
        <task-parent-id>-1</task-parent-id>
    </task-summary>
</task-summary-list>
----

[GET] tasks/instances/variables/_VARIABLE_NAME_::
Returns a list of tasks that use the specified variable.
+
Aditional parameters you can use: ``varValue``, ``status``, ``user``.
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-summary-list>
    <task-summary>
        <task-id>1</task-id>
        <task-name>Self Evaluation</task-name>
        <task-subject>Please perform a self-evalutation.</task-subject>
        <task-description>Please perform a self-evalutation.</task-description>
        <task-status>Ready</task-status>
        <task-priority>0</task-priority>
        <task-is-skipable>false</task-is-skipable>
        <task-created-by>Kartik</task-created-by>
        <task-created-on>2016-04-07T13:40:32.181+02:00</task-created-on>
        <task-activation-time>2016-04-07T13:40:32.181+02:00</task-activation-time>
        <task-proc-inst-id>1</task-proc-inst-id>
        <task-proc-def-id>evaluation</task-proc-def-id>
        <task-container-id>myContainer</task-container-id>
        <task-parent-id>-1</task-parent-id>
    </task-summary>
</task-summary-list>
----

ifdef::PAM[]
[id='_advanced_queries2']
== Advanced Queries for the {KIE_SERVER}

The {KIE_SERVER} supports the following commands through the REST API.
For more information about advanced queries for the {KIE_SERVER}, see <<_advanced_queries>>. For more information about using advanced queries in the Java Client API, see <<_querydefinition>>.

Use this base URI: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/queries/definitions`.

For endpoints that include _MAPPER_ID_, you can use following default mappers:

* `org.jbpm.kie.services.impl.query.mapper.ProcessInstanceQueryMapper`
** registered with name - `ProcessInstances`
* `org.jbpm.kie.services.impl.query.mapper.ProcessInstanceWithVarsQueryMapper`
** registered with name - `ProcessInstancesWithVariables`
* `org.jbpm.kie.services.impl.query.mapper.ProcessInstanceWithCustomVarsQueryMapper`
** registered with name - `ProcessInstancesWithCustomVariables`
* `org.jbpm.kie.services.impl.query.mapper.UserTaskInstanceQueryMapper`
** registered with name - `UserTasks`
* `org.jbpm.kie.services.impl.query.mapper.UserTaskInstanceWithVarsQueryMapper`
** registered with name - `UserTasksWithVariables`
* `org.jbpm.kie.services.impl.query.mapper.UserTaskInstanceWithCustomVarsQueryMapper`
** registered with name - `UserTasksWithCustomVariables`
* `org.jbpm.kie.services.impl.query.mapper.TaskSummaryQueryMapper`
** registered with name - `TaskSummaries`
* `org.jbpm.kie.services.impl.query.mapper.RawListQueryMapper`
** registered with name - `RawList`

See the list of endpoints:

.Advanced Queries Endpoints
[GET] /::
Returns query definitions.

[GET] /_QUERY_NAME_::
Returns information about the specified query.

[POST] /_QUERY_NAME_::
Registers a query definition.
+


.Request Body
[source,json]
----
 {
	  "query-name" : "getAllTaskInstancesWithCustomVariables1",
	  "query-source" : "java:jboss/datasources/ExampleDS",
	  "query-expression" : "select ti.*,  c.country, c.productCode, c.quantity, c.price, c.saleDate from AuditTaskImpl ti     inner join (select mv.map_var_id, mv.taskid from MappedVariable mv) mv       on (mv.taskid = ti.taskId)     inner join ProductSale c       on (c.id = mv.map_var_id)",
	  "query-target" : "CUSTOM"

	}
----

[PUT] /_QUERY_NAME_::
This endpoint updates a query definition.
+


.Request Body
[source,json]
----
 {
	 "query-name" : "getAllTaskInstancesWithCustomVariables1",
	 "query-source" : "java:jboss/datasources/ExampleDS",
	 "query-expression" : "select ti.*,  c.country, c.productCode, c.quantity, c.price, c.saleDate from AuditTaskImpl ti     inner join (select mv.map_var_id, mv.taskid from MappedVariable mv) mv       on (mv.taskid = ti.taskId)     inner join ProductSale c       on (c.id = mv.map_var_id)",
	 "query-target" : "CUSTOM"

	}
----

[DELETE] /_QUERY_NAME_::
This endpoint deletes a query.

[GET] /_QUERY_NAME_/data?mapper=_MAPPER_ID_::
This endpoint queries tasks with no filtering.
You can use either default or custom mappers.

[POST] /_QUERY_NAME_/filtered-data?mapper=_MAPPER_ID_::
This endpoint queries tasks with filters specified in the request body.
+
.Request Body
[source,json]
----
 {
	  "order-by" : "saleDate, country",
	  "order-asc" : false,
	  "query-params" : [ {
	    "cond-column" : "processInstanceId",
	    "cond-operator" : "BETWEEN",
	    "cond-values" : [ 1000, 2000 ]
	  }, {
	    "cond-column" : "price",
	    "cond-operator" : "GREATER_THAN",
	    "cond-values" : [ 800 ]
	  }, {
	    "cond-column" : "saleDate",
	    "cond-operator" : "BETWEEN",
	    "cond-values" : [ {"java.util.Date":1454281200000}, {"java.util.Date":1456786800000} ]
	  }, {
	    "cond-column" : "productCode",
	    "cond-operator" : "IN",
	    "cond-values" : [ "EAP", "WILDFLY" ]
	  } ],
	  "result-column-mapping" : {
	    "PRICE" : "double",
	    "PRODUCTCODE" : "string",
	    "COUNTRY" : "string",
	    "SALEDATE" : "date",
	    "QUANTITY" : "integer"
	  }
	}
----

[POST] /_QUERY_NAME_/filtered-data?mapper=_MAPPER_ID_&builder=_BUILDER_ID_::
This endpoint queries tasks with QueryParamBuilder.
Pass the QueryParamBuilder variables in the request body.
+
.Request Body
[source,json]
----
 {
  "min" : 10,
  "max" : 20
 }
----

To use advanced queries through the REST API:

. Change into a directory of your choice and create an XML file with your query definition. For example:
+
[source,xml]
----
<query-definition>
    <query-name>getAllTasks</query-name>
    <query-source>java:jboss/datasources/ExampleDS</query-source>
    <query-expression>select * from Task t</query-expression>
    <query-target>TASK</query-target>
</query-definition>
----
. Send a POST request to register your query definition. For example:
+
[source,bash]
----
$ curl -X POST -u 'kieserver:kieserver1!' -H 'Content-type: application/xml' --data @queryDefinition.xml 'http://localhost:8080/kie-execution-server/services/rest/server/queries/definitions/getAllTasks'
----
. To get the results of the query execution, send a GET request to __queries/definitions/getAllTasks/data__. For example:
+
[source,bash]
----
 curl -u 'kieserver:kieserver1!' -H 'Accept: application/xml' 'http://localhost:8080/kie-execution-server/services/rest/server/queries/definitions/getAllTasks/data?mapper=UserTasks&orderBy=&page=0&pageSize=100'
----
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<task-instance-list>
    <task-instance>
        <task-priority>0</task-priority>
        <task-name>TEST_HT</task-name>
        <task-description></task-description>
        <task-status>Reserved</task-status>
        <task-created-on>2016-05-14T01:47:42.684-03:00</task-created-on>
        <task-activation-time>2016-05-14T01:47:42.684-03:00</task-activation-time>
        <task-process-instance-id>1</task-process-instance-id>
        <task-process-id>project1.proc_ht</task-process-id>
        <task-container-id>project1</task-container-id>
    </task-instance>
</task-instance-list>
----

endif::PAM[]
ifdef::PAM[]

[id='_job_execution']
== Managing Job Execution


REST API allows you to access information about asynchronous jobs without using the Business Central directly.
The {KIE_SERVER} exposes a component for executing asynchronous tasks through REST and JMS.
The exposed API then offers you an access to:

* Schedule a new job.
* Cancel an already scheduled job.
* Add a failed job to the queue again by giving the relevant ``_JOB_ID_``.
* Get a particular job by its ``_JOB_ID_``.
* Query jobs scheduled to execute the same command (given as a parameter).
* Query jobs scheduled with the same given ``_BUSINESS_KEY_``.
* Query jobs with the given status as a parameter.


Use the following base URI: __http://_SERVER_ADDRESS:PORT_/kie-execution-server/services/rest/server/jobs__. For example: `__http://_localhost_:8080/kie-execution-server/services/rest/server/jobs__`. See the list of endpoints:


[GET] /::
Response type: list of `RequestInfoInstance` objects
+
Description: Use this endpoint to query jobs in the server. You can specify the parameters ``page``, ``pageSize``, and ``status``; possible values for status are `QUEUED`, `DONE`, `CANCELLED`, `ERROR`, `RETRYING`, and `RUNNING`.
Note that these values must be capitalized.

[POST] /::
+
Request type: `RequestInfoInstance` object
+
Response type: created `_JOB_ID_`
+
Description: Creates a new job request and returns its ID. It is possible to assign the job to a container by setting ``_CONTAINER_ID_``.

[POST] /_JOB_ID_/data::
Request type: A `Map<String, Object>` object. The key is a name of a property specific to the executor command; the value is the property value. Use the `containerId` query parameter to set a deployment ID for the job.
+
Response type: none.
+
Description: Updates the data field for existing command. For example, the https://github.com/kiegroup/jbpm/blob/7.0.x/jbpm-services/jbpm-executor/src/main/java/org/jbpm/executor/commands/LogCleanupCommand.java[LogCleanupCommand.java] command contains the `SkipProcessLog` property. To set it to `true`, use the following payload:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<map-type>
    <entries>
        <entry>
            <key>SkipProcessLog</key>
            <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">true</value>
        </entry>
    </entries>
</map-type>
----

[GET] /commands/_JOB_COMMAND_NAME_::
Response type: list of `RequestInfoInstance` objects
+
Description: Returns a list of jobs configured to run with the `_JOB_COMMAND_NAME_` command class. You can specify the parameters ``page``, ``pageSize``, and ``status``. Use the `status` query parameter to filter queries based on their status; possible values for status are `QUEUED`, `DONE`, `CANCELLED`, `ERROR`, `RETRYING`, and `RUNNING`.

[GET] /_JOB_ID_::
Response type: `RequestInfoInstance` object
+
Description: Returns details of a job request with the provided ``_JOB_ID_``.
You can specify the parameters `withErrors` (boolean) to include errors of an execution and `withData` to include the data associated with the job.

[DELETE] /_JOB_ID_::
Description: Cancels a job with the given ``_JOB_ID_``.
If successful, returns HTTP code 204, otherwise HTTP code 500.

[PUT] /_JOB_ID_::
Request type: `RequestInfoInstance` object
+
Description: Requests unfinished or failed job request with the given `_JOB_ID_` and reassigns it into the job queue.

[GET] /keys/_BUSINESS_KEY_::
Response type: list of `RequestInfoInstance` objects.
+
Description: Returns a list of jobs that match the given ``_BUSINESS_KEY_``. You can specify the parameters ``page``, ``pageSize``, and ``status``. Use the `status` query parameter to filter queries based on their status; possible values for status are `QUEUED`, `DONE`, `CANCELLED`, `ERROR`, `RETRYING`, and `RUNNING`.

[GET] /containers/_CONTAINER_ID_::
+
Response type: list of `RequestInfoInstance` objects.
+
Description: Returns a list of jobs that match given container. You can specify the parameters ``page``, ``pageSize``, and ``status``. Use the `status` query parameter to filter queries based on their status; possible values for status are `QUEUED`, `DONE`, `CANCELLED`, `ERROR`, `RETRYING`, and `RUNNING`.

[GET] /processes/instances/_PROCESS_INSTANCE_ID_::
+
Response type: list of `RequestInfoInstance` objects.
+
Description: Returns a list of jobs associated with given _PROCESS_INSTANCE_ID_. You can specify the parameters ``page``, ``pageSize``, and ``status``. Use the `status` query parameter to filter queries based on their status; possible values for status are `QUEUED`, `DONE`, `CANCELLED`, `ERROR`, `RETRYING`, and `RUNNING`.


.[POST] New Job
====
. Change into a directory of your choice and create a `jobRequest.xml` file with the following content:
+

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<job-request-instance>
	<job-command>org.jbpm.executor.commands.PrintOutCommand</job-command>
	<scheduled-date>2016-02-11T00:00:00-02:00</scheduled-date>
	<data />
</job-request-instance>
----
. Execute the following command:
+

[source]
----
$ curl -X POST --data @jobRequest.xml -u 'kieserver:kieserver1!' -H 'content-type: application/xml' 'http://localhost:8080/kie-execution-server/services/rest/server/jobs/'
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<long-type>
	<value>4</value>
</long-type>
----
====

.[GET] List All Jobs
====
To list all jobs in the JSON format, execute the following command:

[source]
----
$ curl -u 'kieserver:kieserver1!' -H 'Accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/jobs?status=QUEUED&status=DONE&status=CANCELLED&status=ERROR&status=RETRYING&status=RUNNING'
----

An example response:

[source,json]
----

{
 "request-info-instance" : [ {
    "request-instance-id"    :  3,
    "request-status"         : "CANCELLED",
    "request-message"        : "Ready to execute",
    "request-retries"        :  3,
    "request-executions"     :  0,
    "request-command"        : "org.jbpm.executor.commands.PrintOutCommand",
    "request-scheduled-date" :  1455156000000
 }, {
    "request-instance-id"    :  2,
    "request-status"         : "QUEUED",
    "request-message"        : "Ready to execute",
    "request-retries"        :  3,
    "request-executions"     :  0,
    "request-command"        : "org.jbpm.executor.commands.PrintOutCommand",
    "request-scheduled-date" :  1454983200000
 }, {
    "request-instance-id"    :  1,
    "request-status"         : "DONE",
    "request-message"        : "Ready to execute",
    "request-retries"        :  3,
    "request-executions"     :  0,
    "request-command"        : "org.jbpm.executor.commands.PrintOutCommand",
    "request-scheduled-date" :  1454918401190
 } ]
}
----
====
endif::PAM[]

[id='sect-job-filtering']
== Advanced Search Filtering of Jobs

Users with administrator or process administrator permissions can filter jobs using the *Search* tab in the *Jobs* page.

Access the *Jobs* list by clicking *Deploy* -> *Jobs*.

.Filtering Jobs - Default View
image::JobSearchSmall.png[Filtering Jobs - Default View]

Jobs can be filtered on the following attributes:

Process Instance Id:: Filter by process instance ID.
+
Input: `Numeric`

Business Key:: Filter by business key. The business key is defined when a job is created, usually relating in some way to the business process.
+
Input: `String`

Type:: Filter by class name. The type is the class to be executed as part of the job request.
+
Input: 'String'

Process Description:: Filter by process description.
+
Input: `String`

Status::
+
Filter by job status. Only one status filter can be applied to the search results at a time. Selecting a different status overwrites the current status filter. Removing the status filter displays all processes, regardless of status.
+
In the *Request List* page, *All*, *Queued*, *Running*, *Retry*, *Error*, and *Completed* tabs display a list of all jobs with these statuses, however the filtering cannot be performed on these tabs. The following filter states are available:
+
** Canceled
** Completed
** Error
** Queued
** Retrying
** Running

Process Name:: Filter by process name.

Due On:: Filtering by the date or time the job is due.
+
This filter has the following quick filter options:

** Last Hour
** Today
** Last 24 Hours
** Last 7 Days
** Last 30 Days
** Custom
+
Selecting *Custom* date and time filtering opens a calendar tool for selecting a date and time range.
+
.Search by Date
image::DateRangeSearch.png[Search by Date Range]

For more information about advanced search filtering, see {URL_USER_GUIDE}#chap-process-admin-quick-filtering[Process Administration Advanced Search Filtering] in the {USER_GUIDE}.


== Managing Documents

The {KIE_SERVER} enables you to upload and interact with documents. Use the following base URI: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/documents`. See the list of endpoints:

[GET] /::
+
--
Description::
Returns the list of documents saved on your {KIE_SERVER}. Use the `page` and `pageSize` parameters to control pagination.

Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/7.0.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/DocumentInstanceList.java[DocumentInstanceList] object.
--

[GET] /_DOCUMENT_ID_::
+
--
Description::
Returns information about the specified document.

Response Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/7.0.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/DocumentInstance.java[DocumentInstance] object.
--

[GET] /_DOCUMENT_ID_/content::
+
--
Description::
Returns the content of the specified document.

Response Type::
An _application/octet-stream_ attachment.
--

[id='_post_document']
[POST] /::
+
--
Request Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/7.0.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/DocumentInstance.java[DocumentInstance] object.

Description::
Uploads the specified document on your {KIE_SERVER}.

JAXB Example Payload::
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<document-instance>
    <document-id>DocIdentifier</document-id>
    <document-name>DocName</document-name>
    <document-size>0</document-size>
    <document-last-mod>2017-06-19T11:35:48.468+02:00</document-last-mod>
    <document-content>VGhpcyBpcyBhIGRvY3VtZW50</document-content>
</document-instance>
----

XSTREAM Example Payload::
+
[source,xml]
----
<org.kie.server.api.model.instance.DocumentInstance>
  <identifier>DocIdentifier</identifier>
  <name>DocName</name>
  <size>0</size>
  <lastModified>2017-06-19 11:42:51.538 UTC</lastModified>
  <content>VGhpcyBpcyBhIGRvY3VtZW50</content>
</org.kie.server.api.model.instance.DocumentInstance>
----

JSON Example Payload::
+
[source,json]
----
{
  "document-id" : "DocIdentifier",
  "document-name" : "DocName",
  "document-link" : null,
  "document-size" : 0,
  "document-last-mod" : 1497872613186,
  "document-content" : "VGhpcyBpcyBhIGRvY3VtZW50"
}
----

Response Type::
The document ID.
--

[PUT] /_DOCUMENT_ID_::
+
--
Description::
Updates the specified document.

Request Type::
A https://github.com/kiegroup/droolsjbpm-integration/blob/7.0.x/kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/instance/DocumentInstance.java[DocumentInstance] object. For further information about the payload, see <<_post_document,[POST] />>.
--

[DELETE] /_DOCUMENT_ID_::
+
--
Description::
Deletes the specified document.
--


ifdef::PAM[]
[id='_the_rest_api_for_managing_the_realtime_decision_server']
= The REST API for {KIE_SERVER} Administration

This section provides information about the Rest API for both managed and unmanaged {KIE_SERVER} environments.
You must set correct HTTP headers for the servers.  See <<_realtime_decision_server,REST API for {KIE_SERVER}>>


== Managed {KIE_SERVER} Environment

When you have a managed {KIE_SERVER} setup, you need to manage {KIE_SERVER} and containers through a controller.
Usually, it is done through Business Central, but you may also use Controller REST API.

* The controller base URL is provided by business-central war deployment, which is the same as `org.kie.server.controller` property (for example __http://_localhost_:8080/business-central/rest/controller__).
* All requests require basic HTTP Authentication or token-based authentication for the role [property]``kie-server``.


[GET] /management/servers::
+
Returns a list of {KIE_SERVER} templates.
+
.Example Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<server-template-list>
    <server-template>
        <server-id>local-server-123</server-id>
        <server-name>local-server-123</server-name>
        <container-specs>
            <container-id>hr</container-id>
            <container-name>hr</container-name>
            <server-template-key>
                <server-id>local-server-123</server-id>
                <server-name>local-server-123</server-name>
            </server-template-key>
            <release-id>
                <artifact-id>EmailProject</artifact-id>
                <group-id>org.redhat.gss</group-id>
                <version>1.0</version>
            </release-id>
            <configs>
                <entry>
                    <key>RULE</key>
                    <value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                        <pollInterval>500</pollInterval>
                        <scannerStatus>STOPPED</scannerStatus>
                    </value>
                </entry>
                <entry>
                    <key>PROCESS</key>
                    <value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                        <runtimeStrategy>SINGLETON</runtimeStrategy>
                        <mergeMode>MERGE_COLLECTIONS</mergeMode>
                    </value>
                </entry>
            </configs>
            <status>STARTED</status>
        </container-specs>
        <configs/>
        <server-instances>
            <server-instance-id>local-server-123@localhost:8080</server-instance-id>
            <server-name>local-server-123@localhost:8080</server-name>
            <server-template-id>local-server-123</server-template-id>
            <server-url>http://localhost:8080/kie-execution-server/services/rest/server</server-url>
        </server-instances>
        <capabilities>RULE</capabilities>
        <capabilities>PROCESS</capabilities>
        <capabilities>PLANNING</capabilities>
    </server-template>
</server-template-list>
----

[GET] /management/servers/_ID_::
+
Returns {A_KIE_SERVER} template.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<server-template-list>
    <server-template>
        <server-id>local-server-123</server-id>
        <server-name>local-server-123</server-name>
        <container-specs>
            <container-id>hr</container-id>
            <container-name>hr</container-name>
            <server-template-key>
                <server-id>local-server-123</server-id>
                <server-name>local-server-123</server-name>
            </server-template-key>
            <release-id>
                <artifact-id>EmailProject</artifact-id>
                <group-id>org.redhat.gss</group-id>
                <version>1.0</version>
            </release-id>
            <configs>
                <entry>
                    <key>RULE</key>
                    <value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                        <pollInterval>500</pollInterval>
                        <scannerStatus>STOPPED</scannerStatus>
                    </value>
                </entry>
                <entry>
                    <key>PROCESS</key>
                    <value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                        <runtimeStrategy>SINGLETON</runtimeStrategy>
                        <mergeMode>MERGE_COLLECTIONS</mergeMode>
                    </value>
                </entry>
            </configs>
            <status>STARTED</status>
        </container-specs>
        <configs/>
        <server-instances>
            <server-instance-id>local-server-123@localhost:8080</server-instance-id>
            <server-name>local-server-123@localhost:8080</server-name>
            <server-template-id>local-server-123</server-template-id>
            <server-url>http://localhost:8080/kie-execution-server/services/rest/server</server-url>
        </server-instances>
        <capabilities>RULE</capabilities>
        <capabilities>PROCESS</capabilities>
        <capabilities>PLANNING</capabilities>
    </server-template>
</server-template-list>
----

[PUT] /management/servers/_ID_::
Creates a new {KIE_SERVER} template with the specified id.
+

.Example Request to Create a New {KIE_SERVER} Instance
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<server-template-details>
    <server-id>test-demo</server-id>
    <server-name>test-demo</server-name>
    <configs/>
    <capabilities>RULE</capabilities>
    <capabilities>PROCESS</capabilities>
    <capabilities>PLANNING</capabilities>
</server-template-details>
----

[DELETE] /management/servers/_ID_::
Deletes {A_KIE_SERVER} template with the specified id.

[GET] /management/servers/_ID_/containers::
Returns all containers on given server.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<container-spec-list>
    <container-spec>
        <container-id>hr</container-id>
        <container-name>hr</container-name>
        <server-template-key>
            <server-id>local-server-123</server-id>
            <server-name>local-server-123</server-name>
        </server-template-key>
        <release-id>
            <artifact-id>EmailProject</artifact-id>
            <group-id>org.redhat.gss</group-id>
            <version>1.0</version>
        </release-id>
        <configs>
            <entry>
                <key>RULE</key>
                <value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                    <pollInterval>500</pollInterval>
                    <scannerStatus>STOPPED</scannerStatus>
                </value>
            </entry>
            <entry>
                <key>PROCESS</key>
                <value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                    <runtimeStrategy>SINGLETON</runtimeStrategy>
                    <mergeMode>MERGE_COLLECTIONS</mergeMode>
                </value>
            </entry>
        </configs>
        <status>STARTED</status>
    </container-spec>
</container-spec-list>
----

[GET] /management/servers/_ID_/containers/_CONTAINER_ID_::
Returns the container information including its release id and configuration.
+
.Server Response
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<container-spec-details>
    <container-id>hr</container-id>
    <container-name>hr</container-name>
    <server-template-key>
        <server-id>local-server-123</server-id>
        <server-name>local-server-123</server-name>
    </server-template-key>
    <release-id>
        <artifact-id>EmailProject</artifact-id>
        <group-id>org.redhat.gss</group-id>
        <version>1.0</version>
    </release-id>
    <configs>
        <entry>
            <key>RULE</key>
            <value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                <pollInterval>500</pollInterval>
                <scannerStatus>STOPPED</scannerStatus>
            </value>
        </entry>
        <entry>
            <key>PROCESS</key>
            <value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                <runtimeStrategy>SINGLETON</runtimeStrategy>
                <mergeMode>MERGE_COLLECTIONS</mergeMode>
            </value>
        </entry>
    </configs>
    <status>STARTED</status>
</container-spec-details>
----

[PUT] /management/servers/_ID_/containers/_CONTAINER_ID_::
+
--
Creates a new container with the specified container ID, release ID, and the following configuration:

* Runtime strategy: `SINGLETON`.
* KIE Base: `default`.
* KIE Session: `default`.
* Deployment descriptor merge mode: `MERGE_COLLECTIONS`.
* KIE Scanner: `Stopped`.

.Server Request
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<container-spec-details>
    <container-id>hr</container-id>
    <container-name>hr</container-name>
    <server-template-key xsi:type="serverTemplate" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <server-id>local-server-123</server-id>
        <server-name>local-server-123</server-name>
        <configs/>
        <server-instances>
            <server-instance-id>local-server-123@localhost:8080</server-instance-id>
            <server-name>local-server-123@localhost:8080</server-name>
            <server-template-id>local-server-123</server-template-id>
            <server-url>http://localhost:8080/business-central/rest/controller/management/servers/</server-url>
        </server-instances>
    </server-template-key>
    <release-id>
        <artifact-id>HR</artifact-id>
        <group-id>org.jbpm</group-id>
        <version>1.0</version>
    </release-id>
    <configs>
        <entry>
            <key>PROCESS</key>
            <value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                <runtimeStrategy>SINGLETON</runtimeStrategy>
                <kbase></kbase>
                <ksession></ksession>
                <mergeMode>MERGE_COLLECTIONS</mergeMode>
            </value>
        </entry>
        <entry>
            <key>RULE</key>
            <value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<pollInterval>500</pollInterval>
                <scannerStatus>STOPPED</scannerStatus>
            </value>
        </entry>
    </configs>
    <status>STARTED</status>
</container-spec-details>
----
--

[POST] /management/servers/_ID_/containers/_CONTAINER_ID_::
+
--
Updates already existing `_CONTAINER_ID_` container according to the request body. For example:

.Server Request
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<container-spec-details>
    <container-id>hr</container-id>
    <container-name>hr</container-name>
    <server-template-key xsi:type="serverTemplate" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <server-id>local-server-123</server-id>
        <server-name>local-server-123</server-name>
        <configs/>
        <server-instances>
            <server-instance-id>local-server-123@localhost:8080</server-instance-id>
            <server-name>local-server-123@localhost:8080</server-name>
            <server-template-id>local-server-123</server-template-id>
            <server-url>http://localhost:8080/business-central/rest/controller/management/servers/</server-url>
        </server-instances>
    </server-template-key>
    <release-id>
        <artifact-id>HR</artifact-id>
        <group-id>org.jbpm</group-id>
        <version>1.0</version>
    </release-id>
    <configs>
        <entry>
            <key>PROCESS</key>
            <value xsi:type="processConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                <runtimeStrategy>PER_REQUEST</runtimeStrategy>
                <kbase></kbase>
                <ksession></ksession>
                <mergeMode>MERGE_COLLECTIONS</mergeMode>
            </value>
        </entry>
        <entry>
            <key>RULE</key>
            <value xsi:type="ruleConfig" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
		<pollInterval>500</pollInterval>
                <scannerStatus>STOPPED</scannerStatus>
            </value>
        </entry>
    </configs>
    <status>STARTED</status>
</container-spec-details>
----
--

[DELETE] /management/servers/_ID_/containers/_CONTAINER_ID_::
Disposes a container with the specified `_CONTAINER_ID_`.

[POST] /management/servers/_ID_/containers/_CONTAINER_ID_/status/started::
Starts the container. No request body required.

[POST] /management/servers/_ID_/containers/_CONTAINER_ID_/status/stopped::
Stops the Container. No request body required.

== Unmanaged {KIE_SERVER} Environment

The unmanaged {KIE_SERVER} supports endpoints described in this section through the REST API. Note that:

* The base URL for these remains as the endpoint defined earlier: `http://_SERVER:PORT_/kie-execution-server/services/rest/server/`.
* All requests require basic HTTP authentication for the `kie-server` role.

For information about how to access the endpoints, see <<_realtime_decision_server>>.

See the list of endpoints:

[GET] /::
Returns the execution server information.
+
.Server Response
[source,xml]
----
<response type="SUCCESS" msg="Kie Server info">
 <kie-server-info>
  <capabilities>KieServer</capabilities>
  <capabilities>BRM</capabilities>
  <capabilities>BPM</capabilities>
  <capabilities>BPM-UI</capabilities>
  <capabilities>BRP</capabilities>
  <location>
   http://localhost:8230/kie-execution-server/services/rest/server
  </location>
  <messages>
   <content>
    Server KieServerInfo{serverId='15ad5bfa-7532-3eea-940a-abbbbc89f1e8', version='6.5.0.Final-redhat-2', location='http://localhost:8230/kie-execution-server/services/rest/server'}started successfully at Tue Apr 18 08:00:45 CEST 2017
   </content>
   <severity>INFO</severity>
   <timestamp>2017-04-18T08:00:45.953+02:00</timestamp>
  </messages>
  <name>KieServer@/kie-server</name>
  <id>15ad5bfa-7532-3eea-940a-abbbbc89f1e8</id>
  <version>6.5.0.Final-redhat-2</version>
 </kie-server-info>
</response>
----
+
The `<capabilities>` tags provide information about your execution server. See <<_extensions>> for more information about the execution server extensions.


[POST] /config::
Use this endpoint to execute commands on the execution server, for example `create-container`, `list-containers`, `dispose-container`, and `call-container`.
+
An example call for the JAXB marshaller:
+
[source]
----
curl -X POST  -u 'kiesu:kiesu123!' -H 'Content-type: application/xml' -H 'X-KIE-ContentType: JAXB' --data @request.xml 'http://localhost:8080/kie-execution-server/services/rest/server/config'
----
+
An example call for the XSTREAM marshaller:
+
[source]
----
curl -X POST  -u 'kiesu:kiesu123!' -H 'Content-type: application/xml' -H 'X-KIE-ContentType: XSTREAM' --data @request.xml 'http://localhost:8080/kie-execution-server/services/rest/server/config'
----
+
An example call for the JSON marshaller:
+
[source]
----
curl -X POST  -u 'kiesu:kiesu123!' -H 'Content-type: application/json' -H 'X-KIE-ContentType: JSON' --data @request.json 'http://localhost:8080/kie-execution-server/services/rest/server/config'
----
+
Supported commands are:
+
--

* {empty}
+
GetServerInfoCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <get-server-info/>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <get-server-info/>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "get-server-info" : { }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Kie Server info">
        <kie-server-info>
            <capabilities>KieServer</capabilities>
            <capabilities>BRM</capabilities>
            <capabilities>BPM</capabilities>
            <capabilities>BPM-UI</capabilities>
            <capabilities>BRP</capabilities>
            <location>http://localhost:8230/kie-execution-server/services/rest/server</location>
            <messages>
                <content>Server KieServerInfo{serverId='15ad5bfa-7532-3eea-940a-abbbbc89f1e8', version='6.5.0.Final-redhat-2', location='http://localhost:8230/kie-execution-server/services/rest/server'}started successfully at Fri Mar 31 14:14:52 CEST 2017</content>
                <severity>INFO</severity>
                <timestamp>2017-03-31T14:14:52.710+02:00</timestamp>
            </messages>
            <name>KieServer@/kie-server</name>
            <id>15ad5bfa-7532-3eea-940a-abbbbc89f1e8</id>
            <version>6.5.0.Final-redhat-2</version>
        </kie-server-info>
    </response>
</responses>
----

* {empty}
+
CreateContainerCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
<create-container>
  <container container-id="command-script-container">
    <release-id>
      <artifact-id>evaluation</artifact-id>
      <group-id>org.jbpm</group-id>
      <version>1.0</version>
    </release-id>
  </container>
</create-container>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <create-container>
      <kie-container>
        <container-id>command-script-container</container-id>
        <release-id>
          <group-id>org.jbpm</group-id>
          <artifact-id>evaluation</artifact-id>
          <version>1.0</version>
        </release-id>
      </kie-container>
    </create-container>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "create-container" : {
      "container" : {
        "status" : null,
        "messages" : [ ],
        "container-id" : "command-script-container",
        "release-id" : {
          "version" : "1.0",
          "group-id" : "org.jbpm",
          "artifact-id" : "evaluation"
        },
        "config-items" : [ ]
      }
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Container command-script-container successfully deployed with module org.jbpm:evaluation:1.0.">
        <kie-container container-id="command-script-container" status="STARTED">
            <release-id>
                <artifact-id>evaluation</artifact-id>
                <group-id>org.jbpm</group-id>
                <version>1.0</version>
            </release-id>
            <resolved-release-id>
                <artifact-id>evaluation</artifact-id>
                <group-id>org.jbpm</group-id>
                <version>1.0</version>
            </resolved-release-id>
            <scanner status="DISPOSED"/>
        </kie-container>
    </response>
</responses>
----

* {empty}
+
GetContainerInfoCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <get-container-info container-id="command-script-container"/>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <get-container-info>
      <container-id>command-script-container</container-id>
    </get-container-info>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "get-container-info" : {
      "container-id" : "command-script-container"
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Info for container command-script-container">
        <kie-container container-id="command-script-container" status="STARTED">
            <messages>
                <content>Container command-script-container successfully created with module org.jbpm:evaluation:1.0.</content>
                <severity>INFO</severity>
                <timestamp>2017-03-31T15:29:21.056+02:00</timestamp>
            </messages>
            <release-id>
                <artifact-id>evaluation</artifact-id>
                <group-id>org.jbpm</group-id>
                <version>1.0</version>
            </release-id>
            <resolved-release-id>
                <artifact-id>evaluation</artifact-id>
                <group-id>org.jbpm</group-id>
                <version>1.0</version>
            </resolved-release-id>
            <scanner status="DISPOSED"/>
        </kie-container>
    </response>
</responses>

----

* {empty}
+
ListContainersCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <list-containers>
        <kie-container-filter>
            <release-id-filter/>
            <container-status-filter>
                <accepted-status>CREATING</accepted-status>
                <accepted-status>STARTED</accepted-status>
                <accepted-status>FAILED</accepted-status>
                <accepted-status>DISPOSING</accepted-status>
                <accepted-status>STOPPED</accepted-status>
            </container-status-filter>
        </kie-container-filter>
    </list-containers>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
 <commands>
  <list-containers>
   <kie-container-filter>
    <release-id-filter/>
    <container-status-filter>
     <accepted-status>
       <org.kie.server.api.model.KieContainerStatus>CREATING</org.kie.server.api.model.KieContainerStatus>
       <org.kie.server.api.model.KieContainerStatus>STARTED</org.kie.server.api.model.KieContainerStatus>
       <org.kie.server.api.model.KieContainerStatus>FAILED</org.kie.server.api.model.KieContainerStatus>
       <org.kie.server.api.model.KieContainerStatus>DISPOSING</org.kie.server.api.model.KieContainerStatus>
       <org.kie.server.api.model.KieContainerStatus>STOPPED</org.kie.server.api.model.KieContainerStatus>
     </accepted-status>
    </container-status-filter>
   </kie-container-filter>
  </list-containers>
 </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "list-containers" : {
      "kie-container-filter" : {
        "release-id-filter" : { },
        "container-status-filter" : {
          "accepted-status" : [ "CREATING", "STARTED", "FAILED", "DISPOSING", "STOPPED" ]
        }
      }
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="List of created containers">
        <kie-containers>
            <kie-container container-id="command-script-container" status="STARTED">
                <messages>
                    <content>Container command-script-container successfully created with module org.jbpm:evaluation:1.0.</content>
                    <severity>INFO</severity>
                    <timestamp>2017-04-10T10:05:22.866+02:00</timestamp>
                </messages>
                <release-id>
                    <artifact-id>evaluation</artifact-id>
                    <group-id>org.jbpm</group-id>
                    <version>1.0</version>
                </release-id>
                <resolved-release-id>
                    <artifact-id>evaluation</artifact-id>
                    <group-id>org.jbpm</group-id>
                    <version>1.0</version>
                </resolved-release-id>
                <scanner status="DISPOSED"/>
            </kie-container>
        </kie-containers>
    </response>
</responses>
----

* {empty}
+
DisposeContainerCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <dispose-container container-id="mycontainer"/>
</script
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <dispose-container>
      <container-id>mycontainer</container-id>
    </dispose-container>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "dispose-container" : {
      "container-id" : "mycontainer"
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Container mycontainer successfully disposed."/>
</responses>
----

* {empty}
+
GetScannerInfoCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <get-scanner-info container-id="command-script-container"/>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <get-scanner-info>
      <container-id>command-script-container</container-id>
    </get-scanner-info>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "get-scanner-info" : {
      "container-id" : "command-script-container"
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Scanner info successfully retrieved">
        <kie-scanner status="DISPOSED"/>
    </response>
</responses>
----

* {empty}
+
UpdateScannerCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <update-scanner container-id="command-script-container">
        <scanner poll-interval="10000" status="STARTED"/>
    </update-scanner>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <update-scanner>
      <container-id>command-script-container</container-id>
      <scanner>
        <status>STARTED</status>
        <poll-interval>10000</poll-interval>
      </scanner>
    </update-scanner>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "update-scanner" : {
      "scanner" : {
        "status" : "STARTED",
        "poll-interval" : 10000
      },
      "container-id" : "command-script-container"
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Kie scanner successfully created.">
        <kie-scanner poll-interval="10000" status="STARTED"/>
    </response>
</responses>
----

* {empty}
+
UpdateReleaseIdCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <update-release-id container-id="command-script-container">
        <releaseId>
            <artifact-id>evaluation</artifact-id>
            <group-id>org.jbpm</group-id>
            <version>1.1</version>
        </releaseId>
    </update-release-id>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <update-release-id>
      <container-id>command-script-container</container-id>
      <release-id>
        <group-id>org.jbpm</group-id>
        <artifact-id>evaluation</artifact-id>
        <version>1.1</version>
      </release-id>
    </update-release-id>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "update-release-id" : {
      "releaseId" : {
        "version" : "1.1",
        "group-id" : "org.jbpm",
        "artifact-id" : "evaluation"
      },
      "container-id" : "command-script-container"
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Release id successfully updated.">
        <release-id>
            <artifact-id>evaluation</artifact-id>
            <group-id>org.jbpm</group-id>
            <version>1.1</version>
        </release-id>
    </response>
</responses>
----

* {empty}
+
CallContainerCommand::
The `CallContainerCommand` command requires the `payload` attribute. The following payload is used in the examples:
+
[source,java]
----
import org.kie.server.api.marshalling.Marshaller;
import org.kie.server.api.marshalling.MarshallerFactory;
import org.kie.server.api.marshalling.MarshallingFormat;

...

Marshaller marshaller = MarshallerFactory.getMarshaller(MarshallingFormat.JSON,myclass.class.getClassLoader());
//Marshalling format is changed based on the method of marshalling for the CallContainerCommand. Also note myclass.class classloader is called. If replicating this code, change the name to the name of your class.

Command<?> fire = KieServices.Factory.get().getCommands().newFireAllRules();
BatchExecutionCommand batch = KieServices.Factory.get().getCommands().newBatchExecution(Arrays.<Command<?>>asList(fire), "defaultKieSession");
String payload = marshaller.marshall(batch);
----
+
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <call-container container-id="command-script-container">
        <payload>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;batch-execution lookup="defaultKieSession"&gt;
    &lt;fire-all-rules max="-1"/&gt;
&lt;/batch-execution&gt;
</payload>
    </call-container>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <call-container>
      <container-id>command-script-container</container-id>
      <payload>&lt;batch-execution lookup=&quot;defaultKieSession&quot;&gt;
  &lt;fire-all-rules/&gt;
&lt;/batch-execution&gt;</payload>
    </call-container>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "call-container" : {
      "payload" : "{\n  \"lookup\" : \"defaultKieSession\",\n  \"commands\" : [ {\n    \"fire-all-rules\" : {\n      \"max\" : -1,\n      \"out-identifier\" : null\n    }\n  } ]\n}",
      "container-id" : "command-script-container"
    }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Container command-script-container successfully called.">
        <results>&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;
&lt;execution-results&gt;
    &lt;results/&gt;
    &lt;facts/&gt;
&lt;/execution-results&gt;
</results>
    </response>
</responses>
----

* {empty}
+
GetServerStateCommand::
XML body request using the JAXB marshaller:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
    <get-server-state/>
</script>
----
+
XML body request using the XSTREAM marshaller:
+
[source,xml]
----
<script>
  <commands>
    <org.kie.server.api.commands.GetServerStateCommand/>
  </commands>
</script>
----
+
JSON body request:
+
[source,json]
----
{
  "commands" : [ {
    "get-server-state" : { }
  } ]
}
----
+
An example response:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<responses>
    <response type="SUCCESS" msg="Successfully loaded server state for server id 15ad5bfa-7532-3eea-940a-abbbbc89f1e8">
        <kie-server-state-info>
            <config>
                <config-items>
                    <itemName>org.kie.server.repo</itemName>
                    <itemValue>/BPMS6.4/standalone/data</itemValue>
                    <itemType>java.lang.String</itemType>
                </config-items>
            </config>
            <containers container-id="command-script-container" status="STARTED">
                <release-id>
                    <artifact-id>evaluation</artifact-id>
                    <group-id>org.jbpm</group-id>
                    <version>1.1</version>
                </release-id>
                <resolved-release-id>
                    <artifact-id>evaluation</artifact-id>
                    <group-id>org.jbpm</group-id>
                    <version>1.1</version>
                </resolved-release-id>
                <scanner poll-interval="1000" status="STARTED"/>
            </containers>
        </kie-server-state-info>
    </response>
</responses>
----
+
The following example request contains the `create-container`, `call-container`, and `dispose-container` commands:
+
.Sample Request to Create a Container
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<script>
  <create-container>
    <container container-id="command-script-container">
      <release-id>
        <artifact-id>baz</artifact-id>
        <group-id>foo.bar</group-id>
        <version>2.1.0.GA</version>
      </release-id>
    </container>
  </create-container>
  <call-container container-id="command-script-container">
    <payload><?xml version="1.0" encoding="UTF-8" standalone="yes"?>
      <batch-execution lookup="defaultKieSession">
        <insert out-identifier="message" return-object="true" entry-point="DEFAULT" disconnected="false">
          <object xsi:type="message" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <text>HelloWorld</text>
          </object>
        </insert>
        <fire-all-rules max="-1"/>
      </batch-execution>
    </payload>
  </call-container>
  <dispose-container container-id="command-script-container"/>
</script>
----
--

[GET] /containers::
Returns a list of containers on the server.
+
--
.Server Response
[source,xml]
----
<response type="SUCCESS" msg="List of created containers">
  <kie-containers>
    <kie-container container-id="MyProjectContainer" status="STARTED">
      <release-id>
        <artifact-id>Project1</artifact-id>
        <group-id>com.redhat</group-id>
        <version>1.0</version>
      </release-id>
      <resolved-release-id>
        <artifact-id>Project1</artifact-id>
        <group-id>com.redhat</group-id>
        <version>1.0</version>
      </resolved-release-id>
    </kie-container>
  </kie-containers>
</response>
----

Starting with {PRODUCT} version 6.4, you can filter the containers by adding any of the following Maven artifact coordinates to the query:

* `groupId`
* `artifactId`
* `version`

.Filtering Containers by Maven Properties
====

Issuing the following call lists containers with Group ID `org.example`, Artifact ID `artifact`, and version `1.0.0.Final`:

[source]
----
curl -u 'kieserver:kieserver1!' -H 'Accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/containers?groupId=org.example&artifactId=artifact&version=1.0.0.Final'
----
====

To filter by container status, specify the `status` attribute. Multiple values are separated with a comma.

.Example Filtering Containers by Status
====

Issuing the following call lists only failed and stopped containers:

[source]
----
curl -u 'kieserver:kieserver1!' -H 'Accept: application/json' 'http://localhost:8080/kie-execution-server/services/rest/server/containers?status=FAILED,STOPPED'
----
====
--


[GET] /containers/_ID_::
Returns the status and information about a specified container.
+
.Server Response
[source,xml]
----
<response type="SUCCESS" msg="Info for container MyProjectContainer">
  <kie-container container-id="MyProjectContainer" status="STARTED">
    <release-id>
      <artifact-id>Project1</artifact-id>
      <group-id>com.redhat</group-id>
      <version>1.0</version>
    </release-id>
    <resolved-release-id>
      <artifact-id>Project1</artifact-id>
      <group-id>com.redhat</group-id>
      <version>1.0</version>
    </resolved-release-id>
  </kie-container>
</response>
----


[PUT] /containers/_CONTAINER_ID_::
+
--
Creates a new container in the {KIE_SERVER} with a container ID specified in the URI and configuration specified in the request body. The configuration, in addition to the project release ID, provides the following settings:

* Runtime strategy: `SINGLETON`.
* KIE Base: `default`.
* KIE Session: `default`.
* Deployment descriptor merge mode: `MERGE_COLLECTIONS`.
* KIE Scanner:
** Status: `STARTED`.
** Interval: `5000`.


.Request to Create a Container
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<kie-container>
    <config-items>
        <itemName>RuntimeStrategy</itemName>
        <itemValue>SINGLETON</itemValue>
        <itemType>java.lang.String</itemType>
    </config-items>
    <config-items>
        <itemName>MergeMode</itemName>
        <itemValue>MERGE_COLLECTIONS</itemValue>
        <itemType>java.lang.String</itemType>
    </config-items>
    <config-items>
        <itemName>KBase</itemName>
        <itemValue></itemValue>
        <itemType>java.lang.String</itemType>
    </config-items>
    <config-items>
        <itemName>KSession</itemName>
        <itemValue></itemValue>
        <itemType>java.lang.String</itemType>
    </config-items>
    <release-id>
        <artifact-id>EmailProject</artifact-id>
        <group-id>org.redhat.gss</group-id>
        <version>1.0</version>
    </release-id>
    <scanner poll-interval="5000" status="STARTED"/>
</kie-container>
----


.Example Server Response When Creating a Container
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<response type="SUCCESS" msg="Container Example successfully deployed with module org.redhat.gss:EmailProject:1.0.">
    <kie-container container-id="Example" status="STARTED">
        <config-items>
            <itemName>RuntimeStrategy</itemName>
            <itemValue>SINGLETON</itemValue>
            <itemType>java.lang.String</itemType>
        </config-items>
        <config-items>
            <itemName>MergeMode</itemName>
            <itemValue>MERGE_COLLECTIONS</itemValue>
            <itemType>java.lang.String</itemType>
        </config-items>
        <config-items>
            <itemName>KBase</itemName>
            <itemValue></itemValue>
            <itemType>java.lang.String</itemType>
        </config-items>
        <config-items>
            <itemName>KSession</itemName>
            <itemValue></itemValue>
            <itemType>java.lang.String</itemType>
        </config-items>
        <release-id>
            <artifact-id>EmailProject</artifact-id>
            <group-id>org.redhat.gss</group-id>
            <version>1.0</version>
        </release-id>
        <resolved-release-id>
            <artifact-id>EmailProject</artifact-id>
            <group-id>org.redhat.gss</group-id>
            <version>1.0</version>
        </resolved-release-id>
        <scanner poll-interval="5000" status="STARTED"/>
    </kie-container>
</response>
----
--

[DELETE] /containers/_ID_::
Disposes of a container specified by the ID.
+
.Server Response Disposing a Container
[source,xml]
----
<response type="SUCCESS" msg="Container MyProjectContainer successfully disposed."/>
----

[GET] /containers/_ID_/release-id::
Returns a full release ID for a specified container.
+
.Server Response
[source,xml]
----
<response type="SUCCESS" msg="ReleaseId for container MyProjectContainer">
  <release-id>
    <artifact-id>Project1</artifact-id>
    <group-id>com.redhat</group-id>
    <version>1.0</version>
  </release-id>
</response>
----

[POST] /containers/_ID_/release-id::
Allows you to update the release ID of a container.
+
.Sample Server Request
[source,xml]
----
<release-id>
  <artifact-id>Project1</artifact-id>
  <group-id>com.redhat</group-id>
  <version>1.1</version>
</release-id>
----
+
The server responds with a success or error message, such as:
+
.Sample Server Response
[source,xml]
----
<response type="SUCCESS" msg="Release id successfully updated.">
  <release-id>
    <artifact-id>Project1</artifact-id>
    <group-id>com.redhat</group-id>
    <version>1.0</version>
  </release-id>
</response>
----


[GET] /containers/_ID_/scanner::
Returns information about the scanner for container's automatic updates.
+
.Server Response
[source,xml]
----
<response type="SUCCESS" msg="Scanner info successfully retrieved">
  <kie-scanner status="DISPOSED"/>
</response>
----


[POST] /containers/_ID_/scanner::
Allows you to start or stop a scanner that controls polling for updated container deployments.
+
.Example Server Request to Start the Scanner
[source,xml]
----
<kie-scanner status="STARTED" poll-interval="20"/>
----

+
.Server Response
[source,xml]
----
<response type="SUCCESS" msg="Kie scanner successfully created.">
  <kie-scanner status="STARTED"/>
</response>
----

+
To stop the scanner, replace the status with `DISPOSED` and remove the `poll-interval` attribute.


== {KIE_SERVER} Standalone Controller

The {KIE_SERVER} standalone controller is used for handling {KIE_SERVER} instead of Business Central. The standalone controller provides a REST interface that allows {KIE_SERVER} to register with the controller, and allows the controller to then deploy and undeploy (start and stop) containers to {KIE_SERVER} instances running a given server template. The standalone controller can be deployed to all supported containers.

The following configuration settings can be used to expose the {KIE_SERVER} to the controller:

KIE_SERVER_LOCATION::
`org.kie.server.location`

CFG_KIE_USER::
`org.kie.server.user`

CFG_KIE_PASSWORD::
`org.kie.server.pwd`

CFG_KIE_TOKEN::
`org.kie.server.token`

The following properties are used when starting the {KIE_SERVER}. These properties direct the server to an {KIE_SERVER} controller (standalone or embedded), and the authentication values for the controller:

KIE_SERVER_CONTROLLER::
`org.kie.server.controller`

CFG_KIE_CONTROLLER_USER::
`org.kie.server.controller.user`

CFG_KIE_CONTROLLER_PASSWORD::
`org.kie.server.controller.pwd`

CFG_KIE_CONTROLLER_TOKEN::
`org.kie.server.controller.token`

Both embedded and standalone controllers have the same configuration, however the packaging differs. The standalone controller is lightweight, and does not include the entire workbench. The main difference between the embedded and lightweight controllers are:

* The standalone controller has no UI; it is designed to work without Business Central.
* Both controllers expose the same REST API in order to store, manage, and retrieve server templates, however the standalone controller uses a file-based mechanism for storing container templates., while the embedded controller uses Git.

Set the name and location of the template file used by the standalone controller using the following system property:

`org.kie.server.controller.templatefile`.

By setting this property, the standalone controller will attempt to use that file for storing and retrieving container templates. If the property is not set, the following is used as a default file for container template storage:

`System.getProperty("java.io.tmpdir")+System.getProperty("file.separator")+"template_store.xml"`

[IMPORTANT]
====
The use of the default file is not recommended, as it results in container templates being placed in a file that could be erased during the cleanup of a temporary directory.
====


ifdef::PAM[]
== Container Aliases

A container is a deployment unit in the {KIE_SERVER}. It is a runtime representation of a kJAR and contains all the assets of a project (such as rules, processes, classes), which are required during execution. Each container has a unique identifier (`containerId`). When different versions of the same kJAR exist in the server,  it results in multiple containers corresponding to the same project with different versions. In such cases, ensure the client application is configured with the `containerId` that maps to the kJAR version you want it to use.

To minimize this overhead on the client application, you can define aliases for a set of containers belonging to the same project. You can create an alias when creating a container by a REST call. For example, in the request `[PUT] /management/servers/ID/containers/CONTAINER_ID`, container alias can be set using the `container-name` property:
[source,xml]
----
<container-name>alias-name</container-name>
----

You can define an alias to as many containers as required. As the aliases are not restricted to the same `groupId` and `artifactId`, the client applications can use the same alias for different versions of kJARs. Thus, instead of specific `containerId`, a client application can use the alias to interact with {KIE_SERVER}.

To interact with an existing process instance or a task, the {KIE_SERVER} locates the container based on the provided `processId` and `taskId` respectively.
To start a new process instance, it is important to locate the latest version of the deployed kJAR on the server. One of the benefits of using aliases is that it ensures that the client applications use the latest available version of the processes, process definition images, and process forms. To start a new process instance of the latest version, the {KIE_SERVER} finds the latest version of the process from all the containers that belong to the provided alias. The server locates the latest version of the process based on the project versions.

Here is an example of the client request using alias as `my-project` and `processId` as `evaluation`:

[source]
----
http://localhost:8230/kie-execution-server/services/rest/server/containers/my-project/processes/evaluation/instances
----

If the latest version of the deployed project is 1.0, then a new process instance is started from `org.jbpm:my-project:1.0` project. Now if you deploy 2.0 version of the project on the server, the client application can use the same request to start a new process instance from `org.jbpm:my-project:2.0`.

In the task and process REST endpoints, you can use container alias instead of `containerId`. You can define an alias for as many containers as needed. If a new container is deployed, old process still work with older version and new process is deployed from new container. If you do not provide an alias, `artifactId` is used by default.

For information on how to edit container alias using Business Central, see the {URL_USER_GUIDE}#editing_container_aliases_through_business_central[Editing Container Aliases Through Business Central] section of the _{USER_GUIDE}_.
endif::PAM[]

== Process Administration

The base URI for process administration is `http://_SERVER:PORT_/kie-execution-server/services/rest/server/admin/containers/_CONTAINER_ID_/processes`. See the list of endpoints:

[GET] /errors::
+
--
Description::
Returns a list of execution errors for the given container.
+
Possible query parameters with the type associated value: `includeAck` (Boolean), `page` (number), `pageSize` (number), `sort` (String), `sortOrder` (Boolean).
--

[GET] /errors/_ERROR_ID_::
+
--
Description::
Returns information about the given execution error for the given container.
--

[PUT] /errors/_ERROR_ID_::
+
--
Description::
Acknowledges (sets `ack`) the specified error. After this call, the error will not be displayed in the `[GET] /errors/_ERROR_ID_` call.

Payload::
Payload is not required.
--

[PUT] /errors/::
+
--
Description::
Acknowledges (sets `ack`) the error specified by the query parameter `errorId`. After this call, the error will not be displayed in the `[GET] /errors/_ERROR_ID_` call.

Payload::
Payload is not required.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/errors::
+
--
Description::
Returns information about execution errors for the given process instance.
+
Possible query parameters with the type associated value: `includeAck` (Boolean), `page` (number), `pageSize` (number), `sort` (String), `sortOrder` (Boolean). Use the `node` (String) parameter to display errors only for the specified node ID.
--

[PUT] /instances/_PROCESS_INSTANCE_ID_::
+
--
Description::
Enables you to migrate an active process instance. Requires the following query parameters:
+
* `targetContainerId`: The ID of the target container.
* `targetProcessId`: The ID of the process to which you want to migrate. The process must be deployed in the specified `targetContainerId` container.

Payload::
Use empty payload when you require no node mapping. If you require node mapping, the payload is a `Map<String,String>` object, where the key is the old node ID, and the value is the new node ID. For example:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<map-type>
    <entries>
        <entry>
            <key>_D3E17247-1D94-47D8-93AD-D645E317B736</key>
            <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">_B8F3E49D-2C7A-4056-BF49-C61987044DB4</value>
        </entry>
    </entries>
</map-type>
----
--

[PUT] /instances/::
+
--
Description::
Enables you to migrate active process instances. Requires the following query parameters:
+
* `targetContainerId`: The container ID that contains the new version of a deployment to which you want to migrate.
* `targetProcessId`: The process ID (deployment) to which you want to migrate. The process must be deployed in the specified `targetContainerId` container.
* `pInstanceId`: A list of the currently active process instances which you want to migrate (the old version). For multiple process instances, use multiple `pInstanceId` query parameters, for example `pInstanceId=1&pInstanceId=2`.

Payload::
Use empty payload when you require no node mapping. If you require node mapping, the payload is a `Map<String,String>` object, where the key is the old node ID, and the value is the new node ID. For example:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<map-type>
    <entries>
        <entry>
            <key>_D3E17247-1D94-47D8-93AD-D645E317B736</key>
            <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">_B8F3E49D-2C7A-4056-BF49-C61987044DB4</value>
        </entry>
    </entries>
</map-type>
----
--

[DELETE] /instances/_PROCESS_INSTANCE_ID_/nodeinstances/_NODE_INSTANCE_ID_::
+
--
Description::
Cancels the specified node instance within the specified process instance.
--

[PUT] /instances/_PROCESS_INSTANCE_ID_/nodeinstances/_NODE_INSTANCE_ID_::
+
--
Description::
Retriggers the specified node instance within the specified process instance.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/nodeinstances::
+
--
Description::
Returns all the active node instances in the specified process instance.
--

[GET] /instances/_PROCESS_INSTANCE_ID_/timers::
+
--
Description::
Returns a list of timers for the given process instance.
--

[PUT] /instances/_PROCESS_INSTANCE_ID_/timers/_TIMER_ID_::
+
--
Description::
Enables you to update the specified timer for the specified process instace. Possible query parameter: `relative` (Boolean).

Payload::
The payload is a `Map<String,Object>` object where the key is name of the parameter you want to change and the value is the new parameter value. For example:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<map-type>
    <entries>
        <entry>
            <key>delay</key>
            <value xsi:type="xs:int" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">360000</value>
        </entry>
    </entries>
</map-type>
----
--

[POST] instances/_PROCESS_INSTANCE_ID_/nodes/_NODE_ID_::
+
--
Description::
Enables you to re-trigger a node. If the node is not active in the process instance, it becomes active upon re-triggering.

Payload::
No payload is required.
--

[GET] instances/_PROCESS_INSTANCE_ID_/nodes::
+
--
Description::
Returns a list of all the nodes in a process instance.
--

== Task Administration

The base URI for task administration is `http://_SERVER:PORT_/kie-execution-server/services/rest/server/admin/containers/_CONTAINER_ID_/tasks`. The following endpoints are available:

[id='_pot-owners']
[PUT] _TASK_ID_/pot-owners::
+
--
Description::
Adds potential users and groups to the specified task. If you set the `remove` query parameter to `true`, the already existing potential owners and groups will be deleted.

Payload::
The payload is an `org.kie.server.api.model.admin.OrgEntities` object. For example:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<org-entities>
    <users>Quincy</users>
    <users>Xerxes</users>
    <groups>IT</groups>
</org-entities>
----
--

[PUT] _TASK_ID_/exl-owners::
+
--
Description::
Adds excluded users and groups to the specified task. If you set the `remove` query parameter to `true`, the already existing excluded owners and groups will be deleted.

Payload::
Identical to the <<_pot-owners,[POST] TASK_ID/pot-owners>> call.
--

[PUT] _TASK_ID_/admins::
+
--
Description::
Adds business administrator owners and groups to the specified task. If you set the `remove` query parameter to `true`, the already existing business administrator owners and groups will be deleted.

Payload::
Identical to the <<_pot-owners,[POST] TASK_ID/pot-owners>> call.
--

[DELETE] _TASK_ID_/pot-owners/users/_USER_ID_::
+
--
Description::
Removes the specified users from the potential owners of the specified task. The task must be active. You can provide a comma-separated list of users, for example: `.../users/robert,geoffrey,mark`.
--

[DELETE] _TASK_ID_/pot-owners/groups/_GROUP_ID_::
+
--
Description::
Removes the specified user group from the potential owner groups of the specified task. The task must be active. You can provide a comma-separated list of groups, for example: `.../groups/it,hr`.
--

[DELETE] _TASK_ID_/exl-owners/users/_USER_ID_::
+
--
Description::
Removes the specified user from the exluded owners of the specified task. The task must be active. You can provide a comma-separated list of users, for example: `.../users/robert,geoffrey,mark`.
--

[DELETE] _TASK_ID_/exl-owners/groups/_GROUP_ID_::
+
--
Description::
Removes the specified user group from the exluded owner groups of the specified task. The task must be active. You can provide a comma-separated list of groups, for example: `.../groups/it,hr`.
--

[DELETE] _TASK_ID_/admins/users/_USER_ID_::
+
--
Description::
Removes the specified business administrator user from the specified task. The task must be active. You can provide a comma-separated list of users, for example: `.../users/robert,geoffrey,mark`.
--

[DELETE] _TASK_ID_/admins/groups/_GROUP_ID_::
+
--
Description::
Removes the specified business administrator user group from the specified task. The task must be active. You can provide a comma-separated list of groups, for example: `.../groups/it,hr`.
--

[PUT] _TASK_ID_/contents/input::
+
--
Description::
Enters the input into a task instance variable.

Payload::
A `Map<String,Object>` object where the key is the ID of the task input variable and the value is the value of the input. The following example sets the task input `performance` to the value `good`:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<map-type>
    <entries>
        <entry>
            <key>performance</key>
            <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">good</value>
        </entry>
    </entries>
</map-type>
----
--

[DELETE] _TASK_ID_/contents/input::
+
--
Description::
Deletes the input variable content in the task instance. Use the query parameter `name` to specify the ID of the input task variable to be deleted. To delete multiple variables, use the `name` query parameter multiple times, for example `name=variable1&name=variable2`.
--

[DELETE] _TASK_ID_/contents/output::
+
--
Description::
Deletes the output variable content in the task instance. Use the query parameter `name` to specify the ID of the input task variable to be deleted. To delete multiple variables, use the `name` query parameter multiple times, for example `name=variable1&name=variable2`.
--

[POST] _TASK_ID_/reassignments::
+
--
Description::
Creates a task reassignment for the specified task. Required query parameters:
+
* `expiresAt`: When the reassignment will trigger (time from now), for example `1d`, `5h`, or `30s`.
* `whenNotStarted`: The reassignment triggers when the task is not started (Boolean).
* `whenNotCompleted`: The reassignment triggers when the task is not completed (Boolean).
+
If you set both `whenNotStarted` and `whenNotCompleted` to `true`, two reassignments are created, one for each behavior.

Payload::
The payload is an `org.kie.server.api.model.admin.OrgEntities` object. For example:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<org-entities>
    <users>Jenny</users>
</org-entities>
----
--

[GET] _TASK_ID_/reassignments::
+
--
Description::
Returns a list of reassignments for the task. Possible query parameter: `activeOnly` (Boolean, `true` by default).
--

[DELETE] _TASK_ID_/reassignments/_REASSIGNMENT_ID_::
+
--
Description::
Deletes the reassignment.
--

[POST] _TASK_ID_/notifications::
+
--
Description::
Creates a task notification for the specified task. Required query parameters:
+
* `expiresAt`: When the reassignment will trigger (time from now), for example `1d`, `5h`, or `30s`.
* `whenNotStarted`: The reassignment triggers when the task is not started (Boolean).
* `whenNotCompleted`: The reassignment triggers when the task is not completed (Boolean).
+
If you set both `whenNotStarted` and `whenNotCompleted` to `true`, two notifications are created, one for each behavior.

Payload::
The payload is an `org.kie.server.api.model.admin.EmailNotification` object. For example:
+
[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<email-notification>
  <from>acme@acme.org</from>
  <users>Sheldon</users>
  <groups>IT</groups>
  <subject>You hava a task not started</subject>
  <body>
    <html>
      <br/>
      <body><br/><b>You have been assigned to a task (task-id ${taskId})</b><br/><br/>                Important technical information that can be of use when working on it<br/><br/>                - process instance id - ${processInstanceId}<br/><br/>                - work item id - ${workItemId}<br/><br/>                <br/>                <hr/><br/>               Here are all potential owners for this task<br/>                <ul><br/>                $foreach{orgEntity : owners}<br/>                        <li>Potential owner = ${orgEntity.id}</li><br/>                $end{}<br/>                </ul><br/>                <br/>                <i>Regards from jBPM team</i><br/>        </body>
      <br/>
    </html>
  </body>
</email-notification>
----
--

[GET] _TASK_ID_/notifications::
+
--
Description::
Returns a list of notifications for the task. Possible query parameter: `activeOnly` (Boolean, `true` by default).
--

[Delete] _TASK_ID_/notifications/_NOTIFICATION_ID_::
+
--
Description::
Deletes the notification.
--


[GET] /errors::
+
--
Description::
Returns a list of execution task errors for the given container.
+
Possible query parameters with the type associated value: `includeAck` (Boolean), `page` (number), `pageSize` (number), `sort` (String), `sortOrder` (Boolean), `process` (String), `name` (String).
--

[PUT] /errors/::
+
--
Description::
Acknowledges (sets `ack`) the error specified by the query parameter `errorId`. After this call, the error will not be displayed in the `[GET] /errors/_ERROR_ID_` call. To acknowledge multiple errors, use the `errorId` query parameter multiple times, for example `errorId=1&errorId=2`.

Payload::
Payload is not required.
--

[GET] /errors/_ERROR_ID_::
+
--
Description::
Returns information about the given execution task error for the given container.
--

[PUT] /errors/_ERROR_ID_::
+
--
Description::
Acknowledges (sets `ack`) the specified error. After this call, the error will not be displayed in the `[GET] /errors/_ERROR_ID_` call.

Payload::
Payload is not required.
--

ifdef::PAM[]

[id='_intelligent_process_server_ui_extension']
= {KIE_SERVER} UI Extension

The {KIE_SERVER} is focused on execution and contains no UI for interaction. To simplify creating custom UI, {KIE_SERVER} is capable of providing:

* Process form structures.
* Task form structures.
* SVG image of the process definition diagram.
* Annotated SVG image of the process definition diagram.

Business Central, the authoring environment, allows users to build assets, such as rules, decision tables, forms, and others. In Business Central, Form Modeler generates forms that are well integrated with process and task variables, and provides binding between the inputs and outputs.

The {KIE_SERVER} expects data to be mapped onto correct process and task variables. By generating form structures, you are able to create custom UI that will properly map the input data onto process and task variables.

== Using the {KIE_SERVER} UI Extension

The {KIE_SERVER} UI Extension supports the following commands through the REST API. Note the following before using these commands:

* The base URL for these will remain as the endpoint defined earlier (`http://_SERVER:PORT_/kie-execution-server/services/rest/server/`).

* All requests require basic HTTP Authentication for the role `kie-server`.

* You need to enable SVG image storing in order to be able to retrieve it through REST API. To do that, follow these steps:
+
. Change into `$_SERVER_HOME_/standalone/deployments/business-central.war/org.kie.workbench.KIEWebapp/profiles/`.
. In `jbpm.xml`, find `<storesvgonsave enabled="false"/>`.
. Change it to `<storesvgonsave enabled="true"/>`
. Restart your server.
. Modify your business process and save it. This step is necessary, otherwise you will receive an empty SVG image.
. Build and deploy your project.

If you set the *package* attribute of your business process, ensure that it matches the package structure of your project. That means if you set the *package* attribute to `com.example.myproject`, place your business process into the `com/example/myproject` directory of your JAR file.

If you set the *package* attribute to a structure different from the directory structure of your business process, you will receive an error similar to the following:

[source]
----
16:35:52,155 WARN  [org.kie.server.services.jbpm.ui.ImageServiceBase] (http-127.0.0.1:8180-1) Could not find SVG image file for process 'sampleproject1.sampleprocess' within container TestKieUIContainer
----

* The default form structure of the {KIE_SERVER} is XML. You can change the format to JSON by providing HTTP header `Accept: application/json`.

[NOTE]
====
Start the process through {KIE_SERVER} (for example, through the REST API) to ensure the following endpoints work.
====

[GET] /containers/_CONTAINER_ID_/forms/processes/_PROCESS_ID_::
+
.Server Response
[source,xml]
----
<form id="1634631252">
  <property name="subject" value=""/>
  <property name="name" value="com.sample.evaluation-taskform"/>
  <property name="displayMode" value="default"/>
  <property name="labelMode" value="undefined"/>
  <property name="status" value="0"/>
  <field id="301394101" name="301394101" position="0" type="InputText">
    <property name="fieldRequired" value="true"/>
    <property name="groupWithPrevious" value="false"/>
    <property name="labelCSSClass" value=""/>
    <property name="labelCSSStyle" value=""/>
    <property name="label" value=""/>
    <property name="errorMessage" value=""/>
    <property name="title" value=""/>
    <property name="disabled" value="false"/>
    <property name="readonly" value="false"/>
    <property name="size" value=""/>
    <property name="formula" value=""/>
    <property name="rangeFormula" value=""/>
    <property name="pattern" value=""/>
    <property name="styleclass" value=""/>
    <property name="cssStyle" value=""/>
    <property name="isHTML" value="false"/>
    <property name="hideContent" value="false"/>
    <property name="defaultValueFormula" value=""/>
    <property name="inputBinding" value=""/>
    <property name="outputBinding" value="employee"/>
  </field>
  <field id="1698224711" name="1698224711" position="1" type="InputTextArea">
    <property name="fieldRequired" value="true"/>
    <property name="groupWithPrevious" value="false"/>
    <property name="height" value="3"/>
    <property name="labelCSSClass" value=""/>
    <property name="labelCSSStyle" value=""/>
    <property name="label" value=""/>
    <property name="errorMessage" value=""/>
    <property name="title" value=""/>
    <property name="disabled" value="false"/>
    <property name="readonly" value="false"/>
    <property name="size" value=""/>
    <property name="formula" value=""/>
    <property name="rangeFormula" value=""/>
    <property name="pattern" value=""/>
    <property name="styleclass" value=""/>
    <property name="cssStyle" value=""/>
    <property name="defaultValueFormula" value=""/>
    <property name="inputBinding" value=""/>
    <property name="outputBinding" value="reason"/>
  </field>
</form>
----
+
The XML response maps the following form:
+
.Form Mapped to XML
image::9801.png[]
+
Available query parameters:
+
* `lang` (String): The language for which you want to filter. Use together with the `filter` query parameter. Default value: `en`.
* `filter` (Boolean): Turns off filtering when set to false. If you set `lang`, set `filter`. Applicable to `.form` forms.
* `type` (String): Filters the type of form to be returned. Possible values: `FORM`, `FRM`, `FTL`, and `ANY`.
* `marshallContent` (Boolean): If set to `false`, the form is returned in the default format (json). Otherwise, the HTTP header setting is used; XML response for `JAXB` and `XSTREAM`, JSON response for `JSON` settings.

[GET] /containers/_CONTAINER_ID_/forms/tasks/_TASK_ID_::
+
.Server Response
[source,xml]
----
<form id="1635016860">
  <property name="name" value="PerformanceEvaluation-taskform"/>
  <property name="displayMode" value="default"/>
  <property name="status" value="0"/>
  <field id="822358072" name="822358072" position="0" type="InputTextArea">
    <property name="fieldRequired" value="false"/>
    <property name="groupWithPrevious" value="false"/>
    <property name="label" value="Reason"/>
    <property name="errorMessage" value=""/>
    <property name="title" value=""/>
    <property name="readonly" value="true"/>
    <property name="inputBinding" value="reason"/>
    <property name="fieldClass" value="java.lang.String"/>
  </field>
  <field id="348604726" name="348604726" position="1" type="InputText">
    <property name="fieldRequired" value="true"/>
    <property name="groupWithPrevious" value="false"/>
    <property name="label" value="Performance"/>
    <property name="errorMessage" value=""/>
    <property name="title" value=""/>
    <property name="readonly" value="false"/>
    <property name="isHTML" value="false"/>
    <property name="hideContent" value="false"/>
    <property name="inputBinding" value="performance"/>
    <property name="outputBinding" value="performance"/>
    <property name="fieldClass" value="java.lang.String"/>
  </field>
  <field id="1048590899" name="initiator" position="2" type="InputText">
    <property name="fieldRequired" value="false"/>
    <property name="label" value="BusinessAdministratorId (initiator)"/>
    <property name="readonly" value="false"/>
    <property name="inputBinding" value="BusinessAdministratorId"/>
    <property name="fieldClass" value="java.lang.String"/>
  </field>
  <dataHolder id="initiator" inputId="BusinessAdministratorId" name="#9BCAFA" outId="" type="basicType" value="java.lang.String"/>
  <dataHolder id="performance" inputId="" name="#BBBBBB" outId="performance" type="basicType" value="java.lang.String"/>
  <dataHolder id="reason" inputId="reason" name="#FF54A7" outId="" type="basicType" value="java.lang.String"/>
</form>
----
+
The XML response maps the following form:
+
.Form Mapped to XML
image::9803.png[]
+
Available query parameters:
+
* `lang` (String): The language for which you want to filter. Use together with the `filter` query parameter. Default value: `en`.
* `filter` (Boolean): Turns off filtering when set to false. If you set `lang`, set `filter`. Applicable to `.form` forms.
* `type` (String): Filters the type of form to be returned. Possible values: `FORM`, `FRM`, `FTL`, and `ANY`.
* `marshallContent` (Boolean): If set to `false`, the form is returned in the default format (json). Otherwise, the HTTP header setting is used; XML response for `JAXB` and `XSTREAM`, JSON response for `JSON` settings.

[GET] /containers/_CONTAINER_ID_/images/processes/_PROCESS_ID_::
Returns an SVG image of the process definition diagram.
+
.Server Response
====
image::9802.png[]
====

[GET] /containers/_CONTAINER_ID_/images/processes/instances/_PROCESS_INSTANCE_ID_::
Returns an annotated SVG image of the process definition diagram.
+
.Server Response
====
image::9804.png[]
====
endif::PAM[]

[id='_rest_api_overview']
= {KIE_SERVER} Java Client API Overview

[id='_client_config']
== Client Configuration

You need to declare a configuration object and set server communication aspects, such as the protocol (REST or JMS), credentials and the payload format (XStream, JAXB or JSON). For additional example, follow the Hello World project.

.Client Configuration
[source,java]
----
import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;

public class DecisionServerTest {

  private static final String URL = "http://localhost:8080/kie-execution-server/services/rest/server";
  private static final String USER = "kieserver";
  private static final String PASSWORD = "kieserver1!";

  private static final MarshallingFormat FORMAT = MarshallingFormat.JSON;

  private KieServicesConfiguration conf;
  private KieServicesClient kieServicesClient;

  @Before
  public void initialize() {
    conf = KieServicesFactory.newRestConfiguration(URL, USER, PASSWORD);

    //If you use custom classes, such as Obj.class, add them to the configuration
    Set<Class<?>> extraClassList = new HashSet<Class<?>>();
    extraClassList.add(Obj.class);
    conf.addExtraClasses(extraClassList);

    conf.setMarshallingFormat(FORMAT);
    kieServicesClient = KieServicesFactory.newKieServicesClient(conf);
  }
}
----

.JMS Client Configuration
[source,java]
----
import java.util.Properties;

import javax.jms.ConnectionFactory;
import javax.jms.Queue;
import javax.naming.Context;
import javax.naming.InitialContext;

import org.junit.Test;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;

public class DecisionServerTest {

  private static final String REMOTING_URL = new String("remote://localhost:4447");

  private static final String USER = "kieserver";
  private static final String PASSWORD = "kieserver1!";

  private static final String INITIAL_CONTEXT_FACTORY = new String("org.jboss.naming.remote.client.InitialContextFactory");
  private static final String CONNECTION_FACTORY = new String("jms/RemoteConnectionFactory");
  private static final String REQUEST_QUEUE_JNDI = new String("jms/queue/KIE.SERVER.REQUEST");
  private static final String RESPONSE_QUEUE_JNDI = new String("jms/queue/KIE.SERVER.RESPONSE");

  private KieServicesConfiguration conf;
  private KieServicesClient kieServicesClient;

  @Test
  public void testJms() throws Exception {
    final Properties env = new Properties();
    env.put(Context.INITIAL_CONTEXT_FACTORY, INITIAL_CONTEXT_FACTORY);
    env.put(Context.PROVIDER_URL, REMOTING_URL);
    env.put(Context.SECURITY_PRINCIPAL, USER);
    env.put(Context.SECURITY_CREDENTIALS, PASSWORD);
    InitialContext context = new InitialContext(env);

    Queue requestQueue = (Queue) context.lookup(REQUEST_QUEUE_JNDI);
    Queue responseQueue = (Queue) context.lookup(RESPONSE_QUEUE_JNDI);
    ConnectionFactory connectionFactory = (ConnectionFactory) context.lookup(CONNECTION_FACTORY);

    conf = KieServicesFactory.newJMSConfiguration(connectionFactory, requestQueue, responseQueue, USER, PASSWORD);

    //If you use custom classes, such as Obj.class, add them to the configuration
    Set<Class<?>> extraClassList = new HashSet<Class<?>>();
    extraClassList.add(Obj.class);
    conf.addExtraClasses(extraClassList);

    kieServicesClient = KieServicesFactory.newKieServicesClient(conf);
  }
}
----

Note that you must assign the the `guest` role to the user `kieserver`. Additionally, you must declare JMS dependency:

[source,xml]
----
<dependency>
  <groupId>org.jboss.as</groupId>
  <artifactId>jboss-as-jms-client-bom</artifactId>
  <version>7.5.7.Final-redhat-3</version>
  <type>pom</type>
</dependency>
----

[id='_jms_interaction_patterns']
=== JMS Interaction Patterns

Since version 6.4 of {PRODUCT}, {KIE_SERVER} Client integration with JMS has been enhanced by several interaction patterns. Available interaction patterns are:

* _Request reply_: the default option that blocks the client until a response is received, making the JMS integration synchronous. Request reply is _not_ suitable for a JMS transactional delivery.
* _Fire and forget_: an option for one-way integration. Suitable, for example, for notifications invoked by integration with the {KIE_SERVER}. Fire and forget is convenient for a transactional JMS delivery. Messages are delivered to the server only if the transaction that invoked the server client was committed successfully.
* _Asynchronous with callback_: with this option, the client is not blocked after sending a message to {KIE_SERVER}. Responses can be received asynchronously. This option can be used for the transactional JMS delivery.

You can set the response handlers either globally (when a `KieServicesConfiguration` is created) or individually on different client instances (such as `RuleServiceClient`, `ProcessServicesClient`, and others) during runtime.

Whereas fire and forget and request reply patterns do not require any additional configuration, you need to configure the callback if you use the asynchronous pattern.  The {KIE_SERVER} client includes a built-in callback (`BlockingResponseCallback`) that provides support using a blocking queue. The callback is configured to receive a single message at a time by default. Therefore, each client interaction contains a single message (request) and a single response. You can change the size of the queue to make it possible to receive multiple messages.

To create a custom callback, implement the `org.kie.server.client.jms.ResponseCallback` interface.

[NOTE]
====
{KIE_SERVER} client is _not_ thread-safe when switching response handlers. Change of a handler can affect all the threads which are using the same client instance. It is recommended to use separate client instances in case of dynamic changes of the handler. You can maintain a set of clients where each client uses a dedicated response handler. Depending on which handler is required, choose a respective client.

For example, having two clients, the first client (with the fire and forget pattern) can be used for starting processes and the second client (with the request reply pattern) can be used for querying user tasks.
====

.Global JMS Configuration
====
[source,java]
----
InitialContext context = ...;
Queue requestQueue = (Queue) context.lookup("jms/queue/KIE.SERVER.REQUEST");
Queue responseQueue = (Queue) context.lookup("jms/queue/KIE.SERVER.RESPONSE");
ConnectionFactory connectionFactory = (ConnectionFactory) context.lookup("jms/RemoteConnectionFactory");
KieServicesConfiguration jmsConfiguration = KieServicesFactory.newJMSConfiguration(connectionFactory, requestQueue, responseQueue, "user", "password");
// Set your response handler globally here.
jmsConfiguration.setResponseHandler(new FireAndForgetResponseHandler());
----
====

.Per Client JMS Configuration
====
[source,java]
----
ProcessServiceClient processClient = client.getServicesClient(ProcessServicesClient.class);
// Change response handler for processClient. The other clients are not affected.
processClient.setResponseHandler(new FireAndForgetResponseHandler());
----
====

In case you are using asynchronous or fire and forget response handlers, you can turn on JMS transactions in `KieServicesConfiguration`. If you do so, use a transaction-aware connection factory: `XAConnectionFactory`.

WARNING: JMS transactions are supported only on Red Hat JBoss Enterprise Application Platform. JMS transactions are _not_ tested on {WEBLOGIC} and {WEBSPHERE}.

[id='_server_response']
== Server Response

Service responses are represented by the `org.kie.server.api.model.ServiceResponse<T>` object, where `T` represents the payload type. It has the following attributes:

* `String _message_`: returns the response message.
* `ResponseType _type_`: returns either `SUCCESS` or `FAILURE`.
* `T _result_`: returns the requested object.

.Hello World Server Response
====
[source,java]
----
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.RuleServicesClient;

RuleServicesClient ruleClient = client.getServicesClient(RuleServicesClient.class);
ServiceResponse<String> response = ruleClient.executeCommands(container, batchCommand);
System.out.println(response.getResult());
----
====

NOTE: A service response is retrieved only if you are using the request reply response handler. In case of asynchronous or fire and forget response handlers, all remote calls always return `null`.

[id='_server_commands']
== Inserting and Executing Commands

To insert commands, use the `org.kie.api.command.KieCommands` class. To instantiate the `KieCommands` class, use `org.kie.api.KieServices.get().getCommands()`. If you want to add multiple commands, use the `BatchExecutionCommand` wrapper.

.Inserting and Executing Commands
====
[source,java]
----
import org.kie.api.command.Command;
import org.kie.api.command.KieCommands;
import org.kie.server.api.model.ServiceResponse;
import org.kie.server.client.RuleServicesClient;
import org.kie.server.client.KieServicesClient;
import org.kie.api.KieServices;

import java.util.Arrays;

...

public void executeCommands() {

  String containerId = "hello";
  System.out.println("== Sending commands to the server ==");
  RuleServicesClient rulesClient = kieServicesClient.getServicesClient(RuleServicesClient.class);
  KieCommands commandsFactory = KieServices.Factory.get().getCommands();

  Command<?> insert = commandsFactory.newInsert("Some String OBJ");
  Command<?> fireAllRules = commandsFactory.newFireAllRules();
  Command<?> batchCommand = commandsFactory.newBatchExecution(Arrays.asList(insert, fireAllRules));

  ServiceResponse<String> executeResponse = rulesClient.executeCommands(containerId, batchCommand);

  if(executeResponse.getType() == ResponseType.SUCCESS) {
    System.out.println("Commands executed with success! Response: ");
    System.out.println(executeResponse.getResult());
  } else {
    System.out.println("Error executing rules. Message: ");
    System.out.println(executeResponse.getMsg());
  }
}
----
====

Add the `org.drools:drools-compiler` dependency into your `pom.xml` file. See the {URL_INSTALLATION_GUIDE}#supported_comps[Supported Components Versions] section of _{INSTALLATION_GUIDE}_ to add a correct version.

[source,xml]
----
<dependency>
  <groupId>org.drools-redhat</groupId>
  <artifactId>drools-compiler</artifactId>
  <version>6.5.0.Final-redhat-2</version>
</dependency>
----
See <<_embedded_jbpm_engine_dependencies>> for a list of further Maven dependencies.

[id='_server_capabilities']
== Listing Server Capabilities

From version 6.2, {KIE_SERVER} supports the business process execution. To find out server capabilities, use the `org.kie.server.api.model.KieServerInfo` object.

`KieServicesClient` requires the server capability information to correctly produce service clients (see <<kie-server-clients-ref>>). You can specify the capabilities globally in `KieServicesConfiguration`, otherwise they are automatically retrieved from the server.

IMPORTANT: Regardless of which response handler is globally specified, `KieServicesClient` uses synchronous request response handler to retrieve the server capabilities. However, you cannot make synchronous calls when JMS transactions are enabled. To do so, you need to set the server capabilities in `KieServicesConfiguration`.

.Server Capabilities
====
[source,java]
----
public void listCapabilities() {

  KieServerInfo serverInfo = kieServicesClient.getServerInfo().getResult();
  System.out.print("Server capabilities:");

  for (String capability : serverInfo.getCapabilities()) {
    System.out.print(" " + capability);
  }

  System.out.println();
}
----
====

[id='_containers']
== Listing Containers


Containers are represented by the `org.kie.server.api.model.KieContainerResource` object. The list of resources is represented by the `org.kie.server.api.model.KieContainerResourceList` object.

.Print a List of Containers
====
[source,java]
----
public void listContainers() {
    KieContainerResourceList containersList = kieServicesClient.listContainers().getResult();
    List<KieContainerResource> kieContainers = containersList.getContainers();
    System.out.println("Available containers: ");
    for (KieContainerResource container : kieContainers) {
        System.out.println("\t" + container.getContainerId() + " (" + container.getReleaseId() + ")");
    }
}
----
====

When obtaining the list of containers, you can optionally filter the result using an instance of the `org.kie.server.api.model.KieContainerResourceFilter` class, which is passed to the `org.kie.server.client.KieServicesClient.listContainers()` method.

.Filter Containers in Java Client API
====
[source,java]
----
public void listContainersWithFilter() {

    // The following filter will match only containers with the ReleaseId
    // "org.example:container:1.0.0.Final" and status FAILED
    KieContainerResourceFilter filter = new KieContainerResourceFilter.Builder()
            .releaseId("org.example", "container", "1.0.0.Final")
            .status(KieContainerStatus.FAILED)
            .build();

    // using previously created KieServicesClient....
    KieContainerResourceList containersList = kieServicesClient.listContainers(filter).getResult();
    List<KieContainerResource> kieContainers = containersList.getContainers();

    System.out.println("Available containers: ");

    for (KieContainerResource container : kieContainers) {
        System.out.println("\t" + container.getContainerId() + " (" + container.getReleaseId() + ")");
    }
}
----
====


[id='_container_handling']
== Handling Containers

You can use the {KIE_SERVER} Java client to create and dispose containers.
If you dispose a container, `ServiceResponse` will be returned with `void` payload.
If you create a container, `KieContainerResource` object will be returned.

.Disposing and Creating a Container
[source,java]
----

public void disposeAndCreateContainer() {
    System.out.println("== Disposing and creating containers ==");
    List<KieContainerResource> kieContainers = kieServicesClient.listContainers().getResult().getContainers();
    if (kieContainers.size() == 0) {
        System.out.println("No containers available...");
        return;
    }
    KieContainerResource container = kieContainers.get(0);
    String containerId = container.getContainerId();
    ServiceResponse<Void> responseDispose = kieServicesClient.disposeContainer(containerId);
    if (responseDispose.getType() == ResponseType.FAILURE) {
        System.out.println("Error disposing " + containerId + ". Message: ");
        System.out.println(responseDispose.getMsg());
        return;
    }
    System.out.println("Success Disposing container " + containerId);
    System.out.println("Trying to recreate the container...");
    ServiceResponse<KieContainerResource> createResponse = kieServicesClient.createContainer(containerId, container);
    if(createResponse.getType() == ResponseType.FAILURE) {
        System.out.println("Error creating " + containerId + ". Message: ");
        System.out.println(responseDispose.getMsg());
        return;
    }
    System.out.println("Container recreated with success!");
}
----


[NOTE]
====
A conversation between a client and a specific {KIE_SERVER} container in a clustered environment is secured by a unique `conversationID`. The `conversationID`  is transferred using the `X-KIE-ConversationId` REST header. If you update the container, unset the previous `conversationID`.  Use `KieServiesClient.completeConversation()` to unset the `conversationID` for Java API.
====

include::kie-server-clients-ref.adoc[leveloffset=+1]

[id='_business_processes']
== Listing Available Business Processes


Use `QueryClient` to list available process definitions. `QueryClient` methods use pagination, therefore in addition to the query you make, you must provide the current page and the number of results per page.
In the provided example, the query starts on page _0_ and lists the first _1000_ results.

.List Processes
[source,java]
----

public void listProcesses() {
    System.out.println("== Listing Business Processes ==");
    QueryServicesClient queryClient = kieServicesClient.getServicesClient(QueryServicesClient.class);
    List<ProcessDefinition> findProcessesByContainerId = queryClient.findProcessesByContainerId("rewards", 0, 1000);
    for (ProcessDefinition def : findProcessesByContainerId) {
        System.out.println(def.getName() + " - " + def.getId() + " v" + def.getVersion());
    }
}
----

== Starting a Business Processes
Use the `ProcessServicesClient` client to start your process. Ensure that any custom classes you require for your process are added into the `KieServicesConfiguration` object, using the `addExtraClasses()` method. To start a process using the Java Client API, see the following example:

[source,java]
----
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;

import org.kie.server.api.marshalling.MarshallingFormat;
import org.kie.server.client.KieServicesClient;
import org.kie.server.client.KieServicesConfiguration;
import org.kie.server.client.KieServicesFactory;
import org.kie.server.client.ProcessServicesClient;
...

public static void startProcess() {
  //Client configuration setup
  KieServicesConfiguration config = KieServicesFactory.newRestConfiguration(SERVER_URL, LOGIN, PASSWORD);

  //Add custom classes, such as Obj.class, to the configuration
  Set<Class<?>> extraClassList = new HashSet<Class<?>>();
  extraClassList.add(Obj.class);
  config.addExtraClasses(extraClassList);
  config.setMarshallingFormat(MarshallingFormat.JSON);

  // ProcessServicesClient setup
  KieServicesClient client = KieServicesFactory.newKieServicesClient(config);
  ProcessServicesClient processServicesClient = client.getServicesClient(ProcessServicesClient.class);

  // Create an instance of the custom class
  Obj obj = new Obj();
  obj.setOk("ok");

  Map<String, Object> variables = new HashMap<String, Object>();
  variables.put("test", obj);


  // Start the process with custom class
  processServicesClient.startProcess(CONTAINER, processId, variables);
}
----

ifdef::PAM[]

[id='_querydefinition']
== QueryDefinition for {KIE_SERVER} Using Java Client API

`QueryDefinition` is a feature used to execute advanced queries. For more information about advanced queries, see <<_advanced_queries2>>. To register and execute query definitions using the Java Client API, see the following example:

.Registering and Executing Query Definitions with QueryServicesClient
[source,java]
----
// client setup
KieServicesConfiguration conf = KieServicesFactory.newRestConfiguration(SERVER_URL, LOGIN, PASSWORD);
KieServicesClient client = KieServicesFactory.newKieServicesClient(conf);

// get the query services client
QueryServicesClient queryClient = client.getServicesClient(QueryServicesClient.class);

// building the query
QueryDefinition queryDefinition = QueryDefinition.builder().name(QUERY_NAME)
        .expression("select * from Task t")
        .source("java:jboss/datasources/ExampleDS")
        .target("TASK").build();

// two queries cannot have the same name
queryClient.unregisterQuery(QUERY_NAME);

// register the query
queryClient.registerQuery(queryDefinition);

// execute the query with parameters: query name, mapping type (to map the fields to an object), page number, page size and return type
List<TaskInstance> query = queryClient.query(QUERY_NAME, QueryServicesClient.QUERY_MAP_TASK, 0, 100, TaskInstance.class);

// read the result
for (TaskInstance taskInstance : query) {
    System.out.println(taskInstance);
}
----



Note that `target` instructs `QueryService` to apply default filters.
Alternatively, you can set filter parameters manually. `Target` has the following values:

[source,java]
----
public enum Target {
    PROCESS,
    TASK,
    BA_TASK,
    PO_TASK,
    JOBS,
    CUSTOM;
}
----
endif::PAM[]
