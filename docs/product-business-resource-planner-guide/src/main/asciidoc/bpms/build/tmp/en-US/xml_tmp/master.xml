<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book [
<!ENTITY % sgml.features "IGNORE">
<!ENTITY % xml.features "INCLUDE">
<!ENTITY % DOCBOOK_ENTS PUBLIC "-//OASIS//ENTITIES DocBook Character Entities V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/dbcentx.mod">
%DOCBOOK_ENTS;
]>
<?asciidoc-toc maxdepth="3"?><?asciidoc-numbered?><book xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
<info>
<title>Business Resource Planner Guide</title><subtitle>
	For Red Hat JBoss BPM Suite 7.0
	<para>Limited Availability Beta Build 2</para>
</subtitle>

<date>2017-10-27</date>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Author_Group.xml"/>
<productname>Red Hat JBoss BPM Suite</productname>
<productnumber>7.0</productnumber>
<abstract>
	<para>A guide to using API's in Red Hat JBoss BPM Suite for developers.</para>
</abstract>
<xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="Common_Content/Legal_Notice.xml"/>
</info>
<preface>
<title>Preface</title>
<simpara>Red_Hat Customer_Content_Services &lt;<link xlink:href="mailto:brms-docs@redhat.com">brms-docs@redhat.com</link>&gt;; Emily Murphy; Gemma Sheldon; Michele Haglund; Stetson Robinson; Vidya Iyengar</simpara>
</preface>
<chapter xml:id="productintroduction" remap="_productintroduction">
<title>Red Hat JBoss Business Resource Planner Introduction</title>
<section xml:id="productintroductionoverview" remap="_productintroductionoverview">
<title>What is Red Hat JBoss Business Resource Planner</title>
<simpara><emphasis>Red Hat JBoss Business Resource Planner</emphasis> is a lightweight, embeddable planning engine that optimizes planning problems.
It helps normal Java™ programmers solve planning problems efficiently, and it combines optimization heuristics and metaheuristics with very efficient score calculations.</simpara>
<simpara>Red Hat JBoss Business Resource Planner helps solve various use cases like the following:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Employee/Patient Rosters</emphasis>. It helps create timetables for nurses and keeps track of patient bed management.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Educational Timetables</emphasis>. It helps schedule lessons, courses, exams, and conference presentations.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Shop Schedules</emphasis>: It tracks car assembly lines, machine queue planning, and workforce task planning.</simpara>
</listitem>
<listitem>
<simpara><emphasis>Cutting Stock</emphasis>: It minimizes waste by reducing the consumption of resources such as paper and steel.</simpara>
</listitem>
</itemizedlist>
<simpara>Every organization faces planning problems; that is, they provide products and services with a limited set of constrained resources (employees, assets, time, and money).</simpara>
<figure>
<title>Use Case Overview</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerIntroduction/WhatIsOptaPlanner/useCaseOverview.png"/>
</imageobject>
<textobject><phrase>useCaseOverview</phrase></textobject>
</mediaobject>
</figure>
<simpara>Red Hat JBoss Business Resource Planner is open source software under the Apache Software License 2.0.
It is 100% pure Java™ and runs on any Java virtual machine.</simpara>
</section>
<section xml:id="runTheExamplesInAnIDE">
<title>Download Red Hat JBoss Business Resource Planner</title>
<simpara>Red Hat JBoss Business Resource Planner is production ready.
The API is stable but backward incompatible changes can occur.
With the recipe called <link xlink:href="https://github.com/droolsjbpm/optaplanner/blob/master/optaplanner-distribution/src/main/assembly/filtered-resources/UpgradeFromPreviousVersionRecipe.txt">UpgradeFromPreviousVersionRecipe.txt</link>, you can easily upgrade to a newer version and quickly deal with any backwards incompatible changes.
This recipe file is included in every release.</simpara>
<orderedlist numeration="arabic">
<title>Procedure: Get the release ZIP and run the examples</title>
<listitem>
<simpara>Navigate to the <link xlink:href="https://access.redhat.com">Red Hat Customer Portal</link> and log in with your user credentials.</simpara>
</listitem>
<listitem>
<simpara>Select <emphasis role="strong">Downloads</emphasis> → <emphasis role="strong">Red Hat JBoss Middleware</emphasis> → <emphasis role="strong">Download Software</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Products</emphasis> drop-down menu, select <emphasis role="strong">BPM Suite</emphasis> or <emphasis role="strong">BRMS Platform</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>From the <emphasis role="strong">Version</emphasis> drop-down menu, select the product version <emphasis role="strong">7.0</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Select the <emphasis role="strong">Standalone</emphasis> or <emphasis role="strong">Deployable</emphasis> file and then click <emphasis role="strong">download</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Unzip the files.</simpara>
</listitem>
<listitem>
<simpara>Open the directory <literal>examples</literal> and run the following script:</simpara>
<simpara>Linux or Mac:</simpara>
<screen>$ cd examples
$ ./runExamples.sh</screen>
<simpara>Windows:</simpara>
<screen>$ cd examples
$ runExamples.bat</screen>
</listitem>
</orderedlist>
<figure>
<title>Download Red Hat JBoss Business Resource Planner</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerIntroduction/DownloadAndRunTheExamples/distributionZipProductized.png"/>
</imageobject>
<textobject><phrase>distributionZipProductized</phrase></textobject>
</mediaobject>
</figure>
<simpara>The Examples GUI application will open.
Just pick an example:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerIntroduction/DownloadAndRunTheExamples/plannerExamplesAppScreenshot.png"/>
</imageobject>
<textobject><phrase>plannerExamplesAppScreenshot</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Red Hat JBoss Business Resource Planner itself has no GUI dependencies.
It runs just as well on a server or a mobile JVM as it does on the desktop.</simpara>
</note>
</section>
<section xml:id="productintroductionexamples" remap="_productintroductionexamples">
<title>Run the Examples</title>
<orderedlist numeration="arabic">
<title>Procedure: To run the examples in your favorite IDE:</title>
<listitem>
<simpara>Configure your IDE:</simpara>
<itemizedlist>
<listitem>
<simpara>In IntelliJ and NetBeans, just open the file <literal>examples/sources/pom.xml</literal> as a new project, the Maven integration will take care of the rest.</simpara>
</listitem>
<listitem>
<simpara>In Eclipse, open a new project for the directory <literal>examples/sources</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add all the JARs to the classpath from the directory <literal>binaries</literal> and the directory <literal>examples/binaries</literal> , except for the file <literal>examples/binaries/optaplanner-examples-*.jar</literal>.</simpara>
</listitem>
<listitem>
<simpara>Add the Java source directory <literal>src/main/java</literal> and the Java resources directory <literal>src/main/resources</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Next, create a run configuration:</simpara>
<itemizedlist>
<listitem>
<simpara>Main class: <literal>org.optaplanner.examples.app.OptaPlannerExamplesApp</literal></simpara>
</listitem>
<listitem>
<simpara>VM parameters (optional): <literal>-Xmx512M -server</literal></simpara>
</listitem>
<listitem>
<simpara>Working directory: <literal>examples</literal> (this is the directory that contains the directory <literal>data</literal>)</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Run that run configuration.</simpara>
</listitem>
</orderedlist>
<orderedlist numeration="arabic">
<title>Procedure: Use Red Hat JBoss Business Resource Planner with Maven, Gradle, Ivy, Buildr or Ant:</title>
<listitem>
<simpara>Get the Red Hat JBoss Business Resource Planner JARs at <link xlink:href="http://search.maven.org/#search|ga|1|org.drools.planner">the Central Repository</link> (and also at <link xlink:href="https://repository.jboss.org/nexus/index.html#nexus-search;gav~org.drools.planner">the JBoss Nexus Repository</link>).</simpara>
</listitem>
<listitem>
<simpara>If you use Maven, add a dependency to <literal>optaplanner-core</literal> in your project’s <literal>pom.xml</literal> :</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;dependency&gt;
      &lt;groupId&gt;org.optaplanner&lt;/groupId&gt;
      &lt;artifactId&gt;optaplanner-core&lt;/artifactId&gt;
      &lt;version&gt;...&lt;/version&gt;
  &lt;/dependency&gt;</programlisting>
<simpara>To identify the latest version, check <link xlink:href="http://search.maven.org/#search|ga|1|org.drools.planner">the Central Repository</link>.
This is similar for Gradle, Ivy, and Buildr.</simpara>
</listitem>
<listitem>
<simpara>If you’re still using Ant (without Ivy), copy all the JARs from the downloaded ZIP’s <literal>binaries</literal> directory and manually verify that your classpath doesn’t contain duplicate JARs.</simpara>
</listitem>
</orderedlist>
<note>
<simpara>The downloaded ZIP’s <literal>binaries</literal> directory contains far more JARs then <literal>optaplanner-core</literal> actually uses.
It also contains the JARs used by other modules, such as <literal>optaplanner-benchmark</literal>.</simpara>
<simpara>Check the Maven repository <literal>pom.xml</literal> files to determine the minimal dependency set for a specific version of a specific module.</simpara>
</note>
<note>
<simpara>Red Hat JBoss Business Resource Planner will be known as Planner for the rest of this book.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="quickStart">
<title>Getting Started: A Cloud Balancing Demonstration</title>
<section xml:id="cloudBalancingTutorial">
<title>Cloud Balancing Tutorial</title>
<section xml:id="cloudBalancingProblemDescription">
<title>Problem Description</title>
<simpara>Suppose your company owns a number of cloud computers and needs to run a number of processes on those computers.
Assign each process to a computer.</simpara>
<simpara>The following hard constraints must be fulfilled:</simpara>
<itemizedlist>
<listitem>
<simpara>Every computer must be able to handle the minimum hardware requirements of the sum of its processes:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">CPU capacity</emphasis>: The CPU power of a computer must be at least the sum of the CPU power required by the processes assigned to that computer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Memory capacity</emphasis>: The RAM memory of a computer must be at least the sum of the RAM memory required by the processes assigned to that computer.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Network capacity</emphasis>: The network bandwidth of a computer must be at least the sum of the network bandwidth required by the processes assigned to that computer.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>The following soft constraints should be optimized:</simpara>
<itemizedlist>
<listitem>
<simpara>Each computer that has one or more processes assigned, incurs a maintenance cost (which is fixed per computer).</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Cost</emphasis>: Minimize the total maintenance cost.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>This problem is a form of <emphasis>bin packing</emphasis>.
The following is a simplified example, in which we assign four processes to two computers with two constraints (CPU and RAM) with a simple algorithm:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/QuickStart/CloudBalancingTutorial/cloudBalanceUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>cloudBalanceUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The simple algorithm used here is the <emphasis>First Fit Decreasing</emphasis> algorithm, which assigns the bigger processes first and assigns the smaller processes to the remaining space.
As you can see, it is not optimal, as it does not leave enough room to assign the yellow process <literal>D</literal>.</simpara>
<simpara>Planner does find the more optimal solution by using additional, smarter algorithms.
It also scales: both in data (more processes, more computers) and constraints (more hardware requirements, other constraints).
So let’s see how Planner can be used in this scenario.</simpara>
<simpara>Here’s an executive summary of this example and <link linkend="machineReassignment">an advanced implementation with more constraints</link>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/QuickStart/CloudBalancingTutorial/cloudOptimizationValueProposition.png" align="center"/>
</imageobject>
<textobject><phrase>cloudOptimizationValueProposition</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="cloudBalancingProblemSize">
<title>Problem Size</title>
<table frame="all" rowsep="1" colsep="1">
<title>Cloud Balancing Problem Size</title>
<tgroup cols="4">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="25*"/>
<colspec colname="col_3" colwidth="25*"/>
<colspec colname="col_4" colwidth="25*"/>
<thead>
<row>
<entry align="left" valign="top">Problem Size</entry>
<entry align="left" valign="top">Computers</entry>
<entry align="left" valign="top">Processes</entry>
<entry align="left" valign="top">Search Space</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara>2computers-6processes</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>6</simpara></entry>
<entry align="left" valign="top"><simpara>64</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>3computers-9processes</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>9</simpara></entry>
<entry align="left" valign="top"><simpara>10^4</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>4computers-012processes</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>12</simpara></entry>
<entry align="left" valign="top"><simpara>10^7</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>100computers-300processes</simpara></entry>
<entry align="left" valign="top"><simpara>100</simpara></entry>
<entry align="left" valign="top"><simpara>300</simpara></entry>
<entry align="left" valign="top"><simpara>10^600</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>200computers-600processes</simpara></entry>
<entry align="left" valign="top"><simpara>200</simpara></entry>
<entry align="left" valign="top"><simpara>600</simpara></entry>
<entry align="left" valign="top"><simpara>10^1380</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>400computers-1200processes</simpara></entry>
<entry align="left" valign="top"><simpara>400</simpara></entry>
<entry align="left" valign="top"><simpara>1200</simpara></entry>
<entry align="left" valign="top"><simpara>10^3122</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>800computers-2400processes</simpara></entry>
<entry align="left" valign="top"><simpara>800</simpara></entry>
<entry align="left" valign="top"><simpara>2400</simpara></entry>
<entry align="left" valign="top"><simpara>10^6967</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
</section>
<section xml:id="cloudBalancingDomainModel">
<title>Using the Domain Model</title>
<section xml:id="cloudBalancingDomainModelDesign">
<title>Domain Model Design</title>
<simpara>Using a <link linkend="domainModelingGuide">domain model</link> helps determine which classes are planning entities and which of their properties are planning variables. It also helps to simplify contraints, improve performance, and increase flexibility for future needs.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Draw a class diagram of your domain model.</simpara>
</listitem>
<listitem>
<simpara>Normalize it to remove duplicate data.</simpara>
</listitem>
<listitem>
<simpara>Write down some sample instances for each class.</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Computer</literal>: represents a computer with certain hardware and maintenance costs.</simpara>
<simpara>In this example, the sample instances for the <literal>Computer</literal> class are: <literal>cpuPower</literal>, <literal>memory</literal>, <literal>networkBandwidth</literal>, <literal>cost</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>Process</literal>: represents a process with a demand. Needs to be assigned to a <literal>Computer</literal> by Planner.</simpara>
<simpara>Sample instances for <literal>Process</literal> are: <literal>requiredCpuPower</literal>, <literal>requiredMemory</literal>, and <literal>requiredNetworkBandwidth</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>CloudBalance</literal>: represents a problem. Contains every <literal>Computer</literal> and <literal>Process</literal> for a certain data set.</simpara>
<simpara>The sample instance for <literal>CloudBalance</literal> is <literal>score</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Determine which relationships (or fields) change during planning.</simpara>
<itemizedlist>
<listitem>
<simpara>Planning entity: the class (or classes) that changes during solving. In this example, it is the class <literal>Process</literal>.</simpara>
</listitem>
<listitem>
<simpara>Planning variable: the property (or properties) of a planning entity class that changes during solving. In this example, it is the property <literal>computer</literal> on the class <literal>Process</literal>.</simpara>
</listitem>
<listitem>
<simpara>Planning solution: the class that represents a data set and contains all planning entities. In this example that is the class <literal>CloudBalance</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>In the UML class diagram below, the Planner concepts are already annotated:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/QuickStart/CloudBalancingDomainModel/cloudBalanceClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>cloudBalanceClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="cloudBalancingDomainModelImplementation">
<title>Domain Model Implementation</title>
<section xml:id="cloudBalancingClassComputer">
<title>The <literal>Computer</literal> Class</title>
<simpara>The <literal>Computer</literal> class is a POJO (Plain Old Java Object). Usually, you will have more of this kind of classes with input data.</simpara>
<example>
<title>CloudComputer.java</title>
<programlisting language="java" linenumbering="unnumbered">public class CloudComputer ... {

    private int cpuPower;
    private int memory;
    private int networkBandwidth;
    private int cost;

    ... // getters
}</programlisting>
</example>
</section>
<section xml:id="cloudBalancingClassProcess">
<title>The <literal>Process</literal> Class</title>
<simpara>The <literal>Process</literal> class is particularly important. It is the class that is modified during solving.</simpara>
<simpara>We need to tell Planner that it can change the property <literal>computer</literal>. To do this:
. Annotate the class with <literal>@PlanningEntity</literal>.
. Annotate the getter <literal>getComputer()</literal> with <literal>@PlanningVariable</literal>.</simpara>
<simpara>Of course, the property <literal>computer</literal> needs a setter too, so Planner can change it during solving.</simpara>
<example>
<title>CloudProcess.java</title>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity(...)
public class CloudProcess ... {

    private int requiredCpuPower;
    private int requiredMemory;
    private int requiredNetworkBandwidth;

    private CloudComputer computer;

    ... // getters

    @PlanningVariable(valueRangeProviderRefs = {"computerRange"})
    public CloudComputer getComputer() {
        return computer;
    }

    public void setComputer(CloudComputer computer) {
        computer = computer;
    }

    // ************************************************************************
    // Complex methods
    // ************************************************************************

    ...

}</programlisting>
</example>
<itemizedlist>
<listitem>
<simpara>Planner needs to know which values it can choose from to assign to the property <literal>computer</literal>. Those values are retrieved from the method <literal>CloudBalance.getComputerList()</literal> on the planning solution, which returns a list of all computers in the current data set.</simpara>
</listitem>
<listitem>
<simpara>The <literal>@PlanningVariable</literal>'s <literal>valueRangeProviderRefs</literal> parameter on <literal>CloudProcess.getComputer()</literal> needs to match with the <literal>@ValueRangeProvider</literal>'s <literal>id</literal> on CloudBalance.getComputerList().</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Instead of getter annotations, it is also possible to use <link linkend="annotationAlternatives">field annotations</link>.</simpara>
</note>
</section>
<section xml:id="cloudBalancingClassCloudBalance">
<title>The <literal>CloudBalance</literal> Class</title>
<simpara>The <literal>CloudBalance</literal> class has a <emphasis><phrase role="path">@PlanningSolution</phrase></emphasis>
 annotation.
* It holds a list of all computers and processes.
* It represents both the planning problem and (if it’s initialized) the planning solution.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Planner needs to retrieve the collection of processes that it can change, therefore we annotate the getter <literal>getProcessList()</literal> with <literal>@PlanningEntityCollectionProperty</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>CloudBalance</literal> class also has a <literal>@PlanningScore</literal> annotated property <literal>score</literal>, which is the <literal>Score</literal> of that solution in its current state.
Planner automatically updates it when it calculates a <literal>Score</literal> for a solution instance and therefore it needs a setter.</simpara>
</listitem>
<listitem>
<simpara>Especially for score calculation with Drools, the property <literal>computerList</literal> needs to be annotated with a <literal>@ProblemFactCollectionProperty</literal> so the computers are known to it.</simpara>
</listitem>
</orderedlist>
<example>
<title>CloudBalance.java</title>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class CloudBalance ... {

    private List&lt;CloudComputer&gt; computerList;

    private List&lt;CloudProcess&gt; processList;

    private HardSoftScore score;

    @ValueRangeProvider(id = "computerRange")
    @ProblemFactCollectionProperty
    public List&lt;CloudComputer&gt; getComputerList() {
        return computerList;
    }

    @PlanningEntityCollectionProperty
    public List&lt;CloudProcess&gt; getProcessList() {
        return processList;
    }

    @PlanningScore
    public HardSoftScore getScore() {
        return score;
    }

    public void setScore(HardSoftScore score) {
        this.score = score;
    }

    ...
}</programlisting>
</example>
</section>
</section>
</section>
<section xml:id="cloudBalancingMainMethod">
<title>Run the Cloud Balancing Hello World</title>
<orderedlist numeration="arabic">
<listitem>
<simpara><link linkend="runTheExamplesInAnIDE">Download and configure the examples in your preferred IDE.</link></simpara>
</listitem>
<listitem>
<simpara>Create a run configuration with the following main class: <literal>org.optaplanner.examples.cloudbalancing.app.CloudBalancingHelloWorld</literal></simpara>
<simpara>By default, the Cloud Balancing Hello World is configured to run for 120 seconds.</simpara>
</listitem>
</orderedlist>
<simpara>It will execute the following code:</simpara>
<example>
<title>CloudBalancingHelloWorld.java</title>
<programlisting language="java" linenumbering="unnumbered">public class CloudBalancingHelloWorld {

    public static void main(String[] args) {
        // Build the Solver
        SolverFactory&lt;CloudBalance&gt; solverFactory = SolverFactory.createFromXmlResource(
                "org/optaplanner/examples/cloudbalancing/solver/cloudBalancingSolverConfig.xml");
        Solver&lt;CloudBalance&gt; solver = solverFactory.buildSolver();

        // Load a problem with 400 computers and 1200 processes
        CloudBalance unsolvedCloudBalance = new CloudBalancingGenerator().createCloudBalance(400, 1200);

        // Solve the problem
        CloudBalance solvedCloudBalance = solver.solve(unsolvedCloudBalance);

        // Display the result
        System.out.println("\nSolved cloudBalance with 400 computers and 1200 processes:\n"
                + toDisplayString(solvedCloudBalance));
    }

    ...
}</programlisting>
</example>
<simpara>The code example does the following:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Build the <literal>Solver</literal> based on a solver configuration (in this case <link linkend="solverConfigurationByXML">an XML file</link>, <literal>cloudBalancingSolverConfig.xml</literal>, from the classpath).</simpara>
<simpara>Building the <literal>Solver</literal> is the most complicated part of this procedure. For more detail, see <link linkend="cloudBalancingSolverConfiguration">Solver Configuration</link>.</simpara>
<programlisting language="java" linenumbering="unnumbered">        SolverFactory&lt;CloudBalance&gt; solverFactory = SolverFactory.createFromXmlResource(
                "org/optaplanner/examples/cloudbalancing/solver/cloudBalancingSolverConfig.xml");
        Solver solver&lt;CloudBalance&gt; = solverFactory.buildSolver();</programlisting>
</listitem>
<listitem>
<simpara>Load the problem.</simpara>
<simpara><literal>CloudBalancingGenerator</literal> generates a random problem: you will replace this with a class that loads a real problem, for example from a database.</simpara>
<programlisting language="java" linenumbering="unnumbered">        CloudBalance unsolvedCloudBalance = new CloudBalancingGenerator().createCloudBalance(400, 1200);</programlisting>
</listitem>
<listitem>
<simpara>Solve the problem.</simpara>
<programlisting language="java" linenumbering="unnumbered">        CloudBalance solvedCloudBalance = solver.solve(unsolvedCloudBalance);</programlisting>
</listitem>
<listitem>
<simpara>Display the result.</simpara>
<programlisting language="java" linenumbering="unnumbered">        System.out.println("\nSolved cloudBalance with 400 computers and 1200 processes:\n"
                + toDisplayString(solvedCloudBalance));</programlisting>
</listitem>
</orderedlist>
</section>
<section xml:id="cloudBalancingSolverConfiguration">
<title>Solver Configuration</title>
<simpara>Take a look at the solver configuration:</simpara>
<example>
<title>cloudBalancingSolverConfig.xml</title>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;solver&gt;
  &lt;!-- Domain model configuration --&gt;
  &lt;scanAnnotatedClasses/&gt;

  &lt;!-- Score configuration --&gt;
  &lt;scoreDirectorFactory&gt;
    &lt;easyScoreCalculatorClass&gt;org.optaplanner.examples.cloudbalancing.optional.score.CloudBalancingEasyScoreCalculator&lt;/easyScoreCalculatorClass&gt;
    &lt;!--&lt;scoreDrl&gt;org/optaplanner/examples/cloudbalancing/solver/cloudBalancingScoreRules.drl&lt;/scoreDrl&gt;--&gt;
  &lt;/scoreDirectorFactory&gt;

  &lt;!-- Optimization algorithms configuration --&gt;
  &lt;termination&gt;
    &lt;secondsSpentLimit&gt;30&lt;/secondsSpentLimit&gt;
  &lt;/termination&gt;
&lt;/solver&gt;</programlisting>
</example>
<simpara>This solver configuration consists of three parts:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Domain model configuration</emphasis>: <emphasis>What can Planner change?</emphasis></simpara>
<simpara>We need to make Planner aware of our domain classes. In this configuration, it will automatically scan all classes in your classpath (for a <literal>@PlanningEntity</literal> or <literal>@PlanningSolution</literal> annotation):</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scanAnnotatedClasses/&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Score configuration</emphasis>: <emphasis>How should Planner optimize the planning variables? What is our goal?</emphasis></simpara>
<simpara>Since we have hard and soft constraints, we use a <literal>HardSoftScore</literal>. But we need to tell Planner how to calculate the score, depending on our business requirements. Further down, we will look into two alternatives to calculate the score: using an easy Java implementation, or using Drools DRL.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;easyScoreCalculatorClass&gt;org.optaplanner.examples.cloudbalancing.optional.score.CloudBalancingEasyScoreCalculator&lt;/easyScoreCalculatorClass&gt;
    &lt;!--&lt;scoreDrl&gt;org/optaplanner/examples/cloudbalancing/solver/cloudBalancingScoreRules.drl&lt;/scoreDrl&gt;--&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Optimization algorithms configuration</emphasis>: <emphasis>How should Planner optimize it?</emphasis></simpara>
<simpara>In this case, we use the default <link linkend="optimizationAlgorithms">optimization algorithms</link> (because no explicit optimization algorithms are configured) for 30 seconds:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;secondsSpentLimit&gt;30&lt;/secondsSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>Planner should get a good result in seconds (and even in less than 15 milliseconds with <link linkend="realTimePlanning">real-time planning</link>), but the more time it has, the better the result will be. Advanced use cases might use a different <link linkend="termination">termination criteria</link> than a hard time limit.</simpara>
<simpara>The default algorithms will already easily surpass human planners and most in-house implementations.
Use the <link linkend="benchmarker">Benchmarker</link> to <link linkend="powerTweaking">power tweak</link> to get even better results.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cloudBalancingScoreConfiguration">
<title>Score Configuration</title>
<simpara>Planner will search for the <literal>Solution</literal> with the highest <literal>Score</literal>.
This example uses a <literal>HardSoftScore</literal>, which means Planner will look for the solution with no hard constraints broken (fulfill hardware requirements) and as little as possible soft constraints broken (minimize maintenance cost).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/QuickStart/CloudBalancingScoreConfiguration/scoreComparisonCloudBalancing.png" align="center"/>
</imageobject>
<textobject><phrase>scoreComparisonCloudBalancing</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Of course, Planner needs to be told about these domain-specific score constraints.
There are several ways to implement such a score function:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="cloudBalancingEasyJavaScoreConfiguration">Easy Java</link></simpara>
</listitem>
<listitem>
<simpara>Incremental Java</simpara>
</listitem>
<listitem>
<simpara><link linkend="cloudBalancingDroolsScoreConfiguration">Drools</link></simpara>
</listitem>
</itemizedlist>
<section xml:id="cloudBalancingEasyJavaScoreConfiguration">
<title>Easy Java Score Configuration</title>
<simpara>One way to define a score function is to implement the interface <literal>EasyScoreCalculator</literal> in plain Java.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;easyScoreCalculatorClass&gt;org.optaplanner.examples.cloudbalancing.optional.score.CloudBalancingEasyScoreCalculator&lt;/easyScoreCalculatorClass&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>Just implement the <literal>calculateScore(Solution)</literal> method to return a <literal>HardSoftScore</literal> instance.</simpara>
<example>
<title>CloudBalancingEasyScoreCalculator.java</title>
<programlisting language="java" linenumbering="unnumbered">public class CloudBalancingEasyScoreCalculator implements EasyScoreCalculator&lt;CloudBalance&gt; {

    /**
     * A very simple implementation. The double loop can easily be removed by using Maps as shown in
     * {@link CloudBalancingMapBasedEasyScoreCalculator#calculateScore(CloudBalance)}.
     */
    public HardSoftScore calculateScore(CloudBalance cloudBalance) {
        int hardScore = 0;
        int softScore = 0;
        for (CloudComputer computer : cloudBalance.getComputerList()) {
            int cpuPowerUsage = 0;
            int memoryUsage = 0;
            int networkBandwidthUsage = 0;
            boolean used = false;

            // Calculate usage
            for (CloudProcess process : cloudBalance.getProcessList()) {
                if (computer.equals(process.getComputer())) {
                    cpuPowerUsage += process.getRequiredCpuPower();
                    memoryUsage += process.getRequiredMemory();
                    networkBandwidthUsage += process.getRequiredNetworkBandwidth();
                    used = true;
                }
            }

            // Hard constraints
            int cpuPowerAvailable = computer.getCpuPower() - cpuPowerUsage;
            if (cpuPowerAvailable &lt; 0) {
                hardScore += cpuPowerAvailable;
            }
            int memoryAvailable = computer.getMemory() - memoryUsage;
            if (memoryAvailable &lt; 0) {
                hardScore += memoryAvailable;
            }
            int networkBandwidthAvailable = computer.getNetworkBandwidth() - networkBandwidthUsage;
            if (networkBandwidthAvailable &lt; 0) {
                hardScore += networkBandwidthAvailable;
            }

            // Soft constraints
            if (used) {
                softScore -= computer.getCost();
            }
        }
        return HardSoftScore.valueOf(hardScore, softScore);
    }

}</programlisting>
</example>
<simpara>Even if we optimize the code above to use <literal>Map</literal>s to iterate through the <literal>processList</literal> only once, <emphasis>it is still slow</emphasis> because it does not do <link linkend="incrementalScoreCalculation">incremental score calculation</link>.
To fix that, either use incremental Java score calculation or Drools score calculation.</simpara>
</section>
<section xml:id="cloudBalancingDroolsScoreConfiguration">
<title>Drools Score Configuration</title>
<simpara>Drools score calculation uses incremental calculation, where every score constraint is written as one or more score rules.</simpara>
<simpara>Using the Drools rule engine for score calculation, allows you to integrate with other Drools technologies, such as decision tables (XLS or web based), the KIE Workbench, …​</simpara>
<simpara><emphasis role="strong">Prerequisite</emphasis>
To use the Drools rule engine as a score function, simply add a <literal>scoreDrl</literal> resource in the classpath:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;org/optaplanner/examples/cloudbalancing/solver/cloudBalancingScoreRules.drl&lt;/scoreDrl&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>We want to make sure that all computers have enough CPU, RAM and network bandwidth to support all their processes, so we make these hard constraints:</simpara>
<example>
<title>cloudBalancingScoreRules.drl - Hard Constraints</title>
<screen>...

import org.optaplanner.examples.cloudbalancing.domain.CloudBalance;
import org.optaplanner.examples.cloudbalancing.domain.CloudComputer;
import org.optaplanner.examples.cloudbalancing.domain.CloudProcess;

global HardSoftScoreHolder scoreHolder;

// ############################################################################
// Hard constraints
// ############################################################################

rule "requiredCpuPowerTotal"
    when
        $computer : CloudComputer($cpuPower : cpuPower)
        accumulate(
            CloudProcess(
                computer == $computer,
                $requiredCpuPower : requiredCpuPower);
            $requiredCpuPowerTotal : sum($requiredCpuPower);
            $requiredCpuPowerTotal &gt; $cpuPower
        )
    then
        scoreHolder.addHardConstraintMatch(kcontext, $cpuPower - $requiredCpuPowerTotal);
end

rule "requiredMemoryTotal"
    ...
end

rule "requiredNetworkBandwidthTotal"
    ...
end</screen>
</example>
</listitem>
<listitem>
<simpara>If those constraints are met, we want to minimize the maintenance cost, so we add that as a soft constraint:</simpara>
<example>
<title>cloudBalancingScoreRules.drl - Soft Constraints</title>
<screen>// ############################################################################
// Soft constraints
// ############################################################################

rule "computerCost"
    when
        $computer : CloudComputer($cost : cost)
        exists CloudProcess(computer == $computer)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, - $cost);
end</screen>
</example>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="cloudBalancingBeyondThisTutorial">
<title>Beyond this Tutorial</title>
<simpara>Now that this simple example works, try going further.
Enrich the domain model and add extra constraints such as these:</simpara>
<itemizedlist>
<listitem>
<simpara>Each <literal>Process</literal> belongs to a <literal>Service</literal>. A computer might crash, so processes running the same service should be assigned to different computers.</simpara>
</listitem>
<listitem>
<simpara>Each <literal>Computer</literal> is located in a <literal>Building</literal>. A building might burn down, so processes of the same services should be assigned to computers in different buildings.</simpara>
</listitem>
</itemizedlist>
</section>
</chapter>
<chapter xml:id="useCasesAndExamples">
<title>Use Cases and Examples</title>
<section xml:id="examplesOverview">
<title>Examples Overview</title>
<simpara>Planner has several examples. In this manual we explain mainly using the <emphasis>n</emphasis> queens example and cloud balancing example. So it is advisable to read at least those sections.</simpara>
<simpara>The <literal>Competition?</literal> column in the following table identifies an example as being either realistic or unrealistic. A <emphasis>realistic competition</emphasis> is <emphasis>an official, independent competition</emphasis>:</simpara>
<itemizedlist>
<listitem>
<simpara>that clearly defines a real-word use case.</simpara>
</listitem>
<listitem>
<simpara>with real-world constraints.</simpara>
</listitem>
<listitem>
<simpara>with multiple, real-world datasets.</simpara>
</listitem>
<listitem>
<simpara>that expects reproducible results within a specific time limit on specific hardware.</simpara>
</listitem>
<listitem>
<simpara>that has had serious participation from the academic and/or enterprise Operations Research community.</simpara>
</listitem>
</itemizedlist>
<simpara>These realistic competitions provide an objective comparison of Planner with competitive software and academic research.</simpara>
<simpara>The source code of all these examples is available in the distribution zip under <emphasis><phrase role="path">examples/sources</phrase></emphasis>
and also in git under <emphasis><phrase role="path">optaplanner/optaplanner-examples</phrase></emphasis>.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Examples Overview</title>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<thead>
<row>
<entry align="left" valign="top">Example</entry>
<entry align="left" valign="top">Domain</entry>
<entry align="left" valign="top">Size</entry>
<entry align="left" valign="top">Competition?</entry>
<entry align="left" valign="top">Special features used</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top"><simpara><link linkend="nQueens">N queens</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>256</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 256</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^616</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Pointless (<link xlink:href="http://en.wikipedia.org/wiki/Eight_queens_puzzle#Explicit_solutions">cheatable</link>)</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><simpara>None</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="cloudBalancing">Cloud balancing</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>2400</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 800</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^6967</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>No</simpara>
</listitem>
<listitem>
<simpara>Defined by us</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="realTimePlanning">Real-time planning</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="tsp">Traveling salesman</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 chained variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>980</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 980</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^2927</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Unrealistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://www.math.uwaterloo.ca/tsp/">TSP web</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="realTimePlanning">Real-time planning</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="dinnerParty">Dinner party</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>144</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 72</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^310</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Unrealistic</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Decision Table spreadsheet (XLS) for score constraints</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="tennis">Tennis club scheduling</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>72</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 7</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^60</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>No</simpara>
</listitem>
<listitem>
<simpara>Defined by us</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="fairnessScoreConstraints">Fairness score constraints</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="immovablePlanningEntities">Immovable entities</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="meetingScheduling">Meeting scheduling</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>2 variables</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>10</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 320 and ⇐ <literal>5</literal></simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^320</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>No</simpara>
</listitem>
<listitem>
<simpara>Defined by us</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="timeGrainPattern">TimeGrain pattern</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="curriculumCourse">Course timetabling</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>2 variables</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>434</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 25 and ⇐ <literal>20</literal></simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^1171</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Realistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://www.cs.qub.ac.uk/itc2007/curriculmcourse/course_curriculm_index.htm">ITC 2007 track 3</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="immovablePlanningEntities">Immovable entities</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="machineReassignment">Machine reassignment</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>50000</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 5000</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^184948</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Nearly realistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://challenge.roadef.org/2012/en/">ROADEF 2012</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="realTimePlanning">Real-time planning</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="vehicleRouting">Vehicle routing</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 chained variable</simpara>
</listitem>
<listitem>
<simpara>1 shadow entity class</simpara>
</listitem>
<listitem>
<simpara>1 automatic shadow variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>134</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 141</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^285</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Unrealistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://neo.lcc.uma.es/vrp/">VRP web</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="shadowVariable">Shadow variable</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="realTimePlanning">Real-time planning</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="nearbySelection">Nearby selection</link></simpara>
</listitem>
<listitem>
<simpara>Real road distances</simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="vehicleRouting">Vehicle routing</link> with time windows</simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>All of Vehicle routing</simpara>
</listitem>
<listitem>
<simpara>1 shadow variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>1000</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 1250</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^3000</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Unrealistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://neo.lcc.uma.es/vrp/">VRP web</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>All of Vehicle routing</simpara>
</listitem>
<listitem>
<simpara>Custom <link linkend="customVariableListener">VariableListener</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="projectJobScheduling">Project job scheduling</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>2 variables</simpara>
</listitem>
<listitem>
<simpara>1 shadow variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>640</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ ? and ⇐ <literal>?</literal></simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>?</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Nearly realistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://gent.cs.kuleuven.be/mista2013challenge/">MISTA 2013</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="bendableScore">Bendable score</link></simpara>
</listitem>
<listitem>
<simpara>Custom <link linkend="customVariableListener">VariableListener</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="valueRangeFactory">ValueRangeFactory</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="bedAllocation">Hospital bed planning</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 nullable variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>2750</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 471</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^6851</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Unrealistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="https://people.cs.kuleuven.be/~wim.vancroonenburg/pas/">Kaho PAS</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="overconstrainedPlanning">Overconstrained planning</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="taskAssigning">Task assigning</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 chained variable</simpara>
</listitem>
<listitem>
<simpara>1 shadow entity class</simpara>
</listitem>
<listitem>
<simpara>1 automatic shadow variable</simpara>
</listitem>
<listitem>
<simpara>1 shadow variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>500</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 520</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^1384</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>No</simpara>
</listitem>
<listitem>
<simpara>Defined by us</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="bendableScore">Bendable score</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="chainedThroughTimePattern">Chained through time pattern</link></simpara>
</listitem>
<listitem>
<simpara>Custom <link linkend="customVariableListener">VariableListener</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="continuousPlanning">Continuous planning</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="realTimePlanning">Real-time planning</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="examination">Exam timetabling</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>2 entity classes (same hierarchy)</simpara>
</listitem>
<listitem>
<simpara>2 variables</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>1096</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 80 and ⇐ <literal>49</literal></simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^3374</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Realistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://www.cs.qub.ac.uk/itc2007/examtrack/exam_track_index.htm">ITC 2007 track 1</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Custom <link linkend="customVariableListener">VariableListener</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="employeeRostering">Employee rostering</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>752</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 50</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^1277</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Realistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://www.kuleuven-kortrijk.be/nrpcompetition">INRC 2010</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="continuousPlanning">Continuous planning</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="realTimePlanning">Real-time planning</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="travelingTournament">Traveling tournament</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>1560</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 78</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^2951</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Unrealistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://mat.gsia.cmu.edu/TOURN/">TTP</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Custom <link linkend="moveListFactory">MoveListFactory</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="cheapTimeScheduling">Cheap time scheduling</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>2 variables</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>500</literal></simpara>
</listitem>
<listitem>
<simpara>Value ⇐ 100 and ⇐ <literal>288</literal></simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^20078</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Nearly realistic</simpara>
</listitem>
<listitem>
<simpara><link xlink:href="http://iconchallenge.insight-centre.org/challenge-energy">ICON Energy</link></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="annotationAlternatives">Field annotations</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="valueRangeFactory">ValueRangeFactory</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><link linkend="investment">Investment</link></simpara></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>1 entity class</simpara>
</listitem>
<listitem>
<simpara>1 variable</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>Entity ⇐ <literal>11</literal></simpara>
</listitem>
<listitem>
<simpara>Value = 1000</simpara>
</listitem>
<listitem>
<simpara>Search space ⇐ <literal>10^4</literal></simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara>No</simpara>
</listitem>
<listitem>
<simpara>Defined by us</simpara>
</listitem>
</itemizedlist></entry>
<entry align="left" valign="top"><itemizedlist>
<listitem>
<simpara><link linkend="valueRangeFactory">ValueRangeFactory</link></simpara>
</listitem>
</itemizedlist></entry>
</row>
</tbody>
</tgroup>
</table>
</section>
<section xml:id="basicExamples">
<title>Basic Examples</title>
<section xml:id="nQueens">
<title>N Queens</title>
<section xml:id="nQueensProblemDescription">
<title>Problem Description</title>
<simpara>Place <emphasis>n</emphasis> queens on a <emphasis>n</emphasis> sized chessboard so that no two queens can attack each other.
The most common <emphasis>n</emphasis> queens puzzle is the eight queens puzzle, with <emphasis>n = 8</emphasis>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/BasicExamples/nQueensScreenshot.png" align="center"/>
</imageobject>
<textobject><phrase>nQueensScreenshot</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Use a chessboard of <emphasis>n</emphasis> columns and <emphasis>n</emphasis> rows.</simpara>
</listitem>
<listitem>
<simpara>Place <emphasis>n</emphasis> queens on the chessboard.</simpara>
</listitem>
<listitem>
<simpara>No two queens can attack each other. A queen can attack any other queen on the same horizontal, vertical or diagonal line.</simpara>
</listitem>
</itemizedlist>
<simpara>This documentation heavily uses the four queens puzzle as the primary example.</simpara>
<simpara>A proposed solution could be:</simpara>
<figure>
<title>A Wrong Solution for the Four Queens Puzzle</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/BasicExamples/partiallySolvedNQueens04Explained.png" align="center"/>
</imageobject>
<textobject><phrase>partiallySolvedNQueens04Explained</phrase></textobject>
</mediaobject>
</figure>
<simpara>The above solution is wrong because queens <literal>A1</literal> and <literal>B0</literal> can attack each other (so can queens <literal>B0</literal> and <literal>D0</literal>). Removing queen <literal>B0</literal> would respect the "no two queens can attack each other" constraint, but would break the "place <emphasis>n</emphasis> queens" constraint.</simpara>
<simpara>Below is a correct solution:</simpara>
<figure>
<title>A Correct Solution for the Four Queens Puzzle</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/BasicExamples/solvedNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>solvedNQueens04</phrase></textobject>
</mediaobject>
</figure>
<simpara>All the constraints have been met, so the solution is correct.</simpara>
<simpara>Note that most <emphasis>n</emphasis> queens puzzles have multiple correct solutions.
We will focus on finding a single correct solution for a given <emphasis>n</emphasis>, not on finding the number of possible correct solutions for a given <emphasis>n</emphasis>.</simpara>
</section>
<section xml:id="nQueensProblemSize">
<title>Problem Size</title>
<screen>4queens   has   4 queens with a search space of    256.
8queens   has   8 queens with a search space of   10^7.
16queens  has  16 queens with a search space of  10^19.
32queens  has  32 queens with a search space of  10^48.
64queens  has  64 queens with a search space of 10^115.
256queens has 256 queens with a search space of 10^616.</screen>
<simpara>The implementation of the <emphasis>n</emphasis> queens example has not been optimized because it functions as a beginner example. Nevertheless, it can easily handle 64 queens.
With a few changes it has been shown to easily handle 5000 queens and more.</simpara>
</section>
<section xml:id="nQueensDomainModel">
<title>Domain Model</title>
<simpara>This example uses the domain model to solve the four queens problem.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Creating a Domain Model</emphasis>
A good domain model will make it easier to understand and solve your planning problem.</simpara>
<simpara>This is the domain model for the <emphasis>n</emphasis> queens example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Column {

    private int index;

    // ... getters and setters
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class Row {

    private int index;

    // ... getters and setters
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class Queen {

    private Column column;
    private Row row;

    public int getAscendingDiagonalIndex() {...}
    public int getDescendingDiagonalIndex() {...}

    // ... getters and setters
}</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Calculating the Search Space.</emphasis></simpara>
<simpara>A <literal>Queen</literal> instance has a <literal>Column</literal> (for example: 0 is column A, 1 is column B, …​) and a <literal>Row</literal> (its row, for example: 0 is row 0, 1 is row 1, …​).</simpara>
<simpara>The ascending diagonal line and the descending diagonal line can be calculated based on the column and the row.</simpara>
<simpara>The column and row indexes start from the upper left corner of the chessboard.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class NQueens {

    private int n;
    private List&lt;Column&gt; columnList;
    private List&lt;Row&gt; rowList;

    private List&lt;Queen&gt; queenList;

    private SimpleScore score;

    // ... getters and setters
}</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Finding the Solution</emphasis></simpara>
<simpara>A single <literal>NQueens</literal> instance contains a list of all <literal>Queen</literal> instances.
It is the <literal>Solution</literal> implementation which will be supplied to, solved by, and retrieved from the Solver.</simpara>
</listitem>
</orderedlist>
<simpara>Notice that in the four queens example, NQueens’s <literal>getN()</literal> method will always return four.</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>A Solution for Four Queens Shown in the Domain Model</title>
<tgroup cols="6">
<colspec colname="col_1" colwidth="55*"/>
<colspec colname="col_2" colwidth="9*"/>
<colspec colname="col_3" colwidth="9*"/>
<colspec colname="col_4" colwidth="9*"/>
<colspec colname="col_5" colwidth="9*"/>
<colspec colname="col_6" colwidth="9*"/>
<thead>
<row>
<entry align="left" valign="top">A solution</entry>
<entry align="left" valign="top">Queen</entry>
<entry align="left" valign="top">columnIndex</entry>
<entry align="left" valign="top">rowIndex</entry>
<entry align="left" valign="top">ascendingDiagonalIndex (columnIndex + rowIndex)</entry>
<entry align="left" valign="top">descendingDiagonalIndex (columnIndex - rowIndex)</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" morerows="3"><informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/BasicExamples/partiallySolvedNQueens04Explained.png" align="center"/>
</imageobject>
<textobject><phrase>partiallySolvedNQueens04Explained</phrase></textobject>
</mediaobject>
</informalfigure></entry>
<entry align="left" valign="top"><simpara>A1</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">1 (**)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>-1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>B0</simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">0 (*)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">1 (**)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>1</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>C2</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>2</simpara></entry>
<entry align="left" valign="top"><simpara>4</simpara></entry>
<entry align="left" valign="top"><simpara>0</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>D0</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara><emphasis role="strong">0 (*)</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
<entry align="left" valign="top"><simpara>3</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>When two queens share the same column, row or diagonal line, such as (*) and (**), they can attack each other.</simpara>
</section>
</section>
<section xml:id="cloudBalancing">
<title>Cloud Balancing</title>
<simpara>This example is explained in <link linkend="cloudBalancingTutorial">a tutorial</link>.</simpara>
</section>
<section xml:id="tsp">
<title>Traveling Salesman (TSP - Traveling Salesman Problem)</title>
<section xml:id="tspProblemDescription">
<title>Problem Description</title>
<simpara>Given a list of cities, find the shortest tour for a salesman that visits each city exactly once.</simpara>
<simpara>The problem is defined by <link xlink:href="http://en.wikipedia.org/wiki/Travelling_salesman_problem">Wikipedia</link>.
It is <link xlink:href="http://www.math.uwaterloo.ca/tsp/">one of the most intensively studied problems</link> in computational mathematics.
Yet, in the real world, it is often only part of a planning problem, along with other constraints, such as employee shift rostering constraints.</simpara>
</section>
<section xml:id="tspProblemSize">
<title>Problem Size</title>
<screen>dj38     has  38 cities with a search space of   10^58.
europe40 has  40 cities with a search space of   10^62.
st70     has  70 cities with a search space of  10^126.
pcb442   has 442 cities with a search space of 10^1166.
lu980    has 980 cities with a search space of 10^2927.</screen>
</section>
<section xml:id="tspProblemDifficulty">
<title>Problem Difficulty</title>
<simpara>Despite TSP’s simple definition, the problem is surprisingly hard to solve.
Because it is an NP-hard problem (like most planning problems), the optimal solution for a specific problem dataset can change a lot when that problem dataset is slightly altered:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/BasicExamples/tspOptimalSolutionVolatility.png" align="center"/>
</imageobject>
<textobject><phrase>tspOptimalSolutionVolatility</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="dinnerParty">
<title>Dinner Party</title>
<section xml:id="dinnerPartyProblemDescription">
<title>Problem Description</title>
<simpara>Miss Manners is throwing another dinner party.</simpara>
<itemizedlist>
<listitem>
<simpara>This time she invited 144 guests and prepared 12 round tables with 12 seats each.</simpara>
</listitem>
<listitem>
<simpara>Every guest should sit next to someone (left and right) of the opposite gender.</simpara>
</listitem>
<listitem>
<simpara>And that neighbour should have at least one hobby in common with the guest.</simpara>
</listitem>
<listitem>
<simpara>At every table, there should be two politicians, two doctors, two socialites, two coaches, two teachers and two programmers.</simpara>
</listitem>
<listitem>
<simpara>And the two politicians, two doctors, two coaches and two programmers should not be the same kind at a table.</simpara>
</listitem>
</itemizedlist>
<simpara>Drools Expert also has the normal Miss Manners example (which is much smaller) and employs an exhaustive heuristic to solve it.
Planner’s implementation is far more scalable because it uses heuristics to find the best solution and Drools Expert to calculate the score of each solution.</simpara>
</section>
<section xml:id="dinnerPartyProblemSize">
<title>Problem Size</title>
<screen>wedding01 has 18 jobs, 144 guests, 288 hobby practicians, 12 tables and 144 seats with a search space of 10^310.</screen>
</section>
</section>
<section xml:id="tennis">
<title>Tennis Club Scheduling</title>
<section xml:id="tennisProblemDescription">
<title>Problem Description</title>
<simpara>Every week the tennis club has four teams playing round robin against each other.
Assign those four spots to the teams fairly.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Conflict: A team can only play once per day.</simpara>
</listitem>
<listitem>
<simpara>Unavailability: Some teams are unavailable on some dates.</simpara>
</listitem>
</itemizedlist>
<simpara>Medium constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Fair assignment: All teams should play an (almost) equal number of times.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Evenly confrontation: Each team should play against every other team an equal number of times.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="tennisProblemSize">
<title>Problem Size</title>
<screen>munich-7teams has 7 teams, 18 days, 12 unavailabilityPenalties and 72 teamAssignments with a search space of 10^60.</screen>
</section>
<section xml:id="tennisDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/BasicExamples/tennisClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>tennisClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="meetingScheduling">
<title>Meeting Scheduling</title>
<section xml:id="meetingSchedulingProblemDescription">
<title>Problem Description</title>
<simpara>Assign each meeting to a starting time and a room.
Meetings have different durations.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Room conflict: two meetings must not use the same room at the same time.</simpara>
</listitem>
<listitem>
<simpara>Required attendance: A person cannot have two required meetings at the same time.</simpara>
</listitem>
</itemizedlist>
<simpara>Medium constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Preferred attendance: A person cannot have two preferred meetings at the same time, nor a preferred and a required meeting at the same time.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Sooner rather than later: Schedule all meetings as soon as possible.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="meetingSchedulingProblemSize">
<title>Problem Size</title>
<screen>50meetings-160timegrains-5rooms  has  50 meetings, 160 timeGrains and 5 rooms with a search space of 10^145.
100meetings-320timegrains-5rooms has 100 meetings, 320 timeGrains and 5 rooms with a search space of 10^320.</screen>
</section>
</section>
</section>
<section xml:id="realExamples">
<title>Real Examples</title>
<section xml:id="curriculumCourse">
<title>Course Timetabling (ITC 2007 Track 3 - Curriculum Course Scheduling)</title>
<section xml:id="curriculumCourseProblemDescription">
<title>Problem Description</title>
<simpara>Schedule each lecture into a timeslot and into a room.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Teacher conflict: A teacher must not have two lectures in the same period.</simpara>
</listitem>
<listitem>
<simpara>Curriculum conflict: A curriculum must not have two lectures in the same period.</simpara>
</listitem>
<listitem>
<simpara>Room occupancy: two lectures must not be in the same room in the same period.</simpara>
</listitem>
<listitem>
<simpara>Unavailable period (specified per dataset): A specific lecture must not be assigned to a specific period.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Room capacity: A room’s capacity should not be less than the number of students in its lecture.</simpara>
</listitem>
<listitem>
<simpara>Minimum working days: Lectures of the same course should be spread out into a minimum number of days.</simpara>
</listitem>
<listitem>
<simpara>Curriculum compactness: Lectures belonging to the same curriculum should be adjacent to each other (so in consecutive periods).</simpara>
</listitem>
<listitem>
<simpara>Room stability: Lectures of the same course should be assigned to the same room.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is defined by <link xlink:href="http://www.cs.qub.ac.uk/itc2007/curriculmcourse/course_curriculm_index.htm">the International Timetabling Competition 2007 track 3</link>.</simpara>
</section>
<section xml:id="curriculumCourseProblemSize">
<title>Problem Size</title>
<screen>comp01 has 24 teachers,  14 curricula,  30 courses, 160 lectures, 30 periods,  6 rooms and   53 unavailable period constraints with a search space of  10^360.
comp02 has 71 teachers,  70 curricula,  82 courses, 283 lectures, 25 periods, 16 rooms and  513 unavailable period constraints with a search space of  10^736.
comp03 has 61 teachers,  68 curricula,  72 courses, 251 lectures, 25 periods, 16 rooms and  382 unavailable period constraints with a search space of  10^653.
comp04 has 70 teachers,  57 curricula,  79 courses, 286 lectures, 25 periods, 18 rooms and  396 unavailable period constraints with a search space of  10^758.
comp05 has 47 teachers, 139 curricula,  54 courses, 152 lectures, 36 periods,  9 rooms and  771 unavailable period constraints with a search space of  10^381.
comp06 has 87 teachers,  70 curricula, 108 courses, 361 lectures, 25 periods, 18 rooms and  632 unavailable period constraints with a search space of  10^957.
comp07 has 99 teachers,  77 curricula, 131 courses, 434 lectures, 25 periods, 20 rooms and  667 unavailable period constraints with a search space of 10^1171.
comp08 has 76 teachers,  61 curricula,  86 courses, 324 lectures, 25 periods, 18 rooms and  478 unavailable period constraints with a search space of  10^859.
comp09 has 68 teachers,  75 curricula,  76 courses, 279 lectures, 25 periods, 18 rooms and  405 unavailable period constraints with a search space of  10^740.
comp10 has 88 teachers,  67 curricula, 115 courses, 370 lectures, 25 periods, 18 rooms and  694 unavailable period constraints with a search space of  10^981.
comp11 has 24 teachers,  13 curricula,  30 courses, 162 lectures, 45 periods,  5 rooms and   94 unavailable period constraints with a search space of  10^381.
comp12 has 74 teachers, 150 curricula,  88 courses, 218 lectures, 36 periods, 11 rooms and 1368 unavailable period constraints with a search space of  10^566.
comp13 has 77 teachers,  66 curricula,  82 courses, 308 lectures, 25 periods, 19 rooms and  468 unavailable period constraints with a search space of  10^824.
comp14 has 68 teachers,  60 curricula,  85 courses, 275 lectures, 25 periods, 17 rooms and  486 unavailable period constraints with a search space of  10^722.</screen>
</section>
<section xml:id="curriculumCourseDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/curriculumCourseClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>curriculumCourseClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="machineReassignment">
<title>Machine Reassignment (Google ROADEF 2012)</title>
<section xml:id="machineReassignmentProblemDescription">
<title>Problem Description</title>
<simpara>Assign each process to a machine.
All processes already have an original (unoptimized) assignment.
Each process requires an amount of each resource (such as CPU, RAM, …​). This is a more complex version of the Cloud Balancing example.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Maximum capacity: The maximum capacity for each resource for each machine must not be exceeded.</simpara>
</listitem>
<listitem>
<simpara>Conflict: Processes of the same service must run on distinct machines.</simpara>
</listitem>
<listitem>
<simpara>Spread: Processes of the same service must be spread out across locations.</simpara>
</listitem>
<listitem>
<simpara>Dependency: The processes of a service depending on another service must run in the neighborhood of a process of the other service.</simpara>
</listitem>
<listitem>
<simpara>Transient usage: Some resources are transient and count towards the maximum capacity of both the original machine as the newly assigned machine.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Load: The safety capacity for each resource for each machine should not be exceeded.</simpara>
</listitem>
<listitem>
<simpara>Balance: Leave room for future assignments by balancing the available resources on each machine.</simpara>
</listitem>
<listitem>
<simpara>Process move cost: A process has a move cost.</simpara>
</listitem>
<listitem>
<simpara>Service move cost: A service has a move cost.</simpara>
</listitem>
<listitem>
<simpara>Machine move cost: Moving a process from machine A to machine B has another A-B specific move cost.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is defined by <link xlink:href="http://challenge.roadef.org/2012/en/">the Google ROADEF/EURO Challenge 2012</link>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/cloudOptimizationIsLikeTetris.png" align="center"/>
</imageobject>
<textobject><phrase>cloudOptimizationIsLikeTetris</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="machineReassignmentValueProposition">
<title>Value Proposition</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/QuickStart/CloudBalancingTutorial/cloudOptimizationValueProposition.png" align="center"/>
</imageobject>
<textobject><phrase>cloudOptimizationValueProposition</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="machineReassignmentProblemSize">
<title>Problem Size</title>
<screen>model_a1_1 has  2 resources,  1 neighborhoods,   4 locations,    4 machines,    79 services,   100 processes and 1 balancePenalties with a search space of     10^60.
model_a1_2 has  4 resources,  2 neighborhoods,   4 locations,  100 machines,   980 services,  1000 processes and 0 balancePenalties with a search space of   10^2000.
model_a1_3 has  3 resources,  5 neighborhoods,  25 locations,  100 machines,   216 services,  1000 processes and 0 balancePenalties with a search space of   10^2000.
model_a1_4 has  3 resources, 50 neighborhoods,  50 locations,   50 machines,   142 services,  1000 processes and 1 balancePenalties with a search space of   10^1698.
model_a1_5 has  4 resources,  2 neighborhoods,   4 locations,   12 machines,   981 services,  1000 processes and 1 balancePenalties with a search space of   10^1079.
model_a2_1 has  3 resources,  1 neighborhoods,   1 locations,  100 machines,  1000 services,  1000 processes and 0 balancePenalties with a search space of   10^2000.
model_a2_2 has 12 resources,  5 neighborhoods,  25 locations,  100 machines,   170 services,  1000 processes and 0 balancePenalties with a search space of   10^2000.
model_a2_3 has 12 resources,  5 neighborhoods,  25 locations,  100 machines,   129 services,  1000 processes and 0 balancePenalties with a search space of   10^2000.
model_a2_4 has 12 resources,  5 neighborhoods,  25 locations,   50 machines,   180 services,  1000 processes and 1 balancePenalties with a search space of   10^1698.
model_a2_5 has 12 resources,  5 neighborhoods,  25 locations,   50 machines,   153 services,  1000 processes and 0 balancePenalties with a search space of   10^1698.
model_b_1  has 12 resources,  5 neighborhoods,  10 locations,  100 machines,  2512 services,  5000 processes and 0 balancePenalties with a search space of  10^10000.
model_b_2  has 12 resources,  5 neighborhoods,  10 locations,  100 machines,  2462 services,  5000 processes and 1 balancePenalties with a search space of  10^10000.
model_b_3  has  6 resources,  5 neighborhoods,  10 locations,  100 machines, 15025 services, 20000 processes and 0 balancePenalties with a search space of  10^40000.
model_b_4  has  6 resources,  5 neighborhoods,  50 locations,  500 machines,  1732 services, 20000 processes and 1 balancePenalties with a search space of  10^53979.
model_b_5  has  6 resources,  5 neighborhoods,  10 locations,  100 machines, 35082 services, 40000 processes and 0 balancePenalties with a search space of  10^80000.
model_b_6  has  6 resources,  5 neighborhoods,  50 locations,  200 machines, 14680 services, 40000 processes and 1 balancePenalties with a search space of  10^92041.
model_b_7  has  6 resources,  5 neighborhoods,  50 locations, 4000 machines, 15050 services, 40000 processes and 1 balancePenalties with a search space of 10^144082.
model_b_8  has  3 resources,  5 neighborhoods,  10 locations,  100 machines, 45030 services, 50000 processes and 0 balancePenalties with a search space of 10^100000.
model_b_9  has  3 resources,  5 neighborhoods, 100 locations, 1000 machines,  4609 services, 50000 processes and 1 balancePenalties with a search space of 10^150000.
model_b_10 has  3 resources,  5 neighborhoods, 100 locations, 5000 machines,  4896 services, 50000 processes and 1 balancePenalties with a search space of 10^184948.</screen>
</section>
<section xml:id="machineReassignmentDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/machineReassignmentClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>machineReassignmentClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="vehicleRouting">
<title>Vehicle Routing</title>
<section xml:id="vehicleRoutingProblemDescription">
<title>Problem Description</title>
<simpara>Using a fleet of vehicles, pick up the objects of each customer and bring them to the depot.
Each vehicle can service multiple customers, but it has a limited capacity.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/vehicleRoutingUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>vehicleRoutingUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Besides the basic case (CVRP), there is also a variant with time windows (CVRPTW).</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Vehicle capacity: a vehicle cannot carry more items then its capacity.</simpara>
</listitem>
<listitem>
<simpara>Time windows (only in CVRPTW):</simpara>
<itemizedlist>
<listitem>
<simpara>Travel time: Traveling from one location to another takes time.</simpara>
</listitem>
<listitem>
<simpara>Customer service duration: a vehicle must stay at the customer for the length of the service duration.</simpara>
</listitem>
<listitem>
<simpara>Customer ready time: a vehicle may arrive before the customer’s ready time, but it must wait until the ready time before servicing.</simpara>
</listitem>
<listitem>
<simpara>Customer due time: a vehicle must arrive on time, before the customer’s due time.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Total distance: minimize the total distance driven (fuel consumption) of all vehicles.</simpara>
</listitem>
</itemizedlist>
<simpara>The capacitated vehicle routing problem (CVRP) and its timewindowed variant (CVRPTW) are defined by <link xlink:href="http://neo.lcc.uma.es/vrp/">the VRP web</link>.</simpara>
</section>
<section xml:id="vehicleRoutingValueProposition">
<title>Value Proposition</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/vehicleRoutingValueProposition.png" align="center"/>
</imageobject>
<textobject><phrase>vehicleRoutingValueProposition</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="vehicleRoutingProblemSize">
<title>Problem Size</title>
<simpara>CVRP instances (without time windows):</simpara>
<screen>A-n32-k5  has 1 depots,  5 vehicles and  31 customers with a search space of  10^46.
A-n33-k5  has 1 depots,  5 vehicles and  32 customers with a search space of  10^48.
A-n33-k6  has 1 depots,  6 vehicles and  32 customers with a search space of  10^48.
A-n34-k5  has 1 depots,  5 vehicles and  33 customers with a search space of  10^50.
A-n36-k5  has 1 depots,  5 vehicles and  35 customers with a search space of  10^54.
A-n37-k5  has 1 depots,  5 vehicles and  36 customers with a search space of  10^56.
A-n37-k6  has 1 depots,  6 vehicles and  36 customers with a search space of  10^56.
A-n38-k5  has 1 depots,  5 vehicles and  37 customers with a search space of  10^58.
A-n39-k5  has 1 depots,  5 vehicles and  38 customers with a search space of  10^60.
A-n39-k6  has 1 depots,  6 vehicles and  38 customers with a search space of  10^60.
A-n44-k7  has 1 depots,  7 vehicles and  43 customers with a search space of  10^70.
A-n45-k6  has 1 depots,  6 vehicles and  44 customers with a search space of  10^72.
A-n45-k7  has 1 depots,  7 vehicles and  44 customers with a search space of  10^72.
A-n46-k7  has 1 depots,  7 vehicles and  45 customers with a search space of  10^74.
A-n48-k7  has 1 depots,  7 vehicles and  47 customers with a search space of  10^78.
A-n53-k7  has 1 depots,  7 vehicles and  52 customers with a search space of  10^89.
A-n54-k7  has 1 depots,  7 vehicles and  53 customers with a search space of  10^91.
A-n55-k9  has 1 depots,  9 vehicles and  54 customers with a search space of  10^93.
A-n60-k9  has 1 depots,  9 vehicles and  59 customers with a search space of 10^104.
A-n61-k9  has 1 depots,  9 vehicles and  60 customers with a search space of 10^106.
A-n62-k8  has 1 depots,  8 vehicles and  61 customers with a search space of 10^108.
A-n63-k10 has 1 depots, 10 vehicles and  62 customers with a search space of 10^111.
A-n63-k9  has 1 depots,  9 vehicles and  62 customers with a search space of 10^111.
A-n64-k9  has 1 depots,  9 vehicles and  63 customers with a search space of 10^113.
A-n65-k9  has 1 depots,  9 vehicles and  64 customers with a search space of 10^115.
A-n69-k9  has 1 depots,  9 vehicles and  68 customers with a search space of 10^124.
A-n80-k10 has 1 depots, 10 vehicles and  79 customers with a search space of 10^149.
F-n135-k7 has 1 depots,  7 vehicles and 134 customers with a search space of 10^285.
F-n45-k4  has 1 depots,  4 vehicles and  44 customers with a search space of  10^72.
F-n72-k4  has 1 depots,  4 vehicles and  71 customers with a search space of 10^131.</screen>
<simpara>CVRPTW instances (with time windows):</simpara>
<screen>Solomon_025_C101       has 1 depots,  25 vehicles and   25 customers with a search space of   10^34.
Solomon_025_C201       has 1 depots,  25 vehicles and   25 customers with a search space of   10^34.
Solomon_025_R101       has 1 depots,  25 vehicles and   25 customers with a search space of   10^34.
Solomon_025_R201       has 1 depots,  25 vehicles and   25 customers with a search space of   10^34.
Solomon_025_RC101      has 1 depots,  25 vehicles and   25 customers with a search space of   10^34.
Solomon_025_RC201      has 1 depots,  25 vehicles and   25 customers with a search space of   10^34.
Solomon_100_C101       has 1 depots,  25 vehicles and  100 customers with a search space of  10^200.
Solomon_100_C201       has 1 depots,  25 vehicles and  100 customers with a search space of  10^200.
Solomon_100_R101       has 1 depots,  25 vehicles and  100 customers with a search space of  10^200.
Solomon_100_R201       has 1 depots,  25 vehicles and  100 customers with a search space of  10^200.
Solomon_100_RC101      has 1 depots,  25 vehicles and  100 customers with a search space of  10^200.
Solomon_100_RC201      has 1 depots,  25 vehicles and  100 customers with a search space of  10^200.
Homberger_0200_C1_2_1  has 1 depots,  50 vehicles and  200 customers with a search space of  10^460.
Homberger_0200_C2_2_1  has 1 depots,  50 vehicles and  200 customers with a search space of  10^460.
Homberger_0200_R1_2_1  has 1 depots,  50 vehicles and  200 customers with a search space of  10^460.
Homberger_0200_R2_2_1  has 1 depots,  50 vehicles and  200 customers with a search space of  10^460.
Homberger_0200_RC1_2_1 has 1 depots,  50 vehicles and  200 customers with a search space of  10^460.
Homberger_0200_RC2_2_1 has 1 depots,  50 vehicles and  200 customers with a search space of  10^460.
Homberger_0400_C1_4_1  has 1 depots, 100 vehicles and  400 customers with a search space of 10^1040.
Homberger_0400_C2_4_1  has 1 depots, 100 vehicles and  400 customers with a search space of 10^1040.
Homberger_0400_R1_4_1  has 1 depots, 100 vehicles and  400 customers with a search space of 10^1040.
Homberger_0400_R2_4_1  has 1 depots, 100 vehicles and  400 customers with a search space of 10^1040.
Homberger_0400_RC1_4_1 has 1 depots, 100 vehicles and  400 customers with a search space of 10^1040.
Homberger_0400_RC2_4_1 has 1 depots, 100 vehicles and  400 customers with a search space of 10^1040.
Homberger_0600_C1_6_1  has 1 depots, 150 vehicles and  600 customers with a search space of 10^1666.
Homberger_0600_C2_6_1  has 1 depots, 150 vehicles and  600 customers with a search space of 10^1666.
Homberger_0600_R1_6_1  has 1 depots, 150 vehicles and  600 customers with a search space of 10^1666.
Homberger_0600_R2_6_1  has 1 depots, 150 vehicles and  600 customers with a search space of 10^1666.
Homberger_0600_RC1_6_1 has 1 depots, 150 vehicles and  600 customers with a search space of 10^1666.
Homberger_0600_RC2_6_1 has 1 depots, 150 vehicles and  600 customers with a search space of 10^1666.
Homberger_0800_C1_8_1  has 1 depots, 200 vehicles and  800 customers with a search space of 10^2322.
Homberger_0800_C2_8_1  has 1 depots, 200 vehicles and  800 customers with a search space of 10^2322.
Homberger_0800_R1_8_1  has 1 depots, 200 vehicles and  800 customers with a search space of 10^2322.
Homberger_0800_R2_8_1  has 1 depots, 200 vehicles and  800 customers with a search space of 10^2322.
Homberger_0800_RC1_8_1 has 1 depots, 200 vehicles and  800 customers with a search space of 10^2322.
Homberger_0800_RC2_8_1 has 1 depots, 200 vehicles and  800 customers with a search space of 10^2322.
Homberger_1000_C110_1  has 1 depots, 250 vehicles and 1000 customers with a search space of 10^3000.
Homberger_1000_C210_1  has 1 depots, 250 vehicles and 1000 customers with a search space of 10^3000.
Homberger_1000_R110_1  has 1 depots, 250 vehicles and 1000 customers with a search space of 10^3000.
Homberger_1000_R210_1  has 1 depots, 250 vehicles and 1000 customers with a search space of 10^3000.
Homberger_1000_RC110_1 has 1 depots, 250 vehicles and 1000 customers with a search space of 10^3000.
Homberger_1000_RC210_1 has 1 depots, 250 vehicles and 1000 customers with a search space of 10^3000.</screen>
</section>
<section xml:id="vehicleRoutingDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/vehicleRoutingClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>vehicleRoutingClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The vehicle routing with timewindows domain model makes heavily use of <link linkend="shadowVariable">shadow variables</link>.
This allows it to express its constraints more naturally, because properties such as <literal>arrivalTime</literal> and <literal>departureTime</literal>, are directly available on the domain model.</simpara>
<section xml:id="roadDistancesInsteadOfAirDistances">
<title>Road Distances Instead of Air Distances</title>
<simpara>In the real world, vehicles cannot follow a straight line from location to location: they have to use roads and highways.
From a business point of view, this matters a lot:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/vehicleRoutingDistanceType.png" align="center"/>
</imageobject>
<textobject><phrase>vehicleRoutingDistanceType</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For the optimization algorithm, this does not matter much, as long as the distance between two points can be looked up (and are preferably precalculated). The road cost does not even need to be a distance, it can also be travel time, fuel cost, or a weighted function of those.
There are several technologies available to precalculate road costs, such as <link xlink:href="https://graphhopper.com/">GraphHopper</link> (embeddable, offline Java engine), <link xlink:href="http://open.mapquestapi.com/directions/#matrix">Open MapQuest</link> (web service) and <link xlink:href="https://developers.google.com/maps/documentation/webservices/client-library">Google Maps Client API</link> (web service).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/integrationWithRealMaps.png" align="center"/>
</imageobject>
<textobject><phrase>integrationWithRealMaps</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>There are also several technologies to render it, such as <link xlink:href="http://leafletjs.com">Leaflet</link> and <link xlink:href="https://developers.google.com/maps/">Google Maps for developers</link>: the <literal>optaplanner-webexamples-*.war</literal> has an example which demonstrates such rendering:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/vehicleRoutingLeafletAndGoogleMaps.png" align="center"/>
</imageobject>
<textobject><phrase>vehicleRoutingLeafletAndGoogleMaps</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>It is even possible to render the actual road routes with GraphHopper or Google Map Directions, but because of route overlaps on highways, it can become harder to see the standstill order:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/vehicleRoutingGoogleMapsDirections.png" align="center"/>
</imageobject>
<textobject><phrase>vehicleRoutingGoogleMapsDirections</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Take special care that the road costs between two points use the same optimization criteria as the one used in Planner.
For example, GraphHopper etc will by default return the fastest route, not the shortest route.
Don’t use the km (or miles) distances of the fastest GPS routes to optimize the shortest trip in Planner: this leads to a suboptimal solution as shown below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/roadDistanceTriangleInequality.png" align="center"/>
</imageobject>
<textobject><phrase>roadDistanceTriangleInequality</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Contrary to popular belief, most users do not want the shortest route: they want the fastest route instead.
They prefer highways over normal roads.
They prefer normal roads over dirt roads.
In the real world, the fastest and shortest route are rarely the same.</simpara>
</section>
</section>
</section>
<section xml:id="projectJobScheduling">
<title>Project Job Scheduling</title>
<section xml:id="projectJobSchedulingProblemDescription">
<title>Problem Description</title>
<simpara>Schedule all jobs in time and execution mode to minimize project delays.
Each job is part of a project.
A job can be executed in different ways: each way is an execution mode that implies a different duration but also different resource usages.
This is a form of flexible <emphasis>job shop scheduling</emphasis>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/projectJobSchedulingUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>projectJobSchedulingUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Job precedence: a job can only start when all its predecessor jobs are finished.</simpara>
</listitem>
<listitem>
<simpara>Resource capacity: do not use more resources than available.</simpara>
<itemizedlist>
<listitem>
<simpara>Resources are local (shared between jobs of the same project) or global (shared between all jobs)</simpara>
</listitem>
<listitem>
<simpara>Resource are renewable (capacity available per day) or nonrenewable (capacity available for all days)</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Medium constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Total project delay: minimize the duration (makespan) of each project.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Total makespan: minimize the duration of the whole multi-project schedule.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is defined by <link xlink:href="http://gent.cs.kuleuven.be/mista2013challenge/">the MISTA 2013 challenge</link>.</simpara>
</section>
<section xml:id="projectJobSchedulingProblemSize">
<title>Problem Size</title>
<screen>Schedule A-1  has  2 projects,  24 jobs,   64 execution modes,  7 resources and  150 resource requirements.
Schedule A-2  has  2 projects,  44 jobs,  124 execution modes,  7 resources and  420 resource requirements.
Schedule A-3  has  2 projects,  64 jobs,  184 execution modes,  7 resources and  630 resource requirements.
Schedule A-4  has  5 projects,  60 jobs,  160 execution modes, 16 resources and  390 resource requirements.
Schedule A-5  has  5 projects, 110 jobs,  310 execution modes, 16 resources and  900 resource requirements.
Schedule A-6  has  5 projects, 160 jobs,  460 execution modes, 16 resources and 1440 resource requirements.
Schedule A-7  has 10 projects, 120 jobs,  320 execution modes, 22 resources and  900 resource requirements.
Schedule A-8  has 10 projects, 220 jobs,  620 execution modes, 22 resources and 1860 resource requirements.
Schedule A-9  has 10 projects, 320 jobs,  920 execution modes, 31 resources and 2880 resource requirements.
Schedule A-10 has 10 projects, 320 jobs,  920 execution modes, 31 resources and 2970 resource requirements.
Schedule B-1  has 10 projects, 120 jobs,  320 execution modes, 31 resources and  900 resource requirements.
Schedule B-2  has 10 projects, 220 jobs,  620 execution modes, 22 resources and 1740 resource requirements.
Schedule B-3  has 10 projects, 320 jobs,  920 execution modes, 31 resources and 3060 resource requirements.
Schedule B-4  has 15 projects, 180 jobs,  480 execution modes, 46 resources and 1530 resource requirements.
Schedule B-5  has 15 projects, 330 jobs,  930 execution modes, 46 resources and 2760 resource requirements.
Schedule B-6  has 15 projects, 480 jobs, 1380 execution modes, 46 resources and 4500 resource requirements.
Schedule B-7  has 20 projects, 240 jobs,  640 execution modes, 61 resources and 1710 resource requirements.
Schedule B-8  has 20 projects, 440 jobs, 1240 execution modes, 42 resources and 3180 resource requirements.
Schedule B-9  has 20 projects, 640 jobs, 1840 execution modes, 61 resources and 5940 resource requirements.
Schedule B-10 has 20 projects, 460 jobs, 1300 execution modes, 42 resources and 4260 resource requirements.</screen>
</section>
<section xml:id="bedAllocation">
<title>Hospital Bed Planning (PAS - Patient Admission Scheduling)</title>
<section xml:id="bedAllocationProblemDescription">
<title>Problem Description</title>
<simpara>Assign each patient (that will come to the hospital) into a bed for each night that the patient will stay in the hospital.
Each bed belongs to a room and each room belongs to a department.
The arrival and departure dates of the patients is fixed: only a bed needs to be assigned for each night.</simpara>
<simpara>This problem features <link linkend="overconstrainedPlanning">overconstrained</link> datasets.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/patientAdmissionScheduleUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>patientAdmissionScheduleUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Two patients must not be assigned to the same bed in the same night. Weight: <literal>-1000hard * conflictNightCount</literal>.</simpara>
</listitem>
<listitem>
<simpara>A room can have a gender limitation: only females, only males, the same gender in the same night or no gender limitation at all. Weight: <literal>-50hard * nightCount</literal>.</simpara>
</listitem>
<listitem>
<simpara>A department can have a minimum or maximum age. Weight: <literal>-100hard * nightCount</literal>.</simpara>
</listitem>
<listitem>
<simpara>A patient can require a room with specific equipment(s). Weight: <literal>-50hard * nightCount</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>Medium constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Assign every patient to a bed, unless the dataset is overconstrained. Weight: <literal>-1medium * nightCount</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>A patient can prefer a maximum room size, for example if he/she wants a single room. Weight: <literal>-8soft * nightCount</literal>.</simpara>
</listitem>
<listitem>
<simpara>A patient is best assigned to a department that specializes in his/her problem. Weight: <literal>-10soft * nightCount</literal>.</simpara>
</listitem>
<listitem>
<simpara>A patient is best assigned to a room that specializes in his/her problem. Weight: <literal>-20soft * nightCount</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>That room speciality should be priority 1. Weight: <literal>-10soft * (priority - 1) * nightCount</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>A patient can prefer a room with specific equipment(s). Weight: <literal>-20soft * nightCount</literal>.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is a variant on <link xlink:href="https://people.cs.kuleuven.be/~wim.vancroonenburg/pas/">Kaho’s Patient Scheduling</link> and the datasets come from real world hospitals.</simpara>
</section>
<section xml:id="bedAllocationProblemSize">
<title>Problem Size</title>
<screen>testdata01 has 4 specialisms, 2 equipments, 4 departments,  98 rooms, 286 beds, 14 nights,  652 patients and  652 admissions with a search space of 10^1601.
testdata02 has 6 specialisms, 2 equipments, 6 departments, 151 rooms, 465 beds, 14 nights,  755 patients and  755 admissions with a search space of 10^2013.
testdata03 has 5 specialisms, 2 equipments, 5 departments, 131 rooms, 395 beds, 14 nights,  708 patients and  708 admissions with a search space of 10^1838.
testdata04 has 6 specialisms, 2 equipments, 6 departments, 155 rooms, 471 beds, 14 nights,  746 patients and  746 admissions with a search space of 10^1994.
testdata05 has 4 specialisms, 2 equipments, 4 departments, 102 rooms, 325 beds, 14 nights,  587 patients and  587 admissions with a search space of 10^1474.
testdata06 has 4 specialisms, 2 equipments, 4 departments, 104 rooms, 313 beds, 14 nights,  685 patients and  685 admissions with a search space of 10^1709.
testdata07 has 6 specialisms, 4 equipments, 6 departments, 162 rooms, 472 beds, 14 nights,  519 patients and  519 admissions with a search space of 10^1387.
testdata08 has 6 specialisms, 4 equipments, 6 departments, 148 rooms, 441 beds, 21 nights,  895 patients and  895 admissions with a search space of 10^2366.
testdata09 has 4 specialisms, 4 equipments, 4 departments, 105 rooms, 310 beds, 28 nights, 1400 patients and 1400 admissions with a search space of 10^3487.
testdata10 has 4 specialisms, 4 equipments, 4 departments, 104 rooms, 308 beds, 56 nights, 1575 patients and 1575 admissions with a search space of 10^3919.
testdata11 has 4 specialisms, 4 equipments, 4 departments, 107 rooms, 318 beds, 91 nights, 2514 patients and 2514 admissions with a search space of 10^6291.
testdata12 has 4 specialisms, 4 equipments, 4 departments, 105 rooms, 310 beds, 84 nights, 2750 patients and 2750 admissions with a search space of 10^6851.
testdata13 has 5 specialisms, 4 equipments, 5 departments, 125 rooms, 368 beds, 28 nights,  907 patients and 1109 admissions with a search space of 10^2845.</screen>
</section>
<section xml:id="bedAllocationDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/hospitalBedAllocationClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>hospitalBedAllocationClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="taskAssigning">
<title>Task assigning</title>
<section xml:id="taskAssigningProblemDescription">
<title>Problem Description</title>
<simpara>Assign each task to a spot in an employee’s queue.
Each task has a duration which is affected by the employee’s affinity level with the task’s customer.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Skill: Each task requires one or more skills. The employee must posses all these skills.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft level 0 constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Critical tasks: Complete critical tasks first, sooner than major and minor tasks.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft level 1 constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Minimize makespan: Reduce the time to complete all tasks.</simpara>
<itemizedlist>
<listitem>
<simpara>Start with the longest working employee first, then the second longest working employee and so forth, to creates <link linkend="fairnessScoreConstraints">fairness and load balancing</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Soft level 2 constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Major tasks: Complete major tasks as soon as possible, sooner than minor tasks.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft level 3 constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Minor tasks: Complete minor tasks as soon as possible.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="taskAssigningProblemSize">
<title>Problem Size</title>
<screen>24tasks-8employees   has  24 tasks, 6 skills,  8 employees,   4 task types and  4 customers with a search space of   10^40.
50tasks-5employees   has  50 tasks, 5 skills,  5 employees,  10 task types and 10 customers with a search space of   10^91.
100tasks-5employees  has 100 tasks, 5 skills,  5 employees,  20 task types and 15 customers with a search space of  10^207.
500tasks-20employees has 500 tasks, 6 skills, 20 employees, 100 task types and 60 customers with a search space of 10^1384.</screen>
</section>
<section xml:id="taskAssigningDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/RealExamples/taskAssigningClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>taskAssigningClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
</section>
<section xml:id="difficultExamples">
<title>Advanced Examples</title>
<section xml:id="examination">
<title>Exam Timetabling (ITC 2007 track 1 - Examination)</title>
<section xml:id="examinationProblemDescription">
<title>Problem Description</title>
<simpara>Schedule each exam into a period and into a room.
Multiple exams can share the same room during the same period.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/DifficultExamples/examinationTimetablingUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>examinationTimetablingUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Exam conflict: two exams that share students must not occur in the same period.</simpara>
</listitem>
<listitem>
<simpara>Room capacity: A room’s seating capacity must suffice at all times.</simpara>
</listitem>
<listitem>
<simpara>Period duration: A period’s duration must suffice for all of its exams.</simpara>
</listitem>
<listitem>
<simpara>Period related hard constraints (specified per dataset):</simpara>
<itemizedlist>
<listitem>
<simpara>Coincidence: two specified exams must use the same period (but possibly another room).</simpara>
</listitem>
<listitem>
<simpara>Exclusion: two specified exams must not use the same period.</simpara>
</listitem>
<listitem>
<simpara>After: A specified exam must occur in a period after another specified exam’s period.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Room related hard constraints (specified per dataset):</simpara>
<itemizedlist>
<listitem>
<simpara>Exclusive: one specified exam should not have to share its room with any other exam.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Soft constraints (each of which has a parametrized penalty):</simpara>
<itemizedlist>
<listitem>
<simpara>The same student should not have two exams in a row.</simpara>
</listitem>
<listitem>
<simpara>The same student should not have two exams on the same day.</simpara>
</listitem>
<listitem>
<simpara>Period spread: two exams that share students should be a number of periods apart.</simpara>
</listitem>
<listitem>
<simpara>Mixed durations: two exams that share a room should not have different durations.</simpara>
</listitem>
<listitem>
<simpara>Front load: Large exams should be scheduled earlier in the schedule.</simpara>
</listitem>
<listitem>
<simpara>Period penalty (specified per dataset): Some periods have a penalty when used.</simpara>
</listitem>
<listitem>
<simpara>Room penalty (specified per dataset): Some rooms have a penalty when used.</simpara>
</listitem>
</itemizedlist>
<simpara>It uses large test data sets of real-life universities.</simpara>
<simpara>The problem is defined by <link xlink:href="http://www.cs.qub.ac.uk/itc2007/examtrack/exam_track_index.htm">the International Timetabling Competition 2007 track 1</link>.
Geoffrey De Smet finished 4th in that competition with a very early version of Planner.
Many improvements have been made since then.</simpara>
</section>
<section xml:id="examinationProblemSize">
<title>Problem Size</title>
<screen>exam_comp_set1 has  7883 students,  607 exams, 54 periods,  7 rooms,  12 period constraints and  0 room constraints with a search space of 10^1564.
exam_comp_set2 has 12484 students,  870 exams, 40 periods, 49 rooms,  12 period constraints and  2 room constraints with a search space of 10^2864.
exam_comp_set3 has 16365 students,  934 exams, 36 periods, 48 rooms, 168 period constraints and 15 room constraints with a search space of 10^3023.
exam_comp_set4 has  4421 students,  273 exams, 21 periods,  1 rooms,  40 period constraints and  0 room constraints with a search space of  10^360.
exam_comp_set5 has  8719 students, 1018 exams, 42 periods,  3 rooms,  27 period constraints and  0 room constraints with a search space of 10^2138.
exam_comp_set6 has  7909 students,  242 exams, 16 periods,  8 rooms,  22 period constraints and  0 room constraints with a search space of  10^509.
exam_comp_set7 has 13795 students, 1096 exams, 80 periods, 15 rooms,  28 period constraints and  0 room constraints with a search space of 10^3374.
exam_comp_set8 has  7718 students,  598 exams, 80 periods,  8 rooms,  20 period constraints and  1 room constraints with a search space of 10^1678.</screen>
</section>
<section xml:id="examinationDomainModel">
<title>Domain Model</title>
<simpara>Below you can see the main examination domain classes:</simpara>
<figure>
<title>Examination Domain Class Diagram</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/DifficultExamples/examinationDomainDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>examinationDomainDiagram</phrase></textobject>
</mediaobject>
</figure>
<simpara>Notice that we’ve split up the exam concept into an <literal>Exam</literal> class and a <literal>Topic</literal> class.
The <literal>Exam</literal> instances change during solving (this is the planning entity class), when their period or room property changes.
The <literal>Topic</literal>, <literal>Period</literal> and <literal>Room</literal> instances never change during solving (these are problem facts, just like some other classes).</simpara>
</section>
</section>
<section xml:id="employeeRostering">
<title>Employee Rostering (INRC 2010 - Nurse Rostering)</title>
<section xml:id="employeeRosteringProblemDescription">
<title>Problem Description</title>
<simpara>For each shift, assign a nurse to work that shift.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/DifficultExamples/employeeShiftRosteringUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>employeeShiftRosteringUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">No unassigned shifts</emphasis> (built-in): Every shift need to be assigned to an employee.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Shift conflict</emphasis>: An employee can have only one shift per day.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Contract obligations. The business frequently violates these, so they decided to define these as soft constraints instead of hard constraints.</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Minimum and maximum assignments</emphasis>: Each employee needs to work more than x shifts and less than y shifts (depending on their contract).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Minimum and maximum consecutive working days</emphasis>: Each employee needs to work between x and y days in a row (depending on their contract).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Minimum and maximum consecutive free days</emphasis>: Each employee needs to be free between x and y days in a row (depending on their contract).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Minimum and maximum consecutive working weekends</emphasis>: Each employee needs to work between x and y weekends in a row (depending on their contract).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Complete weekends</emphasis>: Each employee needs to work every day in a weekend or not at all.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Identical shift types during weekend</emphasis>: Each weekend shift for the same weekend of the same employee must be the same shift type.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Unwanted patterns</emphasis>: A combination of unwanted shift types in a row. For example: a late shift followed by an early shift followed by a late shift.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Employee wishes:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Day on request</emphasis>: An employee wants to work on a specific day.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Day off request</emphasis>: An employee does not want to work on a specific day.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Shift on request</emphasis>: An employee wants to be assigned to a specific shift.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Shift off request</emphasis>: An employee does not want to be assigned to a specific shift.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Alternative skill</emphasis>: An employee assigned to a skill should have a proficiency in every skill required by that shift.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is defined by <link xlink:href="http://www.kuleuven-kortrijk.be/nrpcompetition">the International Nurse Rostering Competition 2010</link>.</simpara>
</section>
<section xml:id="employeeRosteringValueProposition">
<title>Value Proposition</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/DifficultExamples/employeeRosteringValueProposition.png" align="center"/>
</imageobject>
<textobject><phrase>employeeRosteringValueProposition</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="employeeRosteringProblemSize">
<title>Problem Size</title>
<simpara>There are three dataset types:</simpara>
<itemizedlist>
<listitem>
<simpara>sprint: must be solved in seconds.</simpara>
</listitem>
<listitem>
<simpara>medium: must be solved in minutes.</simpara>
</listitem>
<listitem>
<simpara>long: must be solved in hours.</simpara>
</listitem>
</itemizedlist>
<screen>toy1          has 1 skills, 3 shiftTypes, 2 patterns, 1 contracts,  6 employees,  7 shiftDates,  35 shiftAssignments and   0 requests with a search space of   10^27.
toy2          has 1 skills, 3 shiftTypes, 3 patterns, 2 contracts, 20 employees, 28 shiftDates, 180 shiftAssignments and 140 requests with a search space of  10^234.

sprint01      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint02      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint03      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint04      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint05      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint06      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint07      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint08      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint09      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint10      has 1 skills, 4 shiftTypes, 3 patterns, 4 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_hint01 has 1 skills, 4 shiftTypes, 8 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_hint02 has 1 skills, 4 shiftTypes, 0 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_hint03 has 1 skills, 4 shiftTypes, 8 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_late01 has 1 skills, 4 shiftTypes, 8 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_late02 has 1 skills, 3 shiftTypes, 4 patterns, 3 contracts, 10 employees, 28 shiftDates, 144 shiftAssignments and 139 requests with a search space of  10^144.
sprint_late03 has 1 skills, 4 shiftTypes, 8 patterns, 3 contracts, 10 employees, 28 shiftDates, 160 shiftAssignments and 150 requests with a search space of  10^160.
sprint_late04 has 1 skills, 4 shiftTypes, 8 patterns, 3 contracts, 10 employees, 28 shiftDates, 160 shiftAssignments and 150 requests with a search space of  10^160.
sprint_late05 has 1 skills, 4 shiftTypes, 8 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_late06 has 1 skills, 4 shiftTypes, 0 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_late07 has 1 skills, 4 shiftTypes, 0 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.
sprint_late08 has 1 skills, 4 shiftTypes, 0 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and   0 requests with a search space of  10^152.
sprint_late09 has 1 skills, 4 shiftTypes, 0 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and   0 requests with a search space of  10^152.
sprint_late10 has 1 skills, 4 shiftTypes, 0 patterns, 3 contracts, 10 employees, 28 shiftDates, 152 shiftAssignments and 150 requests with a search space of  10^152.

medium01      has 1 skills, 4 shiftTypes, 0 patterns, 4 contracts, 31 employees, 28 shiftDates, 608 shiftAssignments and 403 requests with a search space of  10^906.
medium02      has 1 skills, 4 shiftTypes, 0 patterns, 4 contracts, 31 employees, 28 shiftDates, 608 shiftAssignments and 403 requests with a search space of  10^906.
medium03      has 1 skills, 4 shiftTypes, 0 patterns, 4 contracts, 31 employees, 28 shiftDates, 608 shiftAssignments and 403 requests with a search space of  10^906.
medium04      has 1 skills, 4 shiftTypes, 0 patterns, 4 contracts, 31 employees, 28 shiftDates, 608 shiftAssignments and 403 requests with a search space of  10^906.
medium05      has 1 skills, 4 shiftTypes, 0 patterns, 4 contracts, 31 employees, 28 shiftDates, 608 shiftAssignments and 403 requests with a search space of  10^906.
medium_hint01 has 1 skills, 4 shiftTypes, 7 patterns, 4 contracts, 30 employees, 28 shiftDates, 428 shiftAssignments and 390 requests with a search space of  10^632.
medium_hint02 has 1 skills, 4 shiftTypes, 7 patterns, 3 contracts, 30 employees, 28 shiftDates, 428 shiftAssignments and 390 requests with a search space of  10^632.
medium_hint03 has 1 skills, 4 shiftTypes, 7 patterns, 4 contracts, 30 employees, 28 shiftDates, 428 shiftAssignments and 390 requests with a search space of  10^632.
medium_late01 has 1 skills, 4 shiftTypes, 7 patterns, 4 contracts, 30 employees, 28 shiftDates, 424 shiftAssignments and 390 requests with a search space of  10^626.
medium_late02 has 1 skills, 4 shiftTypes, 7 patterns, 3 contracts, 30 employees, 28 shiftDates, 428 shiftAssignments and 390 requests with a search space of  10^632.
medium_late03 has 1 skills, 4 shiftTypes, 0 patterns, 4 contracts, 30 employees, 28 shiftDates, 428 shiftAssignments and 390 requests with a search space of  10^632.
medium_late04 has 1 skills, 4 shiftTypes, 7 patterns, 3 contracts, 30 employees, 28 shiftDates, 416 shiftAssignments and 390 requests with a search space of  10^614.
medium_late05 has 2 skills, 5 shiftTypes, 7 patterns, 4 contracts, 30 employees, 28 shiftDates, 452 shiftAssignments and 390 requests with a search space of  10^667.

long01        has 2 skills, 5 shiftTypes, 3 patterns, 3 contracts, 49 employees, 28 shiftDates, 740 shiftAssignments and 735 requests with a search space of 10^1250.
long02        has 2 skills, 5 shiftTypes, 3 patterns, 3 contracts, 49 employees, 28 shiftDates, 740 shiftAssignments and 735 requests with a search space of 10^1250.
long03        has 2 skills, 5 shiftTypes, 3 patterns, 3 contracts, 49 employees, 28 shiftDates, 740 shiftAssignments and 735 requests with a search space of 10^1250.
long04        has 2 skills, 5 shiftTypes, 3 patterns, 3 contracts, 49 employees, 28 shiftDates, 740 shiftAssignments and 735 requests with a search space of 10^1250.
long05        has 2 skills, 5 shiftTypes, 3 patterns, 3 contracts, 49 employees, 28 shiftDates, 740 shiftAssignments and 735 requests with a search space of 10^1250.
long_hint01   has 2 skills, 5 shiftTypes, 9 patterns, 3 contracts, 50 employees, 28 shiftDates, 740 shiftAssignments and   0 requests with a search space of 10^1257.
long_hint02   has 2 skills, 5 shiftTypes, 7 patterns, 3 contracts, 50 employees, 28 shiftDates, 740 shiftAssignments and   0 requests with a search space of 10^1257.
long_hint03   has 2 skills, 5 shiftTypes, 7 patterns, 3 contracts, 50 employees, 28 shiftDates, 740 shiftAssignments and   0 requests with a search space of 10^1257.
long_late01   has 2 skills, 5 shiftTypes, 9 patterns, 3 contracts, 50 employees, 28 shiftDates, 752 shiftAssignments and   0 requests with a search space of 10^1277.
long_late02   has 2 skills, 5 shiftTypes, 9 patterns, 4 contracts, 50 employees, 28 shiftDates, 752 shiftAssignments and   0 requests with a search space of 10^1277.
long_late03   has 2 skills, 5 shiftTypes, 9 patterns, 3 contracts, 50 employees, 28 shiftDates, 752 shiftAssignments and   0 requests with a search space of 10^1277.
long_late04   has 2 skills, 5 shiftTypes, 9 patterns, 4 contracts, 50 employees, 28 shiftDates, 752 shiftAssignments and   0 requests with a search space of 10^1277.
long_late05   has 2 skills, 5 shiftTypes, 9 patterns, 3 contracts, 50 employees, 28 shiftDates, 740 shiftAssignments and   0 requests with a search space of 10^1257.</screen>
</section>
<section xml:id="employeeRosteringDomainModel">
<title>Domain Model</title>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/DifficultExamples/nurseRosteringClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>nurseRosteringClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
</section>
<section xml:id="travelingTournament">
<title>Traveling Tournament Problem (TTP)</title>
<section xml:id="travelingTournamentProblemDescription">
<title>Problem Description</title>
<simpara>Schedule matches between <emphasis>n</emphasis> teams.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/UseCasesAndExamples/DifficultExamples/travelingTournamentUseCase.png" align="center"/>
</imageobject>
<textobject><phrase>travelingTournamentUseCase</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Each team plays twice against every other team: once home and once away.</simpara>
</listitem>
<listitem>
<simpara>Each team has exactly one match on each timeslot.</simpara>
</listitem>
<listitem>
<simpara>No team must have more than three consecutive home or three consecutive away matches.</simpara>
</listitem>
<listitem>
<simpara>No repeaters: no two consecutive matches of the same two opposing teams.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Minimize the total distance traveled by all teams.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is defined on <link xlink:href="http://mat.gsia.cmu.edu/TOURN/">Michael Trick’s website (which contains the world records too)</link>.</simpara>
</section>
<section xml:id="travelingTournamentProblemSize">
<title>Problem Size</title>
<screen>1-nl04     has  6 days,  4 teams and   12 matches with a search space of    10^9.
1-nl06     has 10 days,  6 teams and   30 matches with a search space of   10^30.
1-nl08     has 14 days,  8 teams and   56 matches with a search space of   10^64.
1-nl10     has 18 days, 10 teams and   90 matches with a search space of  10^112.
1-nl12     has 22 days, 12 teams and  132 matches with a search space of  10^177.
1-nl14     has 26 days, 14 teams and  182 matches with a search space of  10^257.
1-nl16     has 30 days, 16 teams and  240 matches with a search space of  10^354.
2-bra24    has 46 days, 24 teams and  552 matches with a search space of  10^917.
3-nfl16    has 30 days, 16 teams and  240 matches with a search space of  10^354.
3-nfl18    has 34 days, 18 teams and  306 matches with a search space of  10^468.
3-nfl20    has 38 days, 20 teams and  380 matches with a search space of  10^600.
3-nfl22    has 42 days, 22 teams and  462 matches with a search space of  10^749.
3-nfl24    has 46 days, 24 teams and  552 matches with a search space of  10^917.
3-nfl26    has 50 days, 26 teams and  650 matches with a search space of 10^1104.
3-nfl28    has 54 days, 28 teams and  756 matches with a search space of 10^1309.
3-nfl30    has 58 days, 30 teams and  870 matches with a search space of 10^1534.
3-nfl32    has 62 days, 32 teams and  992 matches with a search space of 10^1778.
4-super04  has  6 days,  4 teams and   12 matches with a search space of    10^9.
4-super06  has 10 days,  6 teams and   30 matches with a search space of   10^30.
4-super08  has 14 days,  8 teams and   56 matches with a search space of   10^64.
4-super10  has 18 days, 10 teams and   90 matches with a search space of  10^112.
4-super12  has 22 days, 12 teams and  132 matches with a search space of  10^177.
4-super14  has 26 days, 14 teams and  182 matches with a search space of  10^257.
5-galaxy04 has  6 days,  4 teams and   12 matches with a search space of    10^9.
5-galaxy06 has 10 days,  6 teams and   30 matches with a search space of   10^30.
5-galaxy08 has 14 days,  8 teams and   56 matches with a search space of   10^64.
5-galaxy10 has 18 days, 10 teams and   90 matches with a search space of  10^112.
5-galaxy12 has 22 days, 12 teams and  132 matches with a search space of  10^177.
5-galaxy14 has 26 days, 14 teams and  182 matches with a search space of  10^257.
5-galaxy16 has 30 days, 16 teams and  240 matches with a search space of  10^354.
5-galaxy18 has 34 days, 18 teams and  306 matches with a search space of  10^468.
5-galaxy20 has 38 days, 20 teams and  380 matches with a search space of  10^600.
5-galaxy22 has 42 days, 22 teams and  462 matches with a search space of  10^749.
5-galaxy24 has 46 days, 24 teams and  552 matches with a search space of  10^917.
5-galaxy26 has 50 days, 26 teams and  650 matches with a search space of 10^1104.
5-galaxy28 has 54 days, 28 teams and  756 matches with a search space of 10^1309.
5-galaxy30 has 58 days, 30 teams and  870 matches with a search space of 10^1534.
5-galaxy32 has 62 days, 32 teams and  992 matches with a search space of 10^1778.
5-galaxy34 has 66 days, 34 teams and 1122 matches with a search space of 10^2041.
5-galaxy36 has 70 days, 36 teams and 1260 matches with a search space of 10^2324.
5-galaxy38 has 74 days, 38 teams and 1406 matches with a search space of 10^2628.
5-galaxy40 has 78 days, 40 teams and 1560 matches with a search space of 10^2951.</screen>
</section>
</section>
<section xml:id="cheapTimeScheduling">
<title>Cheap Time Scheduling</title>
<section xml:id="cheapTimeSchedulingProblemDescription">
<title>Problem Description</title>
<simpara>Schedule all tasks in time and on a machine to minimize power cost.
Power prices differs in time.
This is a form of <emphasis>job shop scheduling</emphasis>.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Start time limits: each task must start between its earliest start and latest start limit.</simpara>
</listitem>
<listitem>
<simpara>Maximum capacity: the maximum capacity for each resource for each machine must not be exceeded.</simpara>
</listitem>
<listitem>
<simpara>Startup and shutdown: each machine must be active in the periods during which it has assigned tasks. Between tasks it is allowed to be idle to avoid startup and shutdown costs.</simpara>
</listitem>
</itemizedlist>
<simpara>Medium constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Power cost: minimize the total power cost of the whole schedule.</simpara>
<itemizedlist>
<listitem>
<simpara>Machine power cost: Each active or idle machine consumes power, which infers a power cost (depending on the power price during that time).</simpara>
</listitem>
<listitem>
<simpara>Task power cost: Each task consumes power too, which infers a power cost (depending on the power price during its time).</simpara>
</listitem>
<listitem>
<simpara>Machine startup and shutdown cost: Every time a machine starts up or shuts down, an extra cost is inflicted.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Soft constraints (addendum to the original problem definition):</simpara>
<itemizedlist>
<listitem>
<simpara>Start early: prefer starting a task sooner rather than later.</simpara>
</listitem>
</itemizedlist>
<simpara>The problem is defined by <link xlink:href="http://iconchallenge.insight-centre.org/">the ICON challenge</link>.</simpara>
</section>
<section xml:id="cheapTimeSchedulingProblemSize">
<title>Problem Size</title>
<screen>sample01   has 3 resources,   2 machines, 288 periods and   25 tasks with a search space of    10^53.
sample02   has 3 resources,   2 machines, 288 periods and   50 tasks with a search space of   10^114.
sample03   has 3 resources,   2 machines, 288 periods and  100 tasks with a search space of   10^226.
sample04   has 3 resources,   5 machines, 288 periods and  100 tasks with a search space of   10^266.
sample05   has 3 resources,   2 machines, 288 periods and  250 tasks with a search space of   10^584.
sample06   has 3 resources,   5 machines, 288 periods and  250 tasks with a search space of   10^673.
sample07   has 3 resources,   2 machines, 288 periods and 1000 tasks with a search space of  10^2388.
sample08   has 3 resources,   5 machines, 288 periods and 1000 tasks with a search space of  10^2748.
sample09   has 4 resources,  20 machines, 288 periods and 2000 tasks with a search space of  10^6668.
instance00 has 1 resources,  10 machines, 288 periods and  200 tasks with a search space of   10^595.
instance01 has 1 resources,  10 machines, 288 periods and  200 tasks with a search space of   10^599.
instance02 has 1 resources,  10 machines, 288 periods and  200 tasks with a search space of   10^599.
instance03 has 1 resources,  10 machines, 288 periods and  200 tasks with a search space of   10^591.
instance04 has 1 resources,  10 machines, 288 periods and  200 tasks with a search space of   10^590.
instance05 has 2 resources,  25 machines, 288 periods and  200 tasks with a search space of   10^667.
instance06 has 2 resources,  25 machines, 288 periods and  200 tasks with a search space of   10^660.
instance07 has 2 resources,  25 machines, 288 periods and  200 tasks with a search space of   10^662.
instance08 has 2 resources,  25 machines, 288 periods and  200 tasks with a search space of   10^651.
instance09 has 2 resources,  25 machines, 288 periods and  200 tasks with a search space of   10^659.
instance10 has 2 resources,  20 machines, 288 periods and  500 tasks with a search space of  10^1657.
instance11 has 2 resources,  20 machines, 288 periods and  500 tasks with a search space of  10^1644.
instance12 has 2 resources,  20 machines, 288 periods and  500 tasks with a search space of  10^1637.
instance13 has 2 resources,  20 machines, 288 periods and  500 tasks with a search space of  10^1659.
instance14 has 2 resources,  20 machines, 288 periods and  500 tasks with a search space of  10^1643.
instance15 has 3 resources,  40 machines, 288 periods and  500 tasks with a search space of  10^1782.
instance16 has 3 resources,  40 machines, 288 periods and  500 tasks with a search space of  10^1778.
instance17 has 3 resources,  40 machines, 288 periods and  500 tasks with a search space of  10^1764.
instance18 has 3 resources,  40 machines, 288 periods and  500 tasks with a search space of  10^1769.
instance19 has 3 resources,  40 machines, 288 periods and  500 tasks with a search space of  10^1778.
instance20 has 3 resources,  50 machines, 288 periods and 1000 tasks with a search space of  10^3689.
instance21 has 3 resources,  50 machines, 288 periods and 1000 tasks with a search space of  10^3678.
instance22 has 3 resources,  50 machines, 288 periods and 1000 tasks with a search space of  10^3706.
instance23 has 3 resources,  50 machines, 288 periods and 1000 tasks with a search space of  10^3676.
instance24 has 3 resources,  50 machines, 288 periods and 1000 tasks with a search space of  10^3681.
instance25 has 3 resources,  60 machines, 288 periods and 1000 tasks with a search space of  10^3774.
instance26 has 3 resources,  60 machines, 288 periods and 1000 tasks with a search space of  10^3737.
instance27 has 3 resources,  60 machines, 288 periods and 1000 tasks with a search space of  10^3744.
instance28 has 3 resources,  60 machines, 288 periods and 1000 tasks with a search space of  10^3731.
instance29 has 3 resources,  60 machines, 288 periods and 1000 tasks with a search space of  10^3746.
instance30 has 4 resources,  70 machines, 288 periods and 2000 tasks with a search space of  10^7718.
instance31 has 4 resources,  70 machines, 288 periods and 2000 tasks with a search space of  10^7740.
instance32 has 4 resources,  70 machines, 288 periods and 2000 tasks with a search space of  10^7686.
instance33 has 4 resources,  70 machines, 288 periods and 2000 tasks with a search space of  10^7672.
instance34 has 4 resources,  70 machines, 288 periods and 2000 tasks with a search space of  10^7695.
instance35 has 4 resources,  80 machines, 288 periods and 2000 tasks with a search space of  10^7807.
instance36 has 4 resources,  80 machines, 288 periods and 2000 tasks with a search space of  10^7814.
instance37 has 4 resources,  80 machines, 288 periods and 2000 tasks with a search space of  10^7764.
instance38 has 4 resources,  80 machines, 288 periods and 2000 tasks with a search space of  10^7736.
instance39 has 4 resources,  80 machines, 288 periods and 2000 tasks with a search space of  10^7783.
instance40 has 4 resources,  90 machines, 288 periods and 4000 tasks with a search space of 10^15976.
instance41 has 4 resources,  90 machines, 288 periods and 4000 tasks with a search space of 10^15935.
instance42 has 4 resources,  90 machines, 288 periods and 4000 tasks with a search space of 10^15887.
instance43 has 4 resources,  90 machines, 288 periods and 4000 tasks with a search space of 10^15896.
instance44 has 4 resources,  90 machines, 288 periods and 4000 tasks with a search space of 10^15885.
instance45 has 4 resources, 100 machines, 288 periods and 5000 tasks with a search space of 10^20173.
instance46 has 4 resources, 100 machines, 288 periods and 5000 tasks with a search space of 10^20132.
instance47 has 4 resources, 100 machines, 288 periods and 5000 tasks with a search space of 10^20126.
instance48 has 4 resources, 100 machines, 288 periods and 5000 tasks with a search space of 10^20110.
instance49 has 4 resources, 100 machines, 288 periods and 5000 tasks with a search space of 10^20078.</screen>
</section>
</section>
<section xml:id="investment">
<title>Investment Asset Class Allocation (Portfolio Optimization)</title>
<section xml:id="investmentProblemDescription">
<title>Problem Description</title>
<simpara>Decide the relative quantity to invest in each asset class.</simpara>
<simpara>Hard constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Risk maximum: the total standard deviation must not be higher than the standard deviation maximum.</simpara>
<itemizedlist>
<listitem>
<simpara>Total standard deviation calculation takes asset class correlations into account by applying <link xlink:href="https://en.wikipedia.org/wiki/Modern_portfolio_theory">Markowitz Portfolio Theory</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Region maximum: Each region has a quantity maximum.</simpara>
</listitem>
<listitem>
<simpara>Sector maximum: Each sector has a quantity maximum.</simpara>
</listitem>
</itemizedlist>
<simpara>Soft constraints:</simpara>
<itemizedlist>
<listitem>
<simpara>Maximize expected return.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="investmentProblemSize">
<title>Problem Size</title>
<screen>de_smet_1 has 1 regions, 3 sectors and 11 asset classes with a search space of 10^4.
irrinki_1 has 2 regions, 3 sectors and 6 asset classes with a search space of 10^3.</screen>
<simpara>Larger datasets have not been created or tested yet, but should not pose a problem.</simpara>
</section>
</section>
</section>
</chapter>
<chapter xml:id="plannerConfiguration">
<title>Planner Configuration</title>
<section xml:id="plannerConfigurationOverview">
<title>Overview</title>
<simpara>Solving a planning problem with Planner consists of the following steps:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Model your planning problem</emphasis> as a class that implements the interface <literal>Solution</literal>, for example the class <literal>NQueens</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Configure a <literal>Solver</literal></emphasis>, for example a First Fit and Tabu Search solver for any <literal>NQueens</literal> instance.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Load a problem data set</emphasis> from your data layer, for example a Four Queens instance. That is the planning problem.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Solve it</emphasis> with <literal>Solver.solve(problem)</literal> which returns the best solution found.</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/inputOutputOverview.png" align="center"/>
</imageobject>
<textobject><phrase>inputOutputOverview</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="solverConfiguration">
<title>Solver Configuration</title>
<section xml:id="solverConfigurationByXML">
<title>Solver Configuration by XML</title>
<simpara>Build a <literal>Solver</literal> instance with the <literal>SolverFactory</literal>.
Configure the <literal>SolverFactory</literal> with a solver configuration XML file, provided as a classpath resource (as defined by <literal>ClassLoader.getResource()</literal>):</simpara>
<programlisting language="java" linenumbering="unnumbered">       SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromXmlResource(
               "org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml");
       Solver&lt;NQueens&gt; solver = solverFactory.buildSolver();</programlisting>
<simpara>In a typical project (following the Maven directory structure), that solverConfig XML file would be located at <literal>$PROJECT_DIR/src/main/resources/org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml</literal>.
Alternatively, a <literal>SolverFactory</literal> can be created from a <literal>File</literal>, an <literal>InputStream</literal> or a <literal>Reader</literal> with methods such as <literal>SolverFactory.createFromXmlFile()</literal>.
However, for portability reasons, a classpath resource is recommended.</simpara>
<note>
<simpara>On some environments (<link linkend="integrationWithOSGi">OSGi</link>, <link linkend="integrationWithJBossModules">JBoss modules</link>, …​), classpath resources (such as the solver config, score DRL’s and domain classes) in your jars might not be available to the default <literal>ClassLoader</literal> of the <literal>optaplanner-core</literal> jar.
In those cases, provide the <literal>ClassLoader</literal> of your classes as a parameter:</simpara>
<programlisting language="java" linenumbering="unnumbered">       SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromXmlResource(
               ".../nqueensSolverConfig.xml", getClass().getClassLoader());</programlisting>
</note>
<note>
<simpara>When using Workbench or Execution Server or to take advantage of Drools’s <literal>KieContainer</literal> features, provide the <literal>KieContainer</literal> as a parameter:</simpara>
<programlisting language="java" linenumbering="unnumbered">       KieServices kieServices = KieServices.Factory.get();
       KieContainer kieContainer = kieServices.newKieContainer(
               kieServices.newReleaseId("org.nqueens", "nqueens", "1.0.0"));
       SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromKieContainerXmlResource(
               kieContainer, ".../nqueensSolverConfig.xml");</programlisting>
<simpara>Also use <link linkend="droolsScoreCalculationKsessionName">a ksessionName in the solver configuration</link>.</simpara>
</note>
<simpara>Both a <literal>Solver</literal> and a <literal>SolverFactory</literal> have a generic type called <literal>Solution_</literal>, which is the class representing a <link linkend="planningProblemAndPlanningSolution">planning problem and solution</link>.</simpara>
<simpara>A solver configuration XML file looks like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;solutionClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  &lt;entityClass&gt;org.optaplanner.examples.nqueens.domain.Queen&lt;/entityClass&gt;

  &lt;!-- Define the score function --&gt;
  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
  &lt;/scoreDirectorFactory&gt;

  &lt;!-- Configure the optimization algorithms (optional) --&gt;
  &lt;termination&gt;
    ...
  &lt;/termination&gt;
  &lt;constructionHeuristic&gt;
    ...
  &lt;/constructionHeuristic&gt;
  &lt;localSearch&gt;
    ...
  &lt;/localSearch&gt;
&lt;/solver&gt;</programlisting>
<simpara>Notice the three parts in it:</simpara>
<itemizedlist>
<listitem>
<simpara>Define the model.</simpara>
</listitem>
<listitem>
<simpara>Define the score function.</simpara>
</listitem>
<listitem>
<simpara>Optionally configure the optimization algorithm(s).</simpara>
</listitem>
</itemizedlist>
<simpara>These various parts of a configuration are explained further in this manual.</simpara>
<simpara><emphasis role="strong">Planner makes it relatively easy to switch optimization algorithm(s) just by changing the configuration.</emphasis> There is even a <link linkend="benchmarker">Benchmarker</link> which allows you to play out different configurations against each other and report the most appropriate configuration for your use case.</simpara>
</section>
<section xml:id="solverConfigurationByJavaAPI">
<title>Solver Configuration by Java API</title>
<simpara>A solver configuration can also be configured with the <literal>SolverConfig</literal> API.
This is especially useful to change some values dynamically at runtime.
For example, to change the running time based on user input, before building the <literal>Solver</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">        SolverFactory&lt;NQueens&gt; solverFactory = SolverFactory.createFromXmlResource(
                "org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml");

        TerminationConfig terminationConfig = new TerminationConfig();
        terminationConfig.setMinutesSpentLimit(userInput);
        solverFactory.getSolverConfig().setTerminationConfig(terminationConfig);

        Solver&lt;NQueens&gt; solver = solverFactory.buildSolver();</programlisting>
<simpara>Every element in the solver configuration XML is available as a <literal>*Config</literal> class or a property on a <literal>*Config</literal> class in the package namespace <literal>org.optaplanner.core.config</literal>.
These <literal>*Config</literal> classes are the Java representation of the XML format.
They build the runtime components (of the package namespace <literal>org.optaplanner.core.impl</literal>) and assemble them into an efficient <literal>Solver</literal>.</simpara>
<important>
<simpara>The <literal>SolverFactory</literal> is only multi-thread safe after its configured.
So the <literal>getSolverConfig()</literal> method is not thread-safe.
To configure a <literal>SolverFactory</literal> dynamically for each user request, build a <literal>SolverFactory</literal> as base during initialization and clone it with the <literal>cloneSolverFactory()</literal> method for a user request:</simpara>
<programlisting language="java" linenumbering="unnumbered">    private SolverFactory&lt;NQueens&gt; base;

    public void init() {
        base = SolverFactory.createFromXmlResource(
                "org/optaplanner/examples/nqueens/solver/nqueensSolverConfig.xml");
        base.getSolverConfig().setTerminationConfig(new TerminationConfig());
    }

    // Called concurrently from different threads
    public void userRequest(..., long userInput)
        SolverFactory&lt;NQueens&gt; solverFactory = base.cloneSolverFactory();
        solverFactory.getSolverConfig().getTerminationConfig().setMinutesSpentLimit(userInput);
        Solver&lt;NQueens&gt; solver = solverFactory.buildSolver();
        ...
    }</programlisting>
</important>
</section>
<section xml:id="annotationsConfiguration">
<title>Annotations Configuration</title>
<section xml:id="automaticScanningForAnnotations">
<title>Automatic Scanning for Annotations</title>
<simpara>Instead of the declaring the classes that have a <literal>@PlanningSolution</literal> or <literal>@PlanningEntity</literal> manually:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;solutionClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  &lt;entityClass&gt;org.optaplanner.examples.nqueens.domain.Queen&lt;/entityClass&gt;

  ...
&lt;/solver&gt;</programlisting>
<simpara>Planner can find scan the classpath and find them automatically:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;scanAnnotatedClasses/&gt;

  ...
&lt;/solver&gt;</programlisting>
<note>
<simpara>On environments such as OSGi and Android, which use a non-standard <literal>ClassLoader</literal>,
automated scanning might not find the <literal>@PlanningSolution</literal> or <literal>@PlanningEntity</literal> classes.</simpara>
</note>
<simpara>Automated scanning inflicts a performance cost during bootstrap.
To speed up scanning or if there are multiple models in your classpath,
specify the packages to scan:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;!-- Define the model --&gt;
  &lt;scanAnnotatedClasses&gt;
    &lt;packageInclude&gt;org.optaplanner.examples.cloudbalancing&lt;/packageInclude&gt;
  &lt;/scanAnnotatedClasses&gt;

  ...
&lt;/solver&gt;</programlisting>
<simpara>This finds all solution and entity classes in that package or its subpackages.</simpara>
<note>
<simpara>If <literal>scanAnnotatedClasses</literal> is not specified, the <literal>org.reflections</literal> transitive maven dependency can be excluded.</simpara>
</note>
</section>
<section xml:id="annotationAlternatives">
<title>Annotation Alternatives</title>
<simpara>Planner needs to be told which classes in your domain model are planning entities, which properties are planning variables, etc.
There are several ways to deliver this information:</simpara>
<itemizedlist>
<listitem>
<simpara>Add class annotations and JavaBean property annotations on the domain model (recommended). The property annotations must be on the getter method, not on the setter method. Such a getter does not need to be public.</simpara>
</listitem>
<listitem>
<simpara>Add class annotations and field annotations on the domain model. Such a field does not need to be public.</simpara>
</listitem>
<listitem>
<simpara>No annotations: externalize the domain configuration in an XML file. This is <link xlink:href="https://issues.jboss.org/browse/PLANNER-151">not yet supported</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>This manual focuses on the first manner, but every features supports all three manners, even if it’s not explicitly mentioned.</simpara>
</section>
</section>
</section>
<section xml:id="modelAPlanningProblem">
<title>Model a Planning Problem</title>
<section xml:id="isThisClassAProblemFactOrPlanningEntity">
<title>Is This Class a Problem Fact or Planning Entity?</title>
<simpara>Look at a dataset of your planning problem.
You will recognize domain classes in there, each of which can be categorized as one of the following:</simpara>
<itemizedlist>
<listitem>
<simpara>A unrelated class: not used by any of the score constraints. From a planning standpoint, this data is obsolete.</simpara>
</listitem>
<listitem>
<simpara>A <emphasis role="strong">problem fact</emphasis> class: used by the score constraints, but does NOT change during planning (as long as the problem stays the same). For example: <literal>Bed</literal>, <literal>Room</literal>, <literal>Shift</literal>, <literal>Employee</literal>, <literal>Topic</literal>, <literal>Period</literal>, …​ All the properties of a problem fact class are problem properties.</simpara>
</listitem>
<listitem>
<simpara>A <emphasis role="strong">planning entity</emphasis> class: used by the score constraints and changes during planning. For example: <literal>BedDesignation</literal>, <literal>ShiftAssignment</literal>, <literal>Exam</literal>, …​ The properties that change during planning are planning variables. The other properties are problem properties.</simpara>
</listitem>
</itemizedlist>
<simpara>Ask yourself: _What class changes during planning?<emphasis>_Which class has variables that I want the <literal>Solver</literal> to change for me?</emphasis> That class is a planning entity.
Most use cases have only one planning entity class.
Most use cases also have only one planning variable per planning entity class.</simpara>
<note>
<simpara>In <link linkend="realTimePlanning">real-time planning</link>, even though the problem itself changes, problem facts do not really change during planning, instead they change between planning (because the Solver temporarily stops to apply the problem fact changes).</simpara>
</note>
<simpara>To create a good domain model, read the <link linkend="domainModelingGuide">domain modeling guide</link>.</simpara>
<simpara><emphasis role="strong">In Planner, all problems facts and planning entities are plain old JavaBeans (POJOs).</emphasis> Load them from a database, an XML file, a data repository, a REST service, a noSQL cloud, …​ (see <link linkend="integration">integration</link>): it doesn’t matter.</simpara>
</section>
<section xml:id="problemFact">
<title>Problem Fact</title>
<simpara>A problem fact is any JavaBean (POJO) with getters that does not change during planning.
Implementing the interface <literal>Serializable</literal> is recommended (but not required). For example in n queens, the columns and rows are problem facts:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Column implements Serializable {

    private int index;

    // ... getters
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class Row implements Serializable {

    private int index;

    // ... getters
}</programlisting>
<simpara>A problem fact can reference other problem facts of course:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Course implements Serializable {

    private String code;

    private Teacher teacher; // Other problem fact
    private int lectureSize;
    private int minWorkingDaySize;

    private List&lt;Curriculum&gt; curriculumList; // Other problem facts
    private int studentSize;

    // ... getters
}</programlisting>
<simpara>A problem fact class does <emphasis>not</emphasis> require any Planner specific code.
For example, you can reuse your domain classes, which might have JPA annotations.</simpara>
<note>
<simpara>Generally, better designed domain classes lead to simpler and more efficient score constraints.
Therefore, when dealing with a messy (denormalized) legacy system, it can sometimes be worthwhile to convert the messy domain model into a Planner specific model first.
For example: if your domain model has two <literal>Teacher</literal> instances for the same teacher that teaches at two different departments, it is harder to write a correct score constraint that constrains a teacher’s spare time on the original model than on an adjusted model.</simpara>
<simpara>Alternatively, you can sometimes also introduce <link linkend="cachedProblemFact"><emphasis>a cached problem fact</emphasis></link> to enrich the domain model for planning only.</simpara>
</note>
</section>
<section xml:id="planningEntity">
<title>Planning Entity</title>
<section xml:id="planningEntityAnnotation">
<title>Planning Entity Annotation</title>
<simpara>A planning entity is a JavaBean (POJO) that changes during solving, for example a <literal>Queen</literal> that changes to another row.
A planning problem has multiple planning entities, for example for a single n queens problem, each <literal>Queen</literal> is a planning entity.
But there is usually only one planning entity class, for example the <literal>Queen</literal> class.</simpara>
<simpara>A planning entity class needs to be annotated with the <literal>@PlanningEntity</literal> annotation.</simpara>
<simpara>Each planning entity class has one or more <emphasis>planning variables</emphasis> (which can be <link linkend="planningVariable">genuine</link> or <link linkend="shadowVariable">shadows</link>). It should also have one or more <emphasis>defining</emphasis> properties.
For example in n queens, a <literal>Queen</literal> is defined by its <literal>Column</literal> and has a planning variable <literal>Row</literal>.
This means that a Queen’s column never changes during solving, while its row does change.</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Queen {

    private Column column;

    // Planning variables: changes during planning, between score calculations.
    private Row row;

    // ... getters and setters
}</programlisting>
<simpara>A planning entity class can have multiple planning variables.
For example, a <literal>Lecture</literal> is defined by its <literal>Course</literal> and its index in that course (because one course has multiple lectures). Each <literal>Lecture</literal> needs to be scheduled into a <literal>Period</literal> and a <literal>Room</literal> so it has two planning variables (period and room). For example: the course Mathematics has eight lectures per week, of which the first lecture is Monday morning at 08:00 in room 212.</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Lecture {

    private Course course;
    private int lectureIndexInCourse;

    // Planning variables: changes during planning, between score calculations.
    private Period period;
    private Room room;

    // ...
}</programlisting>
<simpara>Without <link linkend="automaticScanningForAnnotations">automated scanning</link>, the solver configuration also needs to declare each planning entity class:</simpara>
<programlisting language="java" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;entityClass&gt;org.optaplanner.examples.nqueens.domain.Queen&lt;/entityClass&gt;
  ...
&lt;/solver&gt;</programlisting>
<simpara>Some uses cases have multiple planning entity classes.
For example: route freight and trains into railway network arcs, where each freight can use multiple trains over its journey and each train can carry multiple freights per arc.
Having multiple planning entity classes directly raises the implementation complexity of your use case.</simpara>
<note>
<simpara><emphasis>Do not create unnecessary planning entity classes.</emphasis> This leads to difficult <literal>Move</literal> implementations and slower score calculation.</simpara>
<simpara>For example, do not create a planning entity class to hold the total free time of a teacher, which needs to be kept up to date as the <literal>Lecture</literal> planning entities change.
Instead, calculate the free time in the score constraints (or as a <link linkend="shadowVariable">shadow variable</link>) and put the result per teacher into a logically inserted score object.</simpara>
<simpara>If historic data needs to be considered too, then create problem fact to hold the total of the historic assignments up to, but <emphasis>not including</emphasis>, the planning window (so that it does not change when a planning entity changes) and let the score constraints take it into account.</simpara>
</note>
</section>
<section xml:id="planningEntityDifficulty">
<title>Planning Entity Difficulty</title>
<simpara>Some optimization algorithms work more efficiently if they have an estimation of which planning entities are more difficult to plan.
For example: in bin packing bigger items are harder to fit, in course scheduling lectures with more students are more difficult to schedule, and in n queens the middle queens are more difficult to fit on the board.</simpara>
<note>
<simpara><emphasis role="strong">Do not try to use planning entity difficulty to implement a business
          constraint.</emphasis> It will not affect the score function: if we have infinite solving time, the returned solution will be the same.</simpara>
<simpara>To attain a schedule in which certain entities are scheduled earlier in the schedule, <link linkend="formalizeTheBusinessConstraints">add a score constraint</link> to change the score function so it prefers such solutions.
Only consider adding planning entity difficulty too if it can make the solver more efficient.</simpara>
</note>
<simpara>To allow the heuristics to take advantage of that domain specific information, set a <literal>difficultyComparatorClass</literal> to the <literal>@PlanningEntity</literal> annotation:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity(difficultyComparatorClass = CloudProcessDifficultyComparator.class)
public class CloudProcess {
    // ...
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class CloudProcessDifficultyComparator implements Comparator&lt;CloudProcess&gt; {

    public int compare(CloudProcess a, CloudProcess b) {
        return new CompareToBuilder()
                .append(a.getRequiredMultiplicand(), b.getRequiredMultiplicand())
                .append(a.getId(), b.getId())
                .toComparison();
    }

}</programlisting>
<simpara>Alternatively, you can also set a <literal>difficultyWeightFactoryClass</literal> to the <literal>@PlanningEntity</literal> annotation, so that you have access to the rest of the problem facts from the <literal>Solution</literal> too:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity(difficultyWeightFactoryClass = QueenDifficultyWeightFactory.class)
public class Queen {
    // ...
}</programlisting>
<simpara>See <link linkend="sortedSelection">sorted selection</link> for more information.</simpara>
<important>
<simpara>Difficulty should be implemented ascending: easy entities are lower, difficult entities are higher.
For example, in bin packing: small item &lt; medium item &lt; big item.</simpara>
<simpara>Although most algorithms start with the more difficult entities first, they just reverse the ordering.</simpara>
</important>
<simpara><emphasis>None of the current planning variable states should be used to compare planning entity difficulty.</emphasis> During Construction Heuristics, those variables are likely to be <literal>null</literal> anyway.
For example, a <literal>Queen</literal>'s <literal>row</literal> variable should not be used.</simpara>
</section>
</section>
<section xml:id="planningVariable">
<title>Planning Variable (genuine)</title>
<section xml:id="planningVariableAnnotation">
<title>Planning Variable Annotation</title>
<simpara>A planning variable is a JavaBean property (so a getter and setter) on a planning entity.
It points to a planning value, which changes during planning.
For example, a <literal>Queen</literal>'s <literal>row</literal> property is a genuine planning variable.
Note that even though a <literal>Queen</literal>'s <literal>row</literal> property changes to another <literal>Row</literal> during planning, no <literal>Row</literal> instance itself is changed.
Normally planning variables are genuine, but advanced cases can also have <link linkend="shadowVariable">shadows</link>.</simpara>
<simpara>A genuine planning variable getter needs to be annotated with the <literal>@PlanningVariable</literal> annotation, which needs a non-empty <literal>valueRangeProviderRefs</literal> property.</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Queen {
    ...

    private Row row;

    @PlanningVariable(valueRangeProviderRefs = {"rowRange"})
    public Row getRow() {
        return row;
    }

    public void setRow(Row row) {
        this.row = row;
    }

}</programlisting>
<simpara>The <literal>valueRangeProviderRefs</literal> property defines what are the possible planning values for this planning variable.
It references one or more <literal>@ValueRangeProvider</literal> <literal>id</literal>'s.</simpara>
<note>
<simpara>A @PlanningVariable annotation needs to be on a member in a class with a @PlanningEntity annotation.
It is ignored on parent classes or subclasses without that annotation.</simpara>
</note>
<simpara><link linkend="annotationAlternatives">Annotating the field</link> instead of the property works too:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Queen {
    ...

    @PlanningVariable(valueRangeProviderRefs = {"rowRange"})
    private Row row;

}</programlisting>
</section>
<section xml:id="nullablePlanningVariable">
<title>Nullable Planning Variable</title>
<simpara>By default, an initialized planning variable cannot be <literal>null</literal>, so an initialized solution will never use <literal>null</literal> for any of its planning variables.
In an over-constrained use case, this can be counterproductive.
For example: in task assignment with too many tasks for the workforce, we would rather leave low priority tasks unassigned instead of assigning them to an overloaded worker.</simpara>
<simpara>To allow an initialized planning variable to be <literal>null</literal>, set <literal>nullable</literal> to <literal>true</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(..., nullable = true)
    public Worker getWorker() {
        return worker;
    }</programlisting>
<important>
<simpara>Planner will automatically add the value <literal>null</literal> to the value range.
There is no need to add <literal>null</literal> in a collection used by a <literal>ValueRangeProvider</literal>.</simpara>
</important>
<note>
<simpara>Using a nullable planning variable implies that your score calculation is responsible for punishing (or even rewarding) variables with a null value.</simpara>
</note>
<simpara><link linkend="repeatedPlanning">Repeated planning</link> (especially <link linkend="realTimePlanning">real-time planning</link>) does not mix well with a nullable planning variable.
Every time the Solver starts or a problem fact change is made,
the <link linkend="constructionHeuristics">Construction Heuristics</link> will try to initialize all the <literal>null</literal> variables again, which can be a huge waste of time.
One way to deal with this, is to change when a planning entity should be reinitialized with an <literal>reinitializeVariableEntityFilter</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(..., nullable = true, reinitializeVariableEntityFilter = ReinitializeTaskFilter.class)
    public Worker getWorker() {
        return worker;
    }</programlisting>
</section>
<section xml:id="whenIsAPlanningVariableInitialized">
<title>When is a Planning Variable Considered Initialized?</title>
<simpara>A planning variable is considered initialized if its value is not <literal>null</literal> or if the variable is <literal>nullable</literal>.
So a nullable variable is always considered initialized, even when a custom <literal>reinitializeVariableEntityFilter</literal> triggers a reinitialization during construction heuristics.</simpara>
<simpara>A planning entity is initialized if all of its planning variables are initialized.</simpara>
<simpara>A <literal>Solution</literal> is initialized if all of its planning entities are initialized.</simpara>
</section>
</section>
<section xml:id="planningValueAndPlanningValueRange">
<title>Planning Value and Planning Value Range</title>
<section xml:id="planningValue">
<title>Planning Value</title>
<simpara>A planning value is a possible value for a genuine planning variable.
Usually, a planning value is a problem fact, but it can also be any object, for example a <literal>double</literal>.
It can even be another planning entity or even a interface implemented by both a planning entity and a problem fact.</simpara>
<simpara>A planning value range is the set of possible planning values for a planning variable.
This set can be a countable (for example row <literal>1</literal>, <literal>2</literal>, <literal>3</literal> or <literal>4</literal>) or uncountable (for example any <literal>double</literal> between <literal>0.0</literal> and <literal>1.0</literal>).</simpara>
</section>
<section xml:id="planningValueRangeProvider">
<title>Planning Value Range Provider</title>
<section xml:id="planningValueRangeProviderOverview">
<title>Overview</title>
<simpara>The value range of a planning variable is defined with the <literal>@ValueRangeProvider</literal> annotation.
A <literal>@ValueRangeProvider</literal> annotation always has a property <literal>id</literal>, which is referenced by the <literal>@PlanningVariable</literal>'s property <literal>valueRangeProviderRefs</literal>.</simpara>
<simpara>This annotation can be located on two types of methods:</simpara>
<itemizedlist>
<listitem>
<simpara>On the Solution: All planning entities share the same value range.</simpara>
</listitem>
<listitem>
<simpara>On the planning entity: The value range differs per planning entity. This is less common.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>A @ValueRangeProvider annotation needs to be on a member in a class with a @PlanningSolution or a @PlanningEntity annotation.
It is ignored on parent classes or subclasses without those annotations.</simpara>
</note>
<simpara>The return type of that method can be three types:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>Collection</literal>: The value range is defined by a <literal>Collection</literal> (usually a <literal>List</literal>) of its possible values.</simpara>
</listitem>
<listitem>
<simpara>Array: The value range is defined by an array of its possible values.</simpara>
</listitem>
<listitem>
<simpara><literal>ValueRange</literal>: The value range is defined by its bounds. This is less common.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="valueRangeProviderOnSolution">
<title><literal>ValueRangeProvider</literal> on the <literal>Solution</literal></title>
<simpara>All instances of the same planning entity class share the same set of possible planning values for that planning variable.
This is the most common way to configure a value range.</simpara>
<simpara>The <literal>Solution</literal> implementation has method that returns a <literal>Collection</literal> (or a <literal>ValueRange</literal>). Any value from that <literal>Collection</literal> is a possible planning value for this planning variable.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(valueRangeProviderRefs = {"rowRange"})
    public Row getRow() {
        return row;
    }</programlisting>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class NQueens {
    ...

    @ValueRangeProvider(id = "rowRange")
    public List&lt;Row&gt; getRowList() {
        return rowList;
    }

}</programlisting>
<important>
<simpara>That <literal>Collection</literal> (or <literal>ValueRange</literal>) must not contain the value <literal>null</literal>, not even for a <link linkend="nullablePlanningVariable">nullable planning variable</link>.</simpara>
</important>
<simpara><link linkend="annotationAlternatives">Annotating the field</link> instead of the property works too:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class NQueens {
    ...

    @ValueRangeProvider(id = "rowRange")
    private List&lt;Row&gt; rowList;

}</programlisting>
</section>
<section xml:id="valueRangeProviderOnPlanningEntity">
<title><literal>ValueRangeProvider</literal> on the Planning Entity</title>
<simpara>Each planning entity has its own value range (a set of possible planning values) for the planning variable.
For example, if a teacher can <emphasis role="strong">never</emphasis> teach in a room that does not belong to his department, lectures of that teacher can limit their room value range to the rooms of his department.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(valueRangeProviderRefs = {"departmentRoomRange"})
    public Room getRoom() {
        return room;
    }

    @ValueRangeProvider(id = "departmentRoomRange")
    public List&lt;Room&gt; getPossibleRoomList() {
        return getCourse().getTeacher().getDepartment().getRoomList();
    }</programlisting>
<simpara>Never use this to enforce a soft constraint (or even a hard constraint when the problem might not have a feasible solution). For example: <emphasis>Unless there is no other way</emphasis>, a teacher can not teach in a room that does not belong to his department.
In this case, the teacher should <emphasis>not</emphasis> be limited in his room value range (because sometimes there is no other way).</simpara>
<note>
<simpara>By limiting the value range specifically of one planning entity, you are effectively creating a <emphasis>built-in hard constraint</emphasis>.
This can have the benefit of severely lowering the number of possible solutions; however, it can also away the freedom of the optimization algorithms to temporarily break that constraint in order to escape from a local optimum.</simpara>
</note>
<simpara>A planning entity should <emphasis>not</emphasis> use other planning entities to determinate its value range.
That would only try to make the planning entity solve the planning problem itself and interfere with the optimization algorithms.</simpara>
<simpara>Every entity has its own <literal>List</literal> instance, unless multiple entities have the same value range.
For example, if teacher A and B belong to the same department, they use the same <literal>List&lt;Room&gt;</literal> instance.
Furthermore, each <literal>List</literal> contains a subset of the same set of planning value instances.
For example, if department A and B can both use room X, then their <literal>List&lt;Room&gt;</literal> instances contain the same <literal>Room</literal> instance.</simpara>
<note>
<simpara>A <literal>ValueRangeProvider</literal> on the planning entity consumes more memory than <literal>ValueRangeProvider</literal> on the Solution and disables certain automatic performance optimizations.</simpara>
</note>
<warning>
<simpara>A <literal>ValueRangeProvider</literal> on the planning entity is not currently compatible with a <link linkend="chainedPlanningVariable">chained</link> variable.</simpara>
</warning>
</section>
<section xml:id="valueRangeFactory">
<title><literal>ValueRangeFactory</literal></title>
<simpara>Instead of a <literal>Collection</literal>, you can also return a <literal>ValueRange</literal> or <literal>CountableValueRange</literal>, build by the <literal>ValueRangeFactory</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @ValueRangeProvider(id = "delayRange")
    public CountableValueRange&lt;Integer&gt; getDelayRange() {
        return ValueRangeFactory.createIntValueRange(0, 5000);
    }</programlisting>
<simpara>A <literal>ValueRange</literal> uses far less memory, because it only holds the bounds.
In the example above, a <literal>Collection</literal> would need to hold all <literal>5000</literal> ints, instead of just the two bounds.</simpara>
<simpara>Furthermore, an <literal>incrementUnit</literal> can be specified, for example if you have to buy stocks in units of 200 pieces:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @ValueRangeProvider(id = "stockAmountRange")
    public CountableValueRange&lt;Integer&gt; getStockAmountRange() {
         // Range: 0, 200, 400, 600, ..., 9999600, 9999800, 10000000
        return ValueRangeFactory.createIntValueRange(0, 10000000, 200);
    }</programlisting>
<note>
<simpara>Return <literal>CountableValueRange</literal> instead of <literal>ValueRange</literal> whenever possible (so Planner knows that it’s countable).</simpara>
</note>
<simpara>The <literal>ValueRangeFactory</literal> has creation methods for several value class types:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>boolean</literal>: A boolean range.</simpara>
</listitem>
<listitem>
<simpara><literal>int</literal>: A 32bit integer range.</simpara>
</listitem>
<listitem>
<simpara><literal>long</literal>: A 64bit integer range.</simpara>
</listitem>
<listitem>
<simpara><literal>double</literal>: A 64bit floating point range which only supports random selection (because it does not implement <literal>CountableValueRange</literal>).</simpara>
</listitem>
<listitem>
<simpara><literal>BigInteger</literal>: An arbitrary-precision integer range.</simpara>
</listitem>
<listitem>
<simpara><literal>BigDecimal</literal>: A decimal point range. By default, the increment unit is the lowest non-zero value in the scale of the bounds.</simpara>
</listitem>
<listitem>
<simpara><literal>Temporal</literal> (such as <literal>LocalDate</literal>, <literal>LocalDateTime</literal>, …​): A time range.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="combineValueRangeProviders">
<title>Combine ValueRangeProviders</title>
<simpara>Value range providers can be combined, for example:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(valueRangeProviderRefs = {"companyCarRange", "personalCarRange"})
    public Car getCar() {
        return car;
    }</programlisting>
<programlisting language="java" linenumbering="unnumbered">    @ValueRangeProvider(id = "companyCarRange")
    public List&lt;CompanyCar&gt; getCompanyCarList() {
        return companyCarList;
    }

    @ValueRangeProvider(id = "personalCarRange")
    public List&lt;PersonalCar&gt; getPersonalCarList() {
        return personalCarList;
    }</programlisting>
</section>
</section>
<section xml:id="planningValueStrength">
<title>Planning Value Strength</title>
<simpara>Some optimization algorithms work a bit more efficiently if they have an estimation of which planning values are stronger, which means they are more likely to satisfy a planning entity.
For example: in bin packing bigger containers are more likely to fit an item and in course scheduling bigger rooms are less likely to break the student capacity constraint.
Usually, the efficiency gain of planning value strength is far less than that of <link linkend="planningEntityDifficulty">planning entity difficulty</link>.</simpara>
<note>
<simpara><emphasis role="strong">Do not try to use planning value strength to implement a business
          constraint.</emphasis> It will not affect the score function: if we have infinite solving time, the returned solution will be the same.</simpara>
<simpara>To affect the score function, <link linkend="formalizeTheBusinessConstraints">add a score constraint</link>.
Only consider adding planning value strength too if it can make the solver more efficient.</simpara>
</note>
<simpara>To allow the heuristics to take advantage of that domain specific information, set a <literal>strengthComparatorClass</literal> to the <literal>@PlanningVariable</literal> annotation:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(..., strengthComparatorClass = CloudComputerStrengthComparator.class)
    public CloudComputer getComputer() {
        return computer;
    }</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class CloudComputerStrengthComparator implements Comparator&lt;CloudComputer&gt; {

    public int compare(CloudComputer a, CloudComputer b) {
        return new CompareToBuilder()
                .append(a.getMultiplicand(), b.getMultiplicand())
                .append(b.getCost(), a.getCost()) // Descending (but this is debatable)
                .append(a.getId(), b.getId())
                .toComparison();
    }

}</programlisting>
<note>
<simpara>If you have multiple planning value classes in the <emphasis>same</emphasis> value range, the <literal>strengthComparatorClass</literal> needs to implement a <literal>Comparator</literal> of a common superclass (for example <literal>Comparator&lt;Object&gt;</literal>) and be able to handle comparing instances of those different classes.</simpara>
</note>
<simpara>Alternatively, you can also set a <literal>strengthWeightFactoryClass</literal> to the <literal>@PlanningVariable</literal> annotation, so you have access to the rest of the problem facts from the solution too:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(..., strengthWeightFactoryClass = RowStrengthWeightFactory.class)
    public Row getRow() {
        return row;
    }</programlisting>
<simpara>See <link linkend="sortedSelection">sorted selection</link> for more information.</simpara>
<important>
<simpara>Strength should be implemented ascending: weaker values are lower, stronger values are higher.
For example in bin packing: small container &lt; medium container &lt; big container.</simpara>
</important>
<simpara><emphasis>None of the current planning variable state in any of the planning entities should be used to compare planning values.</emphasis> During construction heuristics, those variables are likely to be <literal>null</literal>.
For example, none of the <literal>row</literal> variables of any <literal>Queen</literal> may be used to determine the strength of a <literal>Row</literal>.</simpara>
</section>
<section xml:id="chainedPlanningVariable">
<title>Chained Planning Variable (TSP, VRP, …​)</title>
<simpara>Some use cases, such as TSP and Vehicle Routing, require <emphasis>chaining</emphasis>.
This means the planning entities point to each other and form a chain.
By modeling the problem as a set of chains (instead of a set of trees/loops), the search space is heavily reduced.</simpara>
<simpara>A planning variable that is chained either:</simpara>
<itemizedlist>
<listitem>
<simpara>Directly points to a problem fact (or planning entity), which is called an <emphasis>anchor</emphasis>.</simpara>
</listitem>
<listitem>
<simpara>Points to another planning entity with the same planning variable, which recursively points to an anchor.</simpara>
</listitem>
</itemizedlist>
<simpara>Here are some example of valid and invalid chains:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/chainPrinciples.png" align="center"/>
</imageobject>
<textobject><phrase>chainPrinciples</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Every initialized planning entity is part of an open-ended chain that begins from an anchor.</emphasis> A valid model means that:</simpara>
<itemizedlist>
<listitem>
<simpara>A chain is never a loop. The tail is always open.</simpara>
</listitem>
<listitem>
<simpara>Every chain always has exactly one anchor. The anchor is a problem fact, never a planning entity.</simpara>
</listitem>
<listitem>
<simpara>A chain is never a tree, it is always a line. Every anchor or planning entity has at most one trailing planning entity.</simpara>
</listitem>
<listitem>
<simpara>Every initialized planning entity is part of a chain.</simpara>
</listitem>
<listitem>
<simpara>An anchor with no planning entities pointing to it, is also considered a chain.</simpara>
</listitem>
</itemizedlist>
<warning>
<simpara>A planning problem instance given to the <literal>Solver</literal> must be valid.</simpara>
</warning>
<note>
<simpara>If your constraints dictate a closed chain, model it as an open-ended chain (which is easier to persist in a database) and implement a score constraint for the last entity back to the anchor.</simpara>
</note>
<simpara>The optimization algorithms and built-in <literal>Move</literal>s do chain correction to guarantee that the model stays valid:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/chainCorrection.png" align="center"/>
</imageobject>
<textobject><phrase>chainCorrection</phrase></textobject>
</mediaobject>
</informalfigure>
<warning>
<simpara>A custom <literal>Move</literal> implementation must leave the model in a valid state.</simpara>
</warning>
<simpara>For example, in TSP the anchor is a <literal>Domicile</literal> (in vehicle routing it is <literal>Vehicle</literal>):</simpara>
<programlisting language="java" linenumbering="unnumbered">public class Domicile ... implements Standstill {
    ...

    public City getCity() {...}

}</programlisting>
<simpara>The anchor (which is a problem fact) and the planning entity implement a common interface, for example TSP’s <literal>Standstill</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Standstill {

    City getCity();

}</programlisting>
<simpara>That interface is the return type of the planning variable.
Furthermore, the planning variable is chained.
For example TSP’s <literal>Visit</literal> (in vehicle routing it is <literal>Customer</literal>):</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Visit ... implements Standstill {
    ...

    public City getCity() {...}

    @PlanningVariable(graphType = PlanningVariableGraphType.CHAINED,
        valueRangeProviderRefs = {"domicileRange", "visitRange"})
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }

    public void setPreviousStandstill(Standstill previousStandstill) {
        this.previousStandstill = previousStandstill;
    }

}</programlisting>
<simpara>Notice how two value range providers are usually combined:</simpara>
<itemizedlist>
<listitem>
<simpara>The value range provider that holds the anchors, for example <literal>domicileList</literal>.</simpara>
</listitem>
<listitem>
<simpara>The value range provider that holds the initialized planning entities, for example <literal>visitList</literal>.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="shadowVariable">
<title>Shadow Variable</title>
<section xml:id="shadowVariableIntroduction">
<title>Introduction</title>
<simpara>A shadow variable is a planning variable whose correct value can be deduced from the state of the genuine planning variables.
Even though such a variable violates the principle of normalization by definition, in some use cases it can be very practical to use a shadow variable, especially to express the constraints more naturally.
For example in vehicle routing with time windows: the arrival time at a customer for a vehicle can be calculated based on the previously visited customers of that vehicle (and the known travel times between two locations).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/planningVariableListener.png" align="center"/>
</imageobject>
<textobject><phrase>planningVariableListener</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>When the customers for a vehicle change, the arrival time for each customer is automatically adjusted.
For more information, see the <link linkend="vehicleRoutingDomainModel">vehicle routing domain model</link>.</simpara>
<simpara>From a score calculation perspective, a shadow variable is like any other planning variable.
From an optimization perspective, Planner effectively only optimizes the genuine variables (and mostly ignores the shadow variables): it just assures that when a genuine variable changes, any dependent shadow variables are changed accordingly.</simpara>
<important>
<simpara><emphasis role="strong">Any class that has at least one shadow variable, is a planning entity class</emphasis>, even if it has no genuine planning variables.
That entity class needs to be defined in the solver configuration (unless classes are <link linkend="automaticScanningForAnnotations">automatically scanned</link>)
and be annotated accordingly.</simpara>
<simpara>An genuine planning entity class has at least one genuine planning variable, but can have shadow variables too.
A shadow planning entity class has no genuine planning variables and at least one shadow planning variable.</simpara>
</important>
<simpara>There are several built-in shadow variables:</simpara>
</section>
<section xml:id="bidirectionalVariable">
<title>Bi-directional Variable (Inverse Relation Shadow Variable)</title>
<simpara>Two variables are bi-directional if their instances always point to each other (unless one side points to <literal>null</literal> and the other side does not exist). So if A references B, then B references A.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/bidirectionalVariable.png" align="center"/>
</imageobject>
<textobject><phrase>bidirectionalVariable</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For a non-chained planning variable, the bi-directional relationship must be a many to one relationship.
To map a bi-directional relationship between two planning variables, annotate the master side (which is the genuine side) as a normal planning variable:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class CloudProcess {

    @PlanningVariable(...)
    public CloudComputer getComputer() {
        return computer;
    }
    public void setComputer(CloudComputer computer) {...}

}</programlisting>
<simpara>And then annotate the other side (which is the shadow side) with a <literal>@InverseRelationShadowVariable</literal> annotation on a <literal>Collection</literal> (usually a <literal>Set</literal> or <literal>List</literal>) property:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class CloudComputer {

    @InverseRelationShadowVariable(sourceVariableName = "computer")
    public List&lt;CloudProcess&gt; getProcessList() {
        return processList;
    }

}</programlisting>
<simpara>The <literal>sourceVariableName</literal> property is the name of the genuine planning variable on the return type of the getter (so the name of the genuine planning variable on the <emphasis>other</emphasis> side).</simpara>
<note>
<simpara>The shadow property, which is a <literal>Collection</literal>, can never be <literal>null</literal>.
If no genuine variable is referencing that shadow entity, then it is an empty <literal>Collection</literal>.
Furthermore it must be a mutable <literal>Collection</literal> because once the Solver starts initializing or changing genuine planning variables, it will add and remove to the <literal>Collection</literal>s of those shadow variables accordingly.</simpara>
</note>
<simpara>For a chained planning variable, the bi-directional relationship must be a one to one relationship.
In that case, the genuine side looks like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Customer ... {

    @PlanningVariable(graphType = PlanningVariableGraphType.CHAINED, ...)
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }
    public void setPreviousStandstill(Standstill previousStandstill) {...}

}</programlisting>
<simpara>And the shadow side looks like this:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Standstill {

    @InverseRelationShadowVariable(sourceVariableName = "previousStandstill")
    public Customer getNextCustomer() {
         return nextCustomer;
    }
    public void setNextCustomer(Customer nextCustomer) {...}

}</programlisting>
<warning>
<simpara>The input planning problem of a <literal>Solver</literal> must not violate bi-directional relationships.
If A points to B, then B must point to A.
Planner will not violate that principle during planning, but the input must not violate it.</simpara>
</warning>
</section>
<section xml:id="anchorShadowVariable">
<title>Anchor Shadow Variable</title>
<simpara>An anchor shadow variable is the anchor of <link linkend="chainedPlanningVariable">a chained variable</link>.</simpara>
<simpara>Annotate the anchor property as a <literal>@AnchorShadowVariable</literal> annotation:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity
public class Customer {

    @AnchorShadowVariable(sourceVariableName = "previousStandstill")
    public Vehicle getVehicle() {...}
    public void setVehicle(Vehicle vehicle) {...}

}</programlisting>
<simpara>The <literal>sourceVariableName</literal> property is the name of the chained variable on the same entity class.</simpara>
</section>
<section xml:id="customVariableListener">
<title>Custom <literal>VariableListener</literal></title>
<simpara>To update a shadow variable, Planner uses a <literal>VariableListener</literal>.
To define a custom shadow variable, write a custom <literal>VariableListener</literal>: implement the interface and annotate it on the shadow variable that needs to change.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(...)
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }

    @CustomShadowVariable(variableListenerClass = VehicleUpdatingVariableListener.class,
            sources = {@PlanningVariableReference(variableName = "previousStandstill")})
    public Vehicle getVehicle() {
        return vehicle;
    }</programlisting>
<simpara>The <literal>variableName</literal> is the variable that triggers changes in the shadow variable(s).</simpara>
<note>
<simpara>If the class of the trigger variable is different than the shadow variable, also specify the <literal>entityClass</literal> on <literal>@PlanningVariableReference</literal>.
In that case, make sure that that <literal>entityClass</literal> is also properly configured as a planning entity class in the solver config, or the <literal>VariableListener</literal> will simply never trigger.</simpara>
</note>
<simpara>For example, the <literal>VehicleUpdatingVariableListener</literal> assures that every <literal>Customer</literal> in a chain has the same <literal>Vehicle</literal>, namely the chain’s anchor.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class VehicleUpdatingVariableListener implements VariableListener&lt;Customer&gt; {

    public void afterEntityAdded(ScoreDirector scoreDirector, Customer customer) {
        updateVehicle(scoreDirector, customer);
    }

    public void afterVariableChanged(ScoreDirector scoreDirector, Customer customer) {
        updateVehicle(scoreDirector, customer);
    }

    ...

    protected void updateVehicle(ScoreDirector scoreDirector, Customer sourceCustomer) {
        Standstill previousStandstill = sourceCustomer.getPreviousStandstill();
        Vehicle vehicle = previousStandstill == null ? null : previousStandstill.getVehicle();
        Customer shadowCustomer = sourceCustomer;
        while (shadowCustomer != null &amp;&amp; shadowCustomer.getVehicle() != vehicle) {
            scoreDirector.beforeVariableChanged(shadowCustomer, "vehicle");
            shadowCustomer.setVehicle(vehicle);
            scoreDirector.afterVariableChanged(shadowCustomer, "vehicle");
            shadowCustomer = shadowCustomer.getNextCustomer();
        }
    }

}</programlisting>
<warning>
<simpara>A <literal>VariableListener</literal> can only change shadow variables.
It must never change a genuine planning variable or a problem fact.</simpara>
</warning>
<warning>
<simpara>Any change of a shadow variable must be told to the <literal>ScoreDirector</literal>.</simpara>
</warning>
<simpara>If one <literal>VariableListener</literal> changes two shadow variables (because having two separate <literal>VariableListener</literal>s would be inefficient), then annotate only the first shadow variable with the <literal>variableListenerClass</literal> and let the other shadow variable(s) reference the first shadow variable:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningVariable(...)
    public Standstill getPreviousStandstill() {
        return previousStandstill;
    }

    @CustomShadowVariable(variableListenerClass = TransportTimeAndCapacityUpdatingVariableListener.class,
            sources = {@PlanningVariableReference(variableName = "previousStandstill")})
    public Integer getTransportTime() {
        return transportTime;
    }

    @CustomShadowVariable(variableListenerRef = @PlanningVariableReference(variableName = "transportTime"))
    public Integer getCapacity() {
        return capacity;
    }</programlisting>
</section>
<section xml:id="variableListenerTriggeringOrder">
<title>VariableListener triggering order</title>
<simpara>All shadow variables are triggered by a <literal>VariableListener</literal>, regardless if it’s a built-in or a custom shadow variable.
The genuine and shadow variables form a graph, that determines the order in which the <literal>afterEntityAdded()</literal>, <literal>afterVariableChanged()</literal> and <literal>afterEntityRemoved()</literal> methods are called:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/shadowVariableOrder.png" align="center"/>
</imageobject>
<textobject><phrase>shadowVariableOrder</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>In the example above, D could have also been ordered after E (or F) because there is no direct or indirect dependency between D and E (or F).</simpara>
</note>
<simpara>Planner guarantees that:</simpara>
<itemizedlist>
<listitem>
<simpara>The first <literal>VariableListener</literal>'s <literal>after*()</literal> methods trigger <emphasis>after</emphasis> the last genuine variable has changed. Therefore the genuine variables (A and B in the example above) are guaranteed to be in a consistent state across all its instances (with values A1, A2 and B1 in the example above) because the entire <literal>Move</literal> has been applied.</simpara>
</listitem>
<listitem>
<simpara>The second <literal>VariableListener</literal>'s <literal>after*()</literal> methods trigger <emphasis>after</emphasis> the last first shadow variable has changed. Therefore the first shadow variable (C in the example above) are guaranteed to be in consistent state across all its instances (with values C1 and C2 in the example above). And of course the genuine variables too.</simpara>
</listitem>
<listitem>
<simpara>And so forth.</simpara>
</listitem>
</itemizedlist>
<simpara>Planner does not guarantee the order in which the <literal>after*()</literal> methods are called for the <emphasis>same</emphasis><literal>VariableListener</literal> with different parameters (such as A1 and A2 in the example above), although they are likely to be in the order in which they were affected.</simpara>
<simpara>By default, Planner does not guarantee that the events are unique.
For example, if a shadow variable on an entity is changed twice in the same move (for example by two different genuine variables), then that will cause the same event twice on the <literal>VariableListener</literal>s that are listening to that original shadow variable.
To avoid dealing with that complexity, overwrite the method <literal>requiresUniqueEntityEvents()</literal> to receive unique events at the cost of a small performance penalty:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class StartTimeUpdatingVariableListener implements VariableListener&lt;Task&gt; {

    @Override
    public boolean requiresUniqueEntityEvents() {
        return true;
    }

    ...
}</programlisting>
</section>
</section>
<section xml:id="planningProblemAndPlanningSolution">
<title>Planning Problem and Planning Solution</title>
<section xml:id="planningProblemInstance">
<title>Planning Problem Instance</title>
<simpara>A dataset for a planning problem needs to be wrapped in a class for the <literal>Solver</literal> to solve.
That solution class represents both the planning problem and (if solved) a solution.
It is annotated with a <literal>@PlanningSolution</literal> annotation.
For example in n queens, the solution class is the <literal>NQueens</literal> class, which contains a <literal>Column</literal> list, a <literal>Row</literal> list, and a <literal>Queen</literal> list.</simpara>
<simpara>A planning problem is actually an unsolved planning solution or - stated differently - an uninitialized solution.
For example in n queens, that <literal>NQueens</literal> class has the <literal>@PlanningSolution</literal> annotation, yet every <literal>Queen</literal> in an unsolved <literal>NQueens</literal> class is not yet assigned to a <literal>Row</literal> (their <literal>row</literal> property is <literal>null</literal>). That’s not a feasible solution.
It’s not even a possible solution.
It’s an uninitialized solution.</simpara>
</section>
<section xml:id="solutionClass">
<title>Solution Class</title>
<simpara>A solution class holds all problem facts, planning entities and a score.
It is annotated with a <literal>@PlanningSolution</literal> annotation.
For example, an <literal>NQueens</literal> instance holds a list of all columns, all rows and all <literal>Queen</literal> instances:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class NQueens {

    // Problem facts
    private int n;
    private List&lt;Column&gt; columnList;
    private List&lt;Row&gt; rowList;

    // Planning entities
    private List&lt;Queen&gt; queenList;

    private SimpleScore score;

    ...
}</programlisting>
<simpara>Without <link linkend="automaticScanningForAnnotations">automated scanning</link>, the solver configuration also needs to declare the planning solution class:</simpara>
<programlisting language="java" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;solutionClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/solutionClass&gt;
  ...
&lt;/solver&gt;</programlisting>
</section>
<section xml:id="planningEntitiesOfASolution">
<title>Planning Entities of a Solution (<literal>@PlanningEntityCollectionProperty</literal>)</title>
<simpara>Planner needs to extract the entity instances from the solution instance.
It gets those collection(s) by calling every getter (or field) that is annotated with <literal>@PlanningEntityCollectionProperty</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class NQueens {
    ...

    private List&lt;Queen&gt; queenList;

    @PlanningEntityCollectionProperty
    public List&lt;Queen&gt; getQueenList() {
        return queenList;
    }

}</programlisting>
<simpara>There can be multiple <literal>@PlanningEntityCollectionProperty</literal> annotated members.
Those can even return a <literal>Collection</literal> with the same entity class type.
Instead of <literal>Collection</literal>, it can also return an array.</simpara>
<note>
<simpara>A <literal>@PlanningEntityCollectionProperty</literal> annotation needs to be on a member in a class with a <literal>@PlanningSolution</literal> annotation.
It is ignored on parent classes or subclasses without that annotation.</simpara>
</note>
<simpara>In rare cases, a planning entity might be a singleton: use <literal>@PlanningEntityProperty</literal> on its getter (or field) instead.</simpara>
<simpara>Both annotations can also be <link linkend="autoDiscoverSolutionProperties">auto discovered</link> if enabled.</simpara>
</section>
<section xml:id="scoreOfASolution">
<title><literal>Score</literal> of a Solution (<literal>@PlanningScore</literal>)</title>
<simpara>A <literal>Solution</literal> requires a score property (or field), which is annotated with a <literal>@PlanningScore</literal> annotation.
The score property is <literal>null</literal> if the the score hasn’t been calculated yet.
The <literal>score</literal> property is typed to the specific <literal>Score</literal> implementation of your use case.
For example, <literal>NQueens</literal> uses a <link linkend="simpleScore">SimpleScore</link>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class NQueens {
    ...

    private SimpleScore score;

    @PlanningScore
    public SimpleScore getScore() {
        return score;
    }
    public void setScore(SimpleScore score) {
        this.score = score;
    }

}</programlisting>
<simpara>Most use cases use a <link linkend="hardSoftScore">HardSoftScore</link> instead:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class CloudBalance {
    ...

    private HardSoftScore score;

    @PlanningScore
    public HardSoftScore getScore() {
        return score;
    }

    public void setScore(HardSoftScore score) {
        this.score = score;
    }

}</programlisting>
<simpara>Some use cases use <link linkend="scoreType">other score types</link>.</simpara>
<simpara>This annotation can also be <link linkend="autoDiscoverSolutionProperties">auto discovered</link> if enabled.</simpara>
</section>
<section xml:id="getProblemFacts">
<title>Problem Facts of a Solution (<literal>@ProblemFactCollectionProperty</literal>)</title>
<simpara>For <link linkend="droolsScoreCalculation">Drools score calculation</link>, Planner needs to extract the problem fact instances from the solution instance.
It gets those collection(s) by calling every method (or field) that is annotated with <literal>@ProblemFactCollectionProperty</literal>.
All objects returned by those methods will be inserted into the Drools session, so the score rules can access them.
For example in <literal>NQueens</literal> all <literal>Column</literal> and <literal>Row</literal> instances are problem facts.</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class NQueens {
    ...

    private List&lt;Column&gt; columnList;
    private List&lt;Row&gt; rowList;

    @ProblemFactCollectionProperty
    public List&lt;Column&gt; getColumnList() {
        return columnList;
    }

    @ProblemFactCollectionProperty
    public List&lt;Row&gt; getRowList() {
        return rowList;
    }

}</programlisting>
<simpara>All planning entities are automatically inserted into the Drools working memory.
Do note add an annotation on their properties.</simpara>
<note>
<simpara>The problem facts methods are not called often: at most only once per solver phase per solver thread.</simpara>
</note>
<simpara>There can be multiple <literal>@ProblemFactCollectionProperty</literal> annotated members.
Those can even return a <literal>Collection</literal> with the same class type, but they shouldn’t return the same instance twice.
Instead of <literal>Collection</literal>, it can also return an array.</simpara>
<note>
<simpara>A @ProblemFactCollectionProperty annotation needs to be on a member in a class with a @PlanningSolution annotation.
It is ignored on parent classes or subclasses without that annotation.</simpara>
</note>
<simpara>In rare cases, a problem fact might be a singleton: use <literal>@ProblemFactProperty</literal> on its method (or field) instead.</simpara>
<simpara>Both annotations can also be <link linkend="autoDiscoverSolutionProperties">auto discovered</link> if enabled.</simpara>
<section xml:id="cachedProblemFact">
<title>Cached Problem Fact</title>
<simpara>A cached problem fact is a problem fact that does not exist in the real domain model, but is calculated before the <literal>Solver</literal> really starts solving.
The problem facts methods have the opportunity to enrich the domain model with such cached problem facts, which can lead to simpler and faster score constraints.</simpara>
<simpara>For example in examination, a cached problem fact <literal>TopicConflict</literal> is created for every two <literal>Topic</literal>s which share at least one <literal>Student</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @ProblemFactCollectionProperty
    private List&lt;TopicConflict&gt; calculateTopicConflictList() {
        List&lt;TopicConflict&gt; topicConflictList = new ArrayList&lt;TopicConflict&gt;();
        for (Topic leftTopic : topicList) {
            for (Topic rightTopic : topicList) {
                if (leftTopic.getId() &lt; rightTopic.getId()) {
                    int studentSize = 0;
                    for (Student student : leftTopic.getStudentList()) {
                        if (rightTopic.getStudentList().contains(student)) {
                            studentSize++;
                        }
                    }
                    if (studentSize &gt; 0) {
                        topicConflictList.add(new TopicConflict(leftTopic, rightTopic, studentSize));
                    }
                }
            }
        }
        return topicConflictList;
    }</programlisting>
<simpara>Where a score constraint needs to check that no two exams with a topic that shares a student are scheduled close together (depending on the constraint: at the same time, in a row, or in the same day), the <literal>TopicConflict</literal> instance can be used as a problem fact, rather than having to combine every two <literal>Student</literal> instances.</simpara>
</section>
</section>
<section xml:id="autoDiscoverSolutionProperties">
<title>Auto Discover Solution Properties</title>
<simpara>Instead of configuring each property (or field) annotation explicitly,
some can also be deduced automatically by Planner.
For example, on the cloud balancing example:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution(autoDiscoverMemberType = AutoDiscoverMemberType.FIELD)
public class CloudBalance {

    // Auto discovered as @ProblemFactCollectionProperty
    @ValueRangeProvider(id = "computerRange") // Not (yet) auto discovered
    private List&lt;CloudComputer&gt; computerList;

    // Auto discovered as @PlanningEntityCollectionProperty
    private List&lt;CloudProcess&gt; processList;

    // Auto discovered as @PlanningScore
    private HardSoftScore score;

    ...
}</programlisting>
<simpara>The <literal>AutoDiscoverMemberType</literal> can be:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NONE</literal>: No auto discovery.</simpara>
</listitem>
<listitem>
<simpara><literal>FIELD</literal>: Auto discover all fields on the <literal>@PlanningSolution</literal> class</simpara>
</listitem>
<listitem>
<simpara><literal>GETTER</literal>: Auto discover all getters on the <literal>@PlanningSolution</literal> class</simpara>
</listitem>
</itemizedlist>
<simpara>The automatic annotation is based on the field type (or getter return type):</simpara>
<itemizedlist>
<listitem>
<simpara><literal>@ProblemFactProperty</literal>: when it isn’t a <literal>Collection</literal>, an array, a <literal>@PlanningEntity</literal> class or a <literal>Score</literal></simpara>
</listitem>
<listitem>
<simpara><literal>@ProblemFactCollectionProperty</literal>: when it’s a <literal>Collection</literal> (or array) of a type that isn’t a <literal>@PlanningEntity</literal> class</simpara>
</listitem>
<listitem>
<simpara><literal>@PlanningEntityProperty</literal>: when it is a configured <literal>@PlanningEntity</literal> class or subclass</simpara>
</listitem>
<listitem>
<simpara><literal>@PlanningEntityCollectionProperty</literal>: when it’s a <literal>Collection</literal> (or array) of a type that is a configured <literal>@PlanningEntity</literal> class or subclass</simpara>
</listitem>
<listitem>
<simpara><literal>@PlanningScore</literal>: when it is a <literal>Score</literal> or subclass</simpara>
</listitem>
</itemizedlist>
<simpara>These automatic annotation can still be overwritten per field (or getter).
Specifically, a <link linkend="bendableScore">BendableScore</link> always needs to override
with an explicit <literal>@PlanningScore</literal> annotation to define the number of hard and soft levels.</simpara>
</section>
<section xml:id="cloningASolution">
<title>Cloning a Solution</title>
<simpara>Most (if not all) optimization algorithms clone the solution each time they encounter a new best solution (so they can recall it later) or to work with multiple solutions in parallel.</simpara>
<note>
<simpara>There are many ways to clone, such as a shallow clone, deep clone, …​ This context focuses on <emphasis>a planning clone</emphasis>.</simpara>
</note>
<simpara>A planning clone of a solution must fulfill these requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>The clone must represent the same planning problem. Usually it reuses the same instances of the problem facts and problem fact collections as the original.</simpara>
</listitem>
<listitem>
<simpara>The clone must use different, cloned instances of the entities and entity collections. Changes to an original <literal>Solution</literal> entity’s variables must not affect its clone.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/solutionCloning.png" align="center"/>
</imageobject>
<textobject><phrase>solutionCloning</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Implementing a planning clone method is hard, therefore you do not need to implement it.</emphasis></simpara>
<section xml:id="fieldAccessingSolutionCloner">
<title><literal>FieldAccessingSolutionCloner</literal></title>
<simpara>This <literal>SolutionCloner</literal> is used by default.
It works well for most use cases.</simpara>
<warning>
<simpara>When the <literal>FieldAccessingSolutionCloner</literal> clones one of your collections or maps,
it may not recognize the implementation and replace it with <literal>ArrayList</literal>, <literal>LinkedHashSet</literal>, <literal>TreeSet</literal>, <literal>LinkedHashMap</literal>
or <literal>TreeMap</literal> (whichever is more applicable) .
It recognizes most of the common JDK collection and map implementations.</simpara>
</warning>
<simpara>The <literal>FieldAccessingSolutionCloner</literal> does not clone problem facts by default.
If any of your problem facts needs to be deep cloned for a planning clone, for example if the problem fact references a planning entity or the planning solution, mark it with a <literal>@DeepPlanningClone</literal> annotation:</simpara>
<programlisting language="java" linenumbering="unnumbered">@DeepPlanningClone
public class SeatDesignationDependency {
    private SeatDesignation leftSeatDesignation; // planning entity
    private SeatDesignation rightSeatDesignation; // planning entity
    ...
}</programlisting>
<simpara>In the example above, because <literal>SeatDesignation</literal> is a planning entity (which is deep planning cloned automatically), <literal>SeatDesignationDependency</literal> must also be deep planning cloned.</simpara>
<simpara>Alternatively, the <literal>@DeepPlanningClone</literal> annotation can also be used on a getter method.</simpara>
</section>
<section xml:id="customCloning">
<title>Custom Cloning with a SolutionCloner</title>
<simpara>To use a customer cloner, configure it on the planning solution:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution(solutionCloner = NQueensSolutionCloner.class)
public class NQueens {
    ...
}</programlisting>
<simpara>For example, a <literal>NQueens</literal> planning clone only deep clones all <literal>Queen</literal> instances.
So when the original solution changes (later on during planning) and one or more <literal>Queen</literal> instances change,
the planning clone isn’t affected.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class NQueensSolutionCloner implements SolutionCloner&lt;NQueens&gt; {

    @Override
    public NQueens cloneSolution(CloneLedger ledger, NQueens original) {
        NQueens clone = new NQueens();
        ledger.registerClone(original, clone);
        clone.setId(original.getId());
        clone.setN(original.getN());
        clone.setColumnList(original.getColumnList());
        clone.setRowList(original.getRowList());
        List&lt;Queen&gt; queenList = original.getQueenList();
        List&lt;Queen&gt; clonedQueenList = new ArrayList&lt;Queen&gt;(queenList.size());
        for (Queen originalQueen : queenList) {
            Queen cloneQueen = new Queen();
            ledger.registerClone(originalQueen, cloneQueen);
            cloneQueen.setId(originalQueen.getId());
            cloneQueen.setColumn(originalQueen.getColumn());
            cloneQueen.setRow(originalQueen.getRow());
            clonedQueenList.add(cloneQueen);
        }
        clone.setQueenList(clonedQueenList);
        clone.setScore(original.getScore());
        return clone;
    }

}</programlisting>
<simpara><emphasis>The <literal>cloneSolution()</literal> method should only deep clone the planning entities.</emphasis>
Notice that the problem facts, such as <literal>Column</literal> and <literal>Row</literal> are normally <emphasis>not</emphasis> cloned: even their <literal>List</literal> instances are <emphasis>not</emphasis> cloned.
If the problem facts were cloned too, then you would have to make sure that the new planning entity clones also refer to the new problem facts clones used by the cloned solution.
For example, if you were to clone all <literal>Row</literal> instances, then each <literal>Queen</literal> clone and the <literal>NQueens</literal> clone itself should refer to those new <literal>Row</literal> clones.</simpara>
<warning>
<simpara>Cloning an entity with a <link linkend="chainedPlanningVariable">chained</link> variable is devious: a variable of an entity A might point to another entity B.
If A is cloned, then its variable must point to the clone of B, not the original B.</simpara>
</warning>
</section>
</section>
<section xml:id="createAnUninitializedSolution">
<title>Create an Uninitialized Solution</title>
<simpara>Create a <literal>Solution</literal> instance to represent your planning problem’s dataset, so it can be set on the <literal>Solver</literal> as the planning problem to solve.
For example in n queens, an <literal>NQueens</literal> instance is created with the required <literal>Column</literal> and <literal>Row</literal> instances and every <literal>Queen</literal> set to a different <literal>column</literal> and every <literal>row</literal> set to <literal>null</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">    private NQueens createNQueens(int n) {
        NQueens nQueens = new NQueens();
        nQueens.setId(0L);
        nQueens.setN(n);
        nQueens.setColumnList(createColumnList(nQueens));
        nQueens.setRowList(createRowList(nQueens));
        nQueens.setQueenList(createQueenList(nQueens));
        return nQueens;
    }

    private List&lt;Queen&gt; createQueenList(NQueens nQueens) {
        int n = nQueens.getN();
        List&lt;Queen&gt; queenList = new ArrayList&lt;Queen&gt;(n);
        long id = 0L;
        for (Column column : nQueens.getColumnList()) {
            Queen queen = new Queen();
            queen.setId(id);
            id++;
            queen.setColumn(column);
            // Notice that we leave the PlanningVariable properties on null
            queenList.add(queen);
        }
        return queenList;
    }</programlisting>
<figure>
<title>Uninitialized Solution for the Four Queens Puzzle</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/uninitializedNQueens04.png" align="left"/>
</imageobject>
<textobject><phrase>uninitializedNQueens04</phrase></textobject>
</mediaobject>
</figure>
<simpara>Usually, most of this data comes from your data layer, and your <literal>Solution</literal> implementation just aggregates that data and creates the uninitialized planning entity instances to plan:</simpara>
<programlisting language="java" linenumbering="unnumbered">        private void createLectureList(CourseSchedule schedule) {
            List&lt;Course&gt; courseList = schedule.getCourseList();
            List&lt;Lecture&gt; lectureList = new ArrayList&lt;Lecture&gt;(courseList.size());
            long id = 0L;
            for (Course course : courseList) {
                for (int i = 0; i &lt; course.getLectureSize(); i++) {
                    Lecture lecture = new Lecture();
                    lecture.setId(id);
                    id++;
                    lecture.setCourse(course);
                    lecture.setLectureIndexInCourse(i);
                    // Notice that we leave the PlanningVariable properties (period and room) on null
                    lectureList.add(lecture);
                }
            }
            schedule.setLectureList(lectureList);
        }</programlisting>
</section>
</section>
</section>
<section xml:id="useTheSolver">
<title>Use the <literal>Solver</literal></title>
<section xml:id="theSolverInterface">
<title>The <literal>Solver</literal> Interface</title>
<simpara>A <literal>Solver</literal> implementation will solve your planning problem.</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Solver&lt;Solution_&gt; {

    Solution_ solve(Solution_ problem);

    ...
}</programlisting>
<simpara>A <literal>Solver</literal> can only solve one planning problem instance at a time.
A <literal>Solver</literal> should only be accessed from a single thread, except for the methods that are specifically javadocced as being thread-safe.
It is built with a <literal>SolverFactory</literal>, there is no need to implement it yourself.</simpara>
</section>
<section xml:id="solvingAProblem">
<title>Solving a Problem</title>
<simpara>Solving a problem is quite easy once you have:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>Solver</literal> built from a solver configuration</simpara>
</listitem>
<listitem>
<simpara>A <literal>Solution</literal> that represents the planning problem instance</simpara>
</listitem>
</itemizedlist>
<simpara>Just provide the planning problem as argument to the <literal>solve()</literal> method and it will return the best solution found:</simpara>
<programlisting language="java" linenumbering="unnumbered">    NQueens bestSolution = solver.solve(problem);</programlisting>
<simpara>For example in n queens, the <literal>solve()</literal> method will return an <literal>NQueens</literal> instance with every <literal>Queen</literal> assigned to a <literal>Row</literal>.</simpara>
<figure>
<title>Best Solution for the Four Queens Puzzle in 8ms (Also an Optimal Solution)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PlannerConfiguration/solvedNQueens04.png" align="left"/>
</imageobject>
<textobject><phrase>solvedNQueens04</phrase></textobject>
</mediaobject>
</figure>
<simpara>The <literal>solve(Solution)</literal> method can take a long time (depending on the problem size and the solver configuration). The <literal>Solver</literal> intelligently wades through <link linkend="searchSpaceSize">the search space</link> of possible solutions and remembers the best solution it encounters during solving.
Depending on a number factors (including problem size, how much time the <literal>Solver</literal> has, the solver configuration, …​), <link linkend="doesPlannerFindTheOptimalSolution">that best solution might or might not be an optimal solution</link>.</simpara>
<note>
<simpara>The <literal>Solution</literal> instance given to the method <literal>solve(Solution)</literal> is changed by the <literal>Solver</literal>, but do not mistake it for the best solution.</simpara>
<simpara>The <literal>Solution</literal> instance returned by the methods <literal>solve(Solution)</literal> or <literal>getBestSolution()</literal> is most likely <link linkend="cloningASolution">a planning clone</link> of the instance given to the method <literal>solve(Solution)</literal>, which implies it is a different instance.</simpara>
</note>
<note>
<simpara>The <literal>Solution</literal> instance given to the <literal>solve(Solution)</literal> method does not need to be uninitialized.
It can be partially or fully initialized, which is often the case in <link linkend="repeatedPlanning">repeated planning</link>.</simpara>
</note>
</section>
<section xml:id="environmentMode">
<title>Environment Mode: Are There Bugs in my Code?</title>
<simpara>The environment mode allows you to detect common bugs in your implementation.
It does not affect the <link linkend="logging">logging level</link>.</simpara>
<simpara>You can set the environment mode in the solver configuration XML file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;environmentMode&gt;FAST_ASSERT&lt;/environmentMode&gt;
  ...
&lt;/solver&gt;</programlisting>
<simpara>A solver has a single <literal>Random</literal> instance.
Some solver configurations use the <literal>Random</literal> instance a lot more than others.
For example, Simulated Annealing depends highly on random numbers, while Tabu Search only depends on it to deal with score ties.
The environment mode influences the seed of that <literal>Random</literal> instance.</simpara>
<simpara>These are the environment modes:</simpara>
<section xml:id="environmentModeFullAssert">
<title>FULL_ASSERT</title>
<simpara>The FULL_ASSERT mode turns on all assertions (such as assert that the incremental score calculation is uncorrupted for each move) to fail-fast on a bug in a Move implementation, a score rule, the rule engine itself, …​</simpara>
<simpara>This mode is reproducible (see the reproducible mode). It is also intrusive because it calls the method <literal>calculateScore()</literal> more frequently than a non-assert mode.</simpara>
<simpara>The FULL_ASSERT mode is horribly slow (because it does not rely on incremental score calculation).</simpara>
</section>
<section xml:id="environmentModeNonIntrusiveFullAssert">
<title>NON_INTRUSIVE_FULL_ASSERT</title>
<simpara>The NON_INTRUSIVE_FULL_ASSERT turns on several assertions to fail-fast on a bug in a Move implementation, a score rule, the rule engine itself, …​</simpara>
<simpara>This mode is reproducible (see the reproducible mode). It is non-intrusive because it does not call the method <literal>calculateScore()</literal> more frequently than a non assert mode.</simpara>
<simpara>The NON_INTRUSIVE_FULL_ASSERT mode is horribly slow (because it does not rely on incremental score calculation).</simpara>
</section>
<section xml:id="environmentModeFastAssert">
<title>FAST_ASSERT</title>
<simpara>The FAST_ASSERT mode turns on most assertions (such as assert that an undoMove’s score is the same as before the Move) to fail-fast on a bug in a Move implementation, a score rule, the rule engine itself, …​</simpara>
<simpara>This mode is reproducible (see the reproducible mode). It is also intrusive because it calls the method <literal>calculateScore()</literal> more frequently than a non assert mode.</simpara>
<simpara>The FAST_ASSERT mode is slow.</simpara>
<simpara>It is recommended to write a test case that does a short run of your planning problem with the FAST_ASSERT mode on.</simpara>
</section>
<section xml:id="environmentModeReproducible">
<title>REPRODUCIBLE (default)</title>
<simpara>The reproducible mode is the default mode because it is recommended during development.
In this mode, two runs in the same Planner version will execute the same code in the same order. <emphasis role="strong">Those two
        runs will have the same result at every step</emphasis>, except if the note below applies.
This enables you to reproduce bugs consistently.
It also allows you to benchmark certain refactorings (such as a score constraint performance optimization) fairly across runs.</simpara>
<note>
<simpara>Despite the reproducible mode, your application might still not be fully reproducible because of:</simpara>
<itemizedlist>
<listitem>
<simpara>Use of <literal>HashSet</literal> (or another <literal>Collection</literal> which has an inconsistent order between JVM runs) for collections of planning entities or planning values (but not normal problem facts), especially in the <literal>Solution</literal> implementation. Replace it with <literal>LinkedHashSet</literal>.</simpara>
</listitem>
<listitem>
<simpara>Combining a time gradient dependent algorithms (most notably Simulated Annealing) together with time spent termination. A sufficiently large difference in allocated CPU time will influence the time gradient values. Replace Simulated Annealing with Late Acceptance. Or instead, replace time spent termination with step count termination.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>The reproducible mode can be slightly slower than the non-reproducible mode.
If your production environment can benefit from reproducibility, use this mode in production.</simpara>
<simpara>In practice, this mode uses the default, fixed <link linkend="randomNumberGenerator">random seed</link> if no seed is specified, and it also disables certain concurrency optimizations (such as work stealing).</simpara>
</section>
<section xml:id="environmentModeProduction">
<title>NON_REPRODUCIBLE</title>
<simpara>The non-reproducible mode can be slightly faster than the reproducible mode.
Avoid using it during development as it makes debugging and bug fixing painful.
If your production environment doesn’t care about reproducibility, use this mode in production.</simpara>
<simpara>In practice, this mode uses no fixed <link linkend="randomNumberGenerator">random seed</link> if no seed is specified.</simpara>
</section>
</section>
<section xml:id="logging">
<title>Logging Level: What is the <literal>Solver</literal> Doing?</title>
<simpara>The best way to illuminate the black box that is a <literal>Solver</literal>, is to play with the logging level:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">error</emphasis>: Log errors, except those that are thrown to the calling code as a <literal>RuntimeException</literal>.</simpara>
<note>
<simpara><emphasis role="strong">If an error happens, Planner normally fails fast</emphasis>: it throws a subclass of <literal>RuntimeException</literal> with a detailed message to the calling code.
It does not log it as an error itself to avoid duplicate log messages.
Except if the calling code explicitly catches and eats that <literal>RuntimeException</literal>, a <literal>Thread</literal>'s default <literal>ExceptionHandler</literal> will log it as an error anyway.
Meanwhile, the code is disrupted from doing further harm or obfuscating the error.</simpara>
</note>
</listitem>
<listitem>
<simpara><emphasis role="strong">warn</emphasis>: Log suspicious circumstances.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">info</emphasis>: Log every phase and the solver itself. See <link linkend="scopeOverview">scope overview</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">debug</emphasis>: Log every step of every phase. See <link linkend="scopeOverview">scope overview</link>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">trace</emphasis>: Log every move of every step of every phase. See <link linkend="scopeOverview">scope overview</link>.</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Turning on <literal>trace</literal> logging, will slow down performance considerably: it is often four times slower.
However, it is invaluable during development to discover a bottleneck.</simpara>
<simpara>Even <literal>debug</literal> logging can slow down performance considerably for fast stepping algorithms (such as Late Acceptance and Simulated Annealing),
but not for slow stepping algorithms (such as Tabu Search).</simpara>
<simpara>Both cause congestion in <link linkend="multiThreadedSolving">multi-threaded solving</link> with most appenders, see below.</simpara>
<simpara>In Eclipse, <literal>debug</literal> logging to the console tends to cause congestion with a score calculation speeds above 10 000 per second.
Nor IntelliJ, nor the Maven command line suffer from this problem.</simpara>
</note>
<simpara>For example, set it to <literal>debug</literal> logging, to see when the phases end and how fast steps are taken:</simpara>
<screen>INFO  Solving started: time spent (3), best score (-4init/0), random (JDK with seed 0).
DEBUG     CH step (0), time spent (5), score (-3init/0), selected move count (1), picked move (Queen-2 {null -&gt; Row-0}).
DEBUG     CH step (1), time spent (7), score (-2init/0), selected move count (3), picked move (Queen-1 {null -&gt; Row-2}).
DEBUG     CH step (2), time spent (10), score (-1init/0), selected move count (4), picked move (Queen-3 {null -&gt; Row-3}).
DEBUG     CH step (3), time spent (12), score (-1), selected move count (4), picked move (Queen-0 {null -&gt; Row-1}).
INFO  Construction Heuristic phase (0) ended: time spent (12), best score (-1), score calculation speed (9000/sec), step total (4).
DEBUG     LS step (0), time spent (19), score (-1),     best score (-1), accepted/selected move count (12/12), picked move (Queen-1 {Row-2 -&gt; Row-3}).
DEBUG     LS step (1), time spent (24), score (0), new best score (0), accepted/selected move count (9/12), picked move (Queen-3 {Row-3 -&gt; Row-2}).
INFO  Local Search phase (1) ended: time spent (24), best score (0), score calculation speed (4000/sec), step total (2).
INFO  Solving ended: time spent (24), best score (0), score calculation speed (7000/sec), phase total (2), environment mode (REPRODUCIBLE).</screen>
<simpara>All time spent values are in milliseconds.</simpara>
<simpara>Everything is logged to <link xlink:href="http://www.slf4j.org/">SLF4J</link>, which is a simple logging facade
which delegates every log message to Logback, Apache Commons Logging, Log4j or java.util.logging.
Add a dependency to the logging adaptor for your logging framework of choice.</simpara>
<simpara>If you are not using any logging framework yet, use Logback by adding this Maven dependency (there is no need to add an extra bridge dependency):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
      &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>Configure the logging level on the <literal>org.optaplanner</literal> package in your <literal>logback.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;configuration&gt;

  &lt;logger name="org.optaplanner" level="debug"/&gt;

  ...

&lt;/configuration&gt;</programlisting>
<simpara>If it isn’t picked up, temporarily add the system property <literal>-Dlogback.debug=true</literal> to figure out why.</simpara>
<note>
<simpara>When running multiple solvers or one <link linkend="multiThreadedSolving">multi-threaded solver</link>,
most appenders (including the console) cause congestion with <literal>debug</literal> and <literal>trace</literal> logging.
Switch to an async appender to avoid this problem or turn off <literal>debug</literal> logging.</simpara>
</note>
<simpara>If instead, you are still using Log4J 1.x (and you do not want to switch to its faster successor, Logback), add the bridge dependency:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
      &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
      &lt;version&gt;1.x&lt;/version&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>And configure the logging level on the package <literal>org.optaplanner</literal> in your <literal>log4j.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"&gt;

  &lt;category name="org.optaplanner"&gt;
    &lt;priority value="debug" /&gt;
  &lt;/category&gt;

  ...

&lt;/log4j:configuration&gt;</programlisting>
<note>
<simpara>In a multitenant application, multiple <literal>Solver</literal> instances might be running at the same time.
To separate their logging into distinct files, surround the <literal>solve()</literal> call with an <link xlink:href="http://logback.qos.ch/manual/mdc.html">MDC</link>:</simpara>
<programlisting language="java" linenumbering="unnumbered">        MDC.put("tenant.name",tenantName);
        MySolution bestSolution = solver.solve(problem);
        MDC.remove("tenant.name");</programlisting>
<simpara>Then configure your logger to use different files for each <literal>${tenant.name}</literal>.
For example in Logback, use a <literal>SiftingAppender</literal> in <literal>logback.xml</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;appender name="fileAppender" class="ch.qos.logback.classic.sift.SiftingAppender"&gt;
    &lt;discriminator&gt;
      &lt;key&gt;tenant.name&lt;/key&gt;
      &lt;defaultValue&gt;unknown&lt;/defaultValue&gt;
    &lt;/discriminator&gt;
    &lt;sift&gt;
      &lt;appender name="fileAppender.${tenant.name}" class="...FileAppender"&gt;
        &lt;file&gt;local/log/optaplanner-${tenant.name}.log&lt;/file&gt;
        ...
      &lt;/appender&gt;
    &lt;/sift&gt;
  &lt;/appender&gt;</programlisting>
</note>
</section>
<section xml:id="randomNumberGenerator">
<title>Random Number Generator</title>
<simpara>Many heuristics and metaheuristics depend on a pseudorandom number generator for move selection, to resolve score ties, probability based move acceptance, …​ During solving, the same <literal>Random</literal> instance is reused to improve reproducibility, performance and uniform distribution of random values.</simpara>
<simpara>To change the random seed of that <literal>Random</literal> instance, specify a <literal>randomSeed</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;randomSeed&gt;0&lt;/randomSeed&gt;
  ...
&lt;/solver&gt;</programlisting>
<simpara>To change the pseudorandom number generator implementation, specify a <literal>randomType</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;randomType&gt;MERSENNE_TWISTER&lt;/randomType&gt;
  ...
&lt;/solver&gt;</programlisting>
<simpara>The following types are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>JDK</literal> (default): Standard implementation (<literal>java.util.Random</literal>).</simpara>
</listitem>
<listitem>
<simpara><literal>MERSENNE_TWISTER</literal>: Implementation by <link xlink:href="http://commons.apache.org/proper/commons-math/userguide/random.html">Commons Math</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>WELL512A</literal>, <literal>WELL1024A</literal>, <literal>WELL19937A</literal>, <literal>WELL19937C</literal>, <literal>WELL44497A</literal> and <literal>WELL44497B</literal>: Implementation by <link xlink:href="http://commons.apache.org/proper/commons-math/userguide/random.html">Commons Math</link>.</simpara>
</listitem>
</itemizedlist>
<simpara>For most use cases, the randomType has no significant impact on the average quality of the best solution on multiple datasets.
If you want to confirm this on your use case, use the <link linkend="benchmarker">benchmarker</link>.</simpara>
</section>
</section>
</chapter>
<chapter xml:id="scoreCalculation">
<title>Score Calculation</title>
<section xml:id="scoreTerminology">
<title>Score Terminology</title>
<section xml:id="whatIsAScore">
<title>What is a Score?</title>
<simpara>Every <literal>Solution</literal> has a score.
The score is an objective way to compare two solutions.
The solution with the higher score is better.
The <literal>Solver</literal> aims to find the <literal>Solution</literal> with the highest <literal>Score</literal> of all possible solutions.
The <emphasis>best solution</emphasis> is the <literal>Solution</literal> with the highest <literal>Score</literal> that <literal>Solver</literal> has encountered during solving,
which might be the <emphasis>optimal solution</emphasis>.</simpara>
<simpara>Planner cannot automatically know which <literal>Solution</literal> is best for your business, so you need to tell it how to calculate the score of a given <literal>Solution</literal> according to your business needs.
If you forget or are unable to implement an important business constraint, the solution is probably useless:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/optimalWithIncompleteConstraints.png" align="center"/>
</imageobject>
<textobject><phrase>optimalWithIncompleteConstraints</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="formalizeTheBusinessConstraints">
<title>Formalize the Business Constraints</title>
<simpara>To implement a verbal business constraint, it needs to be formalized as a score constraint.
Luckily, defining constraints in Planner is very flexible through the following score techniques:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Score signum (positive or negative)</emphasis>: maximize or minimize a constraint type</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Score weight</emphasis>: put a cost/profit on a constraint type</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Score level (hard, soft, …​)</emphasis>: prioritize a group of constraint types</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Pareto scoring</emphasis> (rarely used)</simpara>
</listitem>
</itemizedlist>
<simpara>Take the time to acquaint yourself with the first three techniques.
Once you understand them, formalizing most business constraints becomes straightforward.</simpara>
</section>
<section xml:id="scoreConstraintSignum">
<title>Score Constraint Signum (Positive or Negative)</title>
<simpara>All score techniques are based on constraints.
A constraint can be a simple pattern (such as <emphasis>Maximize the apple harvest in the solution</emphasis>) or a more complex pattern.
A positive constraint is a constraint you want to maximize.
A negative constraint is a constraint you want to minimize.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/positiveAndNegativeConstraints.png" align="center"/>
</imageobject>
<textobject><phrase>positiveAndNegativeConstraints</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The image above illustrates that <emphasis role="strong">the optimal solution always has the highest score</emphasis>,
regardless if the constraints are positive or negative.</simpara>
<simpara>Most planning problems have only negative constraints and therefore have a negative score.
In that case, the score is the sum of the weight of the negative constraints being broken, with a perfect score of 0.
This explains why the score of a solution of four queens is the negative of the number of queen pairs which can attack each other.</simpara>
<simpara>Negative and positive constraints can be combined, even in the same score level.</simpara>
<note>
<simpara>Do not presume that your business knows all its score constraints in advance.
Expect score constraints to be added or changed after the first releases.</simpara>
</note>
<simpara>When a constraint activates (because the negative constraint is broken or the positive constraint is fulfilled) on a certain planning entity set, it is called a <emphasis>constraint match</emphasis>.</simpara>
</section>
<section xml:id="scoreConstraintWeight">
<title>Score Constraint Weight</title>
<simpara>Not all score constraints are equally important.
If breaking one constraint is equally bad as breaking another constraint x times, then those two constraints have a different weight (but they are in the same score level). For example in vehicle routing, you can make one "unhappy driver" constraint match count as much as two "fuel tank usage" constraint matches:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreWeighting.png" align="center"/>
</imageobject>
<textobject><phrase>scoreWeighting</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Score weighting is easy in use cases where you can <emphasis>put a price tag on everything</emphasis>.
In that case, the positive constraints maximize revenue and the negative constraints minimize expenses, so together they maximize profit.
Alternatively, score weighting is also often used to create social <link linkend="fairnessScoreConstraints">fairness</link>.
For example, a nurse, who requests a free day, pays a higher weight on New Years eve than on a normal day.</simpara>
<simpara>The weight of a constraint match can be dynamically based on the planning entities involved.
For example in cloud balance, the weight of the soft constraint match for an active <literal>Computer</literal> is the <literal>cost</literal> of that <literal>Computer</literal> (which differs per computer).</simpara>
<simpara>Putting a good weight on a constraint can be a difficult analytical decision, because it is about making choices and tradeoffs with other constraints.
Don’t spend too much time on it at the start of an implementation.
A non-accurate weight is less damaging than mediocre algorithms:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreTradeoffInPerspective.png" align="center"/>
</imageobject>
<textobject><phrase>scoreTradeoffInPerspective</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>When deciding the weights of some constraints is debatable, it’s recommended to make them configurable at runtime, as demonstrated in the exam timetabling example with the <literal>InstitutionParametrization</literal> class.
This allow the end-user to recalibrate constraint weights in the user interface and immediately discover the impact of the new weights by running the solver again.</simpara>
</note>
<simpara>Most use cases use a <literal>Score</literal> with <literal>int</literal> weights, such as <link linkend="hardSoftScore">HardSoftScore</link>.</simpara>
</section>
<section xml:id="scoreLevel">
<title>Score Constraint Level (hard, soft, …​)</title>
<simpara>Sometimes a score constraint outranks another score constraint, no matter how many times the other is broken.
In that case, those score constraints are in different levels.
For example, a nurse cannot do two shifts at the same time (due to the constraints of physical reality), this outranks all nurse happiness constraints.</simpara>
<simpara>Most use cases have only two score levels, hard and soft.
The levels of two scores are compared lexicographically.
The first score level gets compared first.
If those differ, the remaining score levels are ignored.
For example, a score that breaks <literal>0</literal> hard constraints and <literal>1000000</literal> soft constraints is better than a score that breaks <literal>1</literal> hard constraint and <literal>0</literal> soft constraints.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreLevels.png" align="center"/>
</imageobject>
<textobject><phrase>scoreLevels</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If there are two (or more) score levels, for example a hard and soft level, then a score is <emphasis>feasible</emphasis> if no hard constraints are broken.</simpara>
<note>
<simpara>By default, Planner will always assign all planning variables a planning value.
If there is no feasible solution, this means the best solution will be infeasible.
To instead leave some of the planning entities unassigned, apply <link linkend="overconstrainedPlanning">overconstrained planning</link>.</simpara>
</note>
<simpara>For each constraint, you need to pick a score level, a score weight and a score signum.
For example: <literal>-1soft</literal> which has score level of <literal>soft</literal>, a weight of <literal>1</literal> and a negative signum.
Do not use a big constraint weight when your business actually wants different score levels.
That hack, known as <emphasis>score folding</emphasis>, is broken:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreFoldingIsBroken.png" align="center"/>
</imageobject>
<textobject><phrase>scoreFoldingIsBroken</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Your business might tell you that your hard constraints all have the same weight, because they cannot be broken (so the weight does not matter). This is not true because if no feasible solution exists for a specific dataset, the least infeasible solution allows the business to estimate how many business resources they are lacking.
For example in cloud balancing, how many new computers to buy.</simpara>
<simpara>Furthermore, it will likely create a <link linkend="scoreTrap">score trap</link>.
For example in cloud balance if a <literal>Computer</literal> has seven CPU too little for its <literal>Process</literal>es, then it must be weighted seven times as much as if it had only one CPU too little.</simpara>
</note>
<simpara>Three or more score levels are supported.
For example: a company might decide that profit outranks employee satisfaction (or vice versa), while both are outranked by the constraints of physical reality.</simpara>
<note>
<simpara>To model fairness or load balancing, there is <link linkend="fairnessScoreConstraints">no need to use lots of score levels</link>
(even though Planner can handle many score levels).</simpara>
</note>
<simpara>Most use cases use a <literal>Score</literal> with two weights, such as <link linkend="hardSoftScore">HardSoftScore</link>.</simpara>
</section>
<section xml:id="paretoScoring">
<title>Pareto Scoring (AKA Multi-objective Optimization Scoring)</title>
<simpara>Far less common is the use case of pareto optimization, which is also known under the more confusing term multi-objective optimization.
In pareto scoring, score constraints are in the same score level, yet they are not weighted against each other.
When two scores are compared, each of the score constraints are compared individually and the score with the most dominating score constraints wins.
Pareto scoring can even be combined with score levels and score constraint weighting.</simpara>
<simpara>Consider this example with positive constraints, where we want to get the most apples and oranges.
Since it is impossible to compare apples and oranges, we can not weight them against each other.
Yet, despite that we can not compare them, we can state that two apples are better then one apple.
Similarly, we can state that two apples and one orange are better than just one orange.
So despite our inability to compare some Scores conclusively (at which point we declare them equal), we can find a set of optimal scores.
Those are called pareto optimal.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/paretoOptimizationScoring.png" align="center"/>
</imageobject>
<textobject><phrase>paretoOptimizationScoring</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Scores are considered equal far more often.
It is left up to a human to choose the better out of a set of best solutions (with equal scores) found by Planner.
In the example above, the user must choose between solution A (three apples and one orange) and solution B (one apple and six oranges). It is guaranteed that Planner has not found another solution which has more apples or more oranges or even a better combination of both (such as two apples and three oranges).</simpara>
<simpara>To implement pareto scoring in Planner, <link linkend="customScore">implement a custom <literal>ScoreDefinition</literal> and <literal>Score</literal></link> (and replace the <literal>BestSolutionRecaller</literal>). Future versions will provide out-of-the-box support.</simpara>
<note>
<simpara>A pareto <literal>Score</literal>'s <literal>compareTo</literal> method is not transitive because it does a pareto comparison.
For example: having two apples is greater than one apple.
One apple is equal to One orange.
Yet, two apples are not greater than one orange (but actually equal). Pareto comparison violates the contract of the interface <literal>java.lang.Comparable</literal>'s <literal>compareTo</literal> method, but Planners systems are <emphasis>pareto comparison safe</emphasis>, unless explicitly stated otherwise in this documentation.</simpara>
</note>
</section>
<section xml:id="combiningScoreTechniques">
<title>Combining Score Techniques</title>
<simpara>All the score techniques mentioned above, can be combined seamlessly:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreComposition.png" align="center"/>
</imageobject>
<textobject><phrase>scoreComposition</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="scoreInterface">
<title><literal>Score</literal> interface</title>
<simpara>A score is represented by the <literal>Score</literal> interface, which naturally extends <literal>Comparable</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Score&lt;...&gt; extends Comparable&lt;...&gt; {
    ...
}</programlisting>
<simpara>The <literal>Score</literal> implementation to use depends on your use case.
Your score might not efficiently fit in a single <literal>long</literal> value.
Planner has several built-in <literal>Score</literal> implementations, but you can implement a custom <literal>Score</literal> too.
Most use cases tend to use the built-in <literal>HardSoftScore</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreClassDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>scoreClassDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>All Score implementations also have an <literal>initScore</literal> (which is an <literal>int</literal>). It is mostly intended for internal use in Planner: it is the negative number of uninitialized planning variables.
From a user’s perspective this is <literal>0</literal>, unless a Construction Heuristic is terminated before it could initialize all planning variables (in which case <literal>Score.isSolutionInitialized()</literal> returns <literal>false</literal>).</simpara>
<simpara>The <literal>Score</literal> implementation (for example <literal>HardSoftScore</literal>) must be the same throughout a <literal>Solver</literal> runtime.
The <literal>Score</literal> implementation is configured in the solution domain class:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class CloudBalance {
    ...

    @PlanningScore
    private HardSoftScore score;

}</programlisting>
</section>
<section xml:id="avoidFloatingPointNumbersInScoreCalculation">
<title>Avoid Floating Point Numbers in Score Calculation</title>
<simpara>Avoid the use of <literal>float</literal> or <literal>double</literal> in score calculation.
Use <literal>BigDecimal</literal> or scaled <literal>long</literal> instead.</simpara>
<simpara>Floating point numbers (<literal>float</literal> and <literal>double</literal>) cannot represent a decimal number correctly.
For example: a <literal>double</literal> cannot hold the value <literal>0.05</literal> correctly.
Instead, it holds the nearest representable value.
Arithmetic (including addition and subtraction) with floating point numbers, especially for planning problems, leads to incorrect decisions:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreWeightType.png" align="center"/>
</imageobject>
<textobject><phrase>scoreWeightType</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Additionally, floating point number addition is not associative:</simpara>
<programlisting language="java" linenumbering="unnumbered">System.out.println( ((0.01 + 0.02) + 0.03) == (0.01 + (0.02 + 0.03)) ); // returns false</programlisting>
<simpara>This leads to <emphasis>score corruption</emphasis>.</simpara>
<simpara>Decimal numbers (<literal>BigDecimal</literal>) have none of these problems.</simpara>
<note>
<simpara>BigDecimal arithmetic is considerably slower than <literal>int</literal>, <literal>long</literal> or <literal>double</literal> arithmetic.
In experiments we have seen the score calculation take five times longer.</simpara>
<simpara>Therefore, in many cases, it can be worthwhile to multiply <emphasis>all</emphasis> numbers for a single score weight by a plural of ten, so the score weight fits in a scaled <literal>int</literal> or <literal>long</literal>.
For example, if we multiple all weights by <literal>1000</literal>, a fuelCost of <literal>0.07</literal> becomes a fuelCostMillis of <literal>70</literal> and no longer uses a decimal score weight.</simpara>
</note>
</section>
</section>
<section xml:id="scoreType">
<title>Choose a Score Type</title>
<simpara>Depending on the number of score levels and type of score weights you need, choose a <literal>Score</literal> type.
Most use cases use a <literal>HardSoftScore</literal>.</simpara>
<note>
<simpara>To properly write a <literal>Score</literal> to a database (with JPA/Hibernate) or to XML/JSON (with XStream/JAXB/Jackson), see <link linkend="integration">the integration chapter</link>.</simpara>
</note>
<section xml:id="simpleScore">
<title>SimpleScore</title>
<simpara>A <literal>SimpleScore</literal> has a single <literal>int</literal> value, for example <literal>-123</literal>.
It has a single score level.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningScore
    private SimpleScore score;</programlisting>
<simpara>Variants of this <literal>Score</literal> type:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>SimpleLongScore</literal> uses a <literal>long</literal> value instead of an <literal>int</literal> value.</simpara>
</listitem>
<listitem>
<simpara><literal>SimpleDoubleScore</literal> uses a <literal>double</literal> value instead of an <literal>int</literal> value. <link linkend="avoidFloatingPointNumbersInScoreCalculation">Not recommended to use.</link></simpara>
</listitem>
<listitem>
<simpara><literal>SimpleBigDecimalScore</literal> uses a <literal>BigDecimal</literal> value instead of an <literal>int</literal> value.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="hardSoftScore">
<title>HardSoftScore (Recommended)</title>
<simpara>A <literal>HardSoftScore</literal> has a hard <literal>int</literal> value and a soft <literal>int</literal> value, for example <literal>-123hard/-456soft</literal>.
It has two score levels (hard and soft).</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningScore
    private HardSoftScore score;</programlisting>
<simpara>Variants of this <literal>Score</literal> type:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HardSoftLongScore</literal> uses <literal>long</literal> values instead of <literal>int</literal> values.</simpara>
</listitem>
<listitem>
<simpara><literal>HardSoftDoubleScore</literal> uses <literal>double</literal> values instead of <literal>int</literal> values. <link linkend="avoidFloatingPointNumbersInScoreCalculation">Not recommended to use.</link></simpara>
</listitem>
<listitem>
<simpara><literal>HardSoftBigDecimalScore</literal> uses <literal>BigDecimal</literal> values instead of <literal>int</literal> values.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="hardMediumSoftScore">
<title>HardMediumSoftScore</title>
<simpara>A <literal>HardMediumSoftScore</literal> which has a hard <literal>int</literal> value, a medium <literal>int</literal> value and a soft <literal>int</literal> value, for example <literal>-123hard/-456medium/-789soft</literal>.
It has three score levels (hard, medium and soft).
The hard level determines if the solution is feasible,
and the medium level and soft level score values determine
how well the solution meets business goals.
Higher medium values take precedence over soft values irrespective of the soft value.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningScore
    private HardMediumSoftScore score;</programlisting>
<simpara>Variants of this <literal>Score</literal> type:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HardMediumSoftLongScore</literal> uses <literal>long</literal> values instead of <literal>int</literal> values.</simpara>
</listitem>
<listitem>
<simpara><literal>HardMediumSoftBigDecimalScore</literal> uses <literal>BigDecimal</literal> values instead of <literal>int</literal> values.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="bendableScore">
<title>BendableScore</title>
<simpara>A <literal>BendableScore</literal> has a configurable number of score levels.
It has an array of hard <literal>int</literal> values and an array of soft <literal>int</literal> values,
for example with two hard levels and three soft levels, the score can be <literal>[-123/-456]hard/[-789/-012/-345]soft</literal>.
In that case, it has five score levels.
A solution is feasible if all hard levels are at least zero.</simpara>
<simpara>A BendableScore with one hard level and one soft level is equivalent to a HardSoftScore,
while a BendableScore with one hard level and two soft levels is equivalent to a HardMediumSoftScore.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningScore(bendableHardLevelsSize = 2, bendableSoftLevelsSize = 3)
    private BendableScore score;</programlisting>
<simpara>The number of hard and soft score levels need to be set at compilation time.
It is not flexible to change during solving.</simpara>
<note>
<simpara>Do not use a <literal>BendableScore</literal> with seven levels just because you have seven constraints.
It is extremely rare to use a different score level for each constraint, because that means one constraint match on soft 0 outweighs even a million constraint matches of soft 1.</simpara>
<simpara>Usually, multiple constraints share the same level and are weighted against each other.
Use <link linkend="explainingTheScore">explaining the score</link> to get the weight of individual constraints in the same level.</simpara>
</note>
<simpara>Variants of this <literal>Score</literal> type:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>BendableLongScore</literal> uses <literal>long</literal> values instead of <literal>int</literal> values.</simpara>
</listitem>
<listitem>
<simpara><literal>BendableBigDecimalScore</literal> uses <literal>BigDecimal</literal> values instead of <literal>int</literal> values.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="customScore">
<title>Implementing a Custom Score</title>
<simpara>Internally, each <literal>Score</literal> implementation also has a <literal>ScoreDefinition</literal> implementation.
For example: <literal>SimpleScore</literal> is defined by <literal>SimpleScoreDefinition</literal>.
The <literal>ScoreDefinition</literal> interface defines the score representation.</simpara>
<simpara>To implement a custom <literal>Score</literal>, also implement such a custom <literal>ScoreDefinition</literal>.
Extend <literal>AbstractScoreDefinition</literal> (preferably by copy pasting <literal>HardSoftScoreDefinition</literal>) and start from there.
Then hook your custom <literal>ScoreDefinition</literal> in the domain:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @PlanningScore(scoreDefinitionClass = MyCustomScoreDefinition.class)
    private MyCustomScore score;</programlisting>
<simpara>To have it integrate seamlessly with <link linkend="jpaAndHibernatePersistingAScore">JPA/Hibernate</link>, <link linkend="integrationWithXStream">XStream</link>, …​, you’ll need to write some glue code.</simpara>
</section>
</section>
<section xml:id="calculateTheScore">
<title>Calculate the <literal>Score</literal></title>
<section xml:id="scoreCalculationTypes">
<title>Score Calculation Types</title>
<simpara>There are several ways to calculate the <literal>Score</literal> of a <literal>Solution</literal>:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Easy Java score calculation</emphasis>: implement a single Java method</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Incremental Java score calculation</emphasis>: implement multiple Java methods</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Drools score calculation</emphasis> (recommended): implement score rules</simpara>
</listitem>
</itemizedlist>
<simpara>Every score calculation type can use any Score definition.
For example, easy Java score calculation can output a <literal>HardSoftScore</literal>.</simpara>
<simpara>All score calculation types are Object Oriented and can reuse existing Java code.</simpara>
<important>
<simpara>The score calculation must be read-only.
It must not change the planning entities or the problem facts in any way.
For example, it must not call a setter method on a planning entity in a Drools score rule’s RHS.
This does not apply to <emphasis>logically inserted</emphasis> objects, which can be changed by the score rules that logically inserted them in the first place.</simpara>
<simpara>Planner will not recalculate the score of a <literal>Solution</literal> if it can predict it (unless an <link linkend="environmentMode">environmentMode assertion</link> is enabled). For example, after a winning step is done, there is no need to calculate the score because that move was done and undone earlier.
As a result, there is no guarantee that such changes applied during score calculation are actually done.</simpara>
</important>
</section>
<section xml:id="easyJavaScoreCalculation">
<title>Easy Java Score Calculation</title>
<simpara>An easy way to implement your score calculation in Java.</simpara>
<itemizedlist>
<listitem>
<simpara>Advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>Plain old Java: no learning curve</simpara>
</listitem>
<listitem>
<simpara>Opportunity to delegate score calculation to an existing code base or legacy system</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Disadvantages:</simpara>
<itemizedlist>
<listitem>
<simpara>Slower and less scalable</simpara>
<itemizedlist>
<listitem>
<simpara>Because there is no <link linkend="incrementalScoreCalculation">incremental score calculation</link></simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Just implement one method of the interface <literal>EasyScoreCalculator</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface EasyScoreCalculator&lt;Solution_&gt; {

    Score calculateScore(Solution_ solution);

}</programlisting>
<simpara>For example in n queens:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class NQueensEasyScoreCalculator implements EasyScoreCalculator&lt;NQueens&gt; {

    public SimpleScore calculateScore(NQueens nQueens) {
        int n = nQueens.getN();
        List&lt;Queen&gt; queenList = nQueens.getQueenList();

        int score = 0;
        for (int i = 0; i &lt; n; i++) {
            for (int j = i + 1; j &lt; n; j++) {
                Queen leftQueen = queenList.get(i);
                Queen rightQueen = queenList.get(j);
                if (leftQueen.getRow() != null &amp;&amp; rightQueen.getRow() != null) {
                    if (leftQueen.getRowIndex() == rightQueen.getRowIndex()) {
                        score--;
                    }
                    if (leftQueen.getAscendingDiagonalIndex() == rightQueen.getAscendingDiagonalIndex()) {
                        score--;
                    }
                    if (leftQueen.getDescendingDiagonalIndex() == rightQueen.getDescendingDiagonalIndex()) {
                        score--;
                    }
                }
            }
        }
        return SimpleScore.valueOf(score);
    }

}</programlisting>
<simpara>Configure it in your solver configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;easyScoreCalculatorClass&gt;org.optaplanner.examples.nqueens.solver.score.NQueensEasyScoreCalculator&lt;/easyScoreCalculatorClass&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>Alternatively, build a <literal>EasyScoreCalculator</literal> instance at runtime and set it with the programmatic API:</simpara>
<programlisting language="java" linenumbering="unnumbered">    solverFactory.getSolverConfig().getScoreDirectorFactoryConfig.setEasyScoreCalculator(easyScoreCalculator);</programlisting>
</section>
<section xml:id="incrementalJavaScoreCalculation">
<title>Incremental Java Score Calculation</title>
<simpara>A way to implement your score calculation incrementally in Java.</simpara>
<itemizedlist>
<listitem>
<simpara>Advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>Very fast and scalable</simpara>
<itemizedlist>
<listitem>
<simpara>Currently the fastest if implemented correctly</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Disadvantages:</simpara>
<itemizedlist>
<listitem>
<simpara>Hard to write</simpara>
<itemizedlist>
<listitem>
<simpara>A scalable implementation heavily uses maps, indexes, …​ (things the Drools rule engine can do for you)</simpara>
</listitem>
<listitem>
<simpara>You have to learn, design, write and improve all these performance optimizations yourself</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Hard to read</simpara>
<itemizedlist>
<listitem>
<simpara>Regular score constraint changes can lead to a high maintenance cost</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Implement all the methods of the interface <literal>IncrementalScoreCalculator</literal> and extend the class <literal>AbstractIncrementalScoreCalculator</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface IncrementalScoreCalculator&lt;Solution_&gt; {

    void resetWorkingSolution(Solution_ workingSolution);

    void beforeEntityAdded(Object entity);

    void afterEntityAdded(Object entity);

    void beforeVariableChanged(Object entity, String variableName);

    void afterVariableChanged(Object entity, String variableName);

    void beforeEntityRemoved(Object entity);

    void afterEntityRemoved(Object entity);

    Score calculateScore();

}</programlisting>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/incrementalScoreCalculatorSequenceDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>incrementalScoreCalculatorSequenceDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For example in n queens:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class NQueensAdvancedIncrementalScoreCalculator extends AbstractIncrementalScoreCalculator&lt;NQueens&gt; {

    private Map&lt;Integer, List&lt;Queen&gt;&gt; rowIndexMap;
    private Map&lt;Integer, List&lt;Queen&gt;&gt; ascendingDiagonalIndexMap;
    private Map&lt;Integer, List&lt;Queen&gt;&gt; descendingDiagonalIndexMap;

    private int score;

    public void resetWorkingSolution(NQueens nQueens) {
        int n = nQueens.getN();
        rowIndexMap = new HashMap&lt;Integer, List&lt;Queen&gt;&gt;(n);
        ascendingDiagonalIndexMap = new HashMap&lt;Integer, List&lt;Queen&gt;&gt;(n * 2);
        descendingDiagonalIndexMap = new HashMap&lt;Integer, List&lt;Queen&gt;&gt;(n * 2);
        for (int i = 0; i &lt; n; i++) {
            rowIndexMap.put(i, new ArrayList&lt;Queen&gt;(n));
            ascendingDiagonalIndexMap.put(i, new ArrayList&lt;Queen&gt;(n));
            descendingDiagonalIndexMap.put(i, new ArrayList&lt;Queen&gt;(n));
            if (i != 0) {
                ascendingDiagonalIndexMap.put(n - 1 + i, new ArrayList&lt;Queen&gt;(n));
                descendingDiagonalIndexMap.put((-i), new ArrayList&lt;Queen&gt;(n));
            }
        }
        score = 0;
        for (Queen queen : nQueens.getQueenList()) {
            insert(queen);
        }
    }

    public void beforeEntityAdded(Object entity) {
        // Do nothing
    }

    public void afterEntityAdded(Object entity) {
        insert((Queen) entity);
    }

    public void beforeVariableChanged(Object entity, String variableName) {
        retract((Queen) entity);
    }

    public void afterVariableChanged(Object entity, String variableName) {
        insert((Queen) entity);
    }

    public void beforeEntityRemoved(Object entity) {
        retract((Queen) entity);
    }

    public void afterEntityRemoved(Object entity) {
        // Do nothing
    }

    private void insert(Queen queen) {
        Row row = queen.getRow();
        if (row != null) {
            int rowIndex = queen.getRowIndex();
            List&lt;Queen&gt; rowIndexList = rowIndexMap.get(rowIndex);
            score -= rowIndexList.size();
            rowIndexList.add(queen);
            List&lt;Queen&gt; ascendingDiagonalIndexList = ascendingDiagonalIndexMap.get(queen.getAscendingDiagonalIndex());
            score -= ascendingDiagonalIndexList.size();
            ascendingDiagonalIndexList.add(queen);
            List&lt;Queen&gt; descendingDiagonalIndexList = descendingDiagonalIndexMap.get(queen.getDescendingDiagonalIndex());
            score -= descendingDiagonalIndexList.size();
            descendingDiagonalIndexList.add(queen);
        }
    }

    private void retract(Queen queen) {
        Row row = queen.getRow();
        if (row != null) {
            List&lt;Queen&gt; rowIndexList = rowIndexMap.get(queen.getRowIndex());
            rowIndexList.remove(queen);
            score += rowIndexList.size();
            List&lt;Queen&gt; ascendingDiagonalIndexList = ascendingDiagonalIndexMap.get(queen.getAscendingDiagonalIndex());
            ascendingDiagonalIndexList.remove(queen);
            score += ascendingDiagonalIndexList.size();
            List&lt;Queen&gt; descendingDiagonalIndexList = descendingDiagonalIndexMap.get(queen.getDescendingDiagonalIndex());
            descendingDiagonalIndexList.remove(queen);
            score += descendingDiagonalIndexList.size();
        }
    }

    public SimpleScore calculateScore() {
        return SimpleScore.valueOf(score);
    }

}</programlisting>
<simpara>Configure it in your solver configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;incrementalScoreCalculatorClass&gt;org.optaplanner.examples.nqueens.solver.score.NQueensAdvancedIncrementalScoreCalculator&lt;/incrementalScoreCalculatorClass&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<note>
<simpara>A piece of incremental score calculator code can be difficult to write and to review.
Assert its correctness by using <link linkend="invalidScoreDetection">an <literal>EasyScoreCalculator</literal> to do the assertions triggered by the <literal>environmentMode</literal></link>.</simpara>
</note>
<section xml:id="constraintMatchAwareIncrementalScoreCalculator">
<title><literal>ConstraintMatchAwareIncrementalScoreCalculator</literal></title>
<simpara>Optionally, also implement the <literal>ConstraintMatchAwareIncrementalScoreCalculator</literal> interface to:</simpara>
<itemizedlist>
<listitem>
<simpara>Explain a score by splitting it up per score constraint with <literal>ScoreDirector.getConstraintMatchTotals()</literal>.</simpara>
</listitem>
<listitem>
<simpara>Visualize or sort planning entities by how many constraints each one breaks with <literal>ScoreDirector.getIndictmentMap()</literal>.</simpara>
</listitem>
<listitem>
<simpara>Receive a detailed analysis if the <literal>IncrementalScoreCalculator</literal> is corrupted in <literal>FAST_ASSERT</literal> or <literal>FULL_ASSERT</literal> <literal>environmentMode</literal>,</simpara>
</listitem>
</itemizedlist>
<programlisting language="java" linenumbering="unnumbered">public interface ConstraintMatchAwareIncrementalScoreCalculator&lt;Solution_&gt; {

    void resetWorkingSolution(Solution_ workingSolution, boolean constraintMatchEnabled);

    Collection&lt;ConstraintMatchTotal&gt; getConstraintMatchTotals();

    Map&lt;Object, Indictment&gt; getIndictmentMap();
}</programlisting>
<simpara>For example in machine reassignment, create one ConstraintMatchTotal per constraint type
and call <literal>addConstraintMatch()</literal> for each constraint match:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MachineReassignmentIncrementalScoreCalculator
        implements ConstraintMatchAwareIncrementalScoreCalculator&lt;MachineReassignment&gt; {
    ...

    @Override
    public void resetWorkingSolution(MachineReassignment workingSolution, boolean constraintMatchEnabled) {
        resetWorkingSolution(workingSolution);
        // ignore constraintMatchEnabled, it is always presumed enabled
    }

    @Override
    public Collection&lt;ConstraintMatchTotal&gt; getConstraintMatchTotals() {
        ConstraintMatchTotal maximumCapacityMatchTotal = new ConstraintMatchTotal(
                CONSTRAINT_PACKAGE, "maximumCapacity", HardSoftLongScore.ZERO);
        ...
        for (MrMachineScorePart machineScorePart : machineScorePartMap.values()) {
            for (MrMachineCapacityScorePart machineCapacityScorePart : machineScorePart.machineCapacityScorePartList) {
                if (machineCapacityScorePart.maximumAvailable &lt; 0L) {
                    maximumCapacityMatchTotal.addConstraintMatch(
                            Arrays.asList(machineCapacityScorePart.machineCapacity),
                            HardSoftLongScore.valueOf(machineCapacityScorePart.maximumAvailable, 0));
                }
            }
        }
        ...
        List&lt;ConstraintMatchTotal&gt; constraintMatchTotalList = new ArrayList&lt;&gt;(4);
        constraintMatchTotalList.add(maximumCapacityMatchTotal);
        ...
        return constraintMatchTotalList;
    }

    @Override
    public Map&lt;Object, Indictment&gt; getIndictmentMap() {
        return null; // Calculate it non-incrementally from getConstraintMatchTotals()
    }
}</programlisting>
<simpara>That <literal>getConstraintMatchTotals()</literal> code often duplicates some of the logic of the normal <literal>IncrementalScoreCalculator</literal> methods.
Drools Score Calculation doesn’t have this disadvantage, because it is constraint match aware automatically when needed,
without any extra domain-specific code.</simpara>
</section>
</section>
<section xml:id="droolsScoreCalculation">
<title>Drools Score Calculation</title>
<section xml:id="droolsScoreCalculationOverview">
<title>Overview</title>
<simpara>Implement your score calculation using the Drools rule engine.
Every score constraint is written as one or more score rules.</simpara>
<itemizedlist>
<listitem>
<simpara>Advantages:</simpara>
<itemizedlist>
<listitem>
<simpara>Incremental score calculation for free</simpara>
<itemizedlist>
<listitem>
<simpara>Because most DRL syntax uses forward chaining, it does incremental calculation without any extra code</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Score constraints are isolated as separate rules</simpara>
<itemizedlist>
<listitem>
<simpara>Easy to add or edit existing score rules</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Flexibility to augment your score constraints by</simpara>
<itemizedlist>
<listitem>
<simpara>Defining them in decision tables</simpara>
<itemizedlist>
<listitem>
<simpara>Excel (XLS) spreadsheet</simpara>
</listitem>
<listitem>
<simpara>KIE Workbench WebUI</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Translate them into natural language with DSL</simpara>
</listitem>
<listitem>
<simpara>Store and release in the KIE Workbench repository</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Performance optimizations in future versions for free</simpara>
<itemizedlist>
<listitem>
<simpara>In every release, the Drools rule engine tends to become faster</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Disadvantages:</simpara>
<itemizedlist>
<listitem>
<simpara>DRL learning curve</simpara>
</listitem>
<listitem>
<simpara>Usage of DRL</simpara>
<itemizedlist>
<listitem>
<simpara>Polyglot fear can prohibit the use of a new language such as DRL in some organizations</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="droolsScoreRulesConfiguration">
<title>Drools Score Rules Configuration</title>
<simpara>There are several ways to define where your score rules live.</simpara>
<section xml:id="droolsScoreCalculationScoreDrl">
<title>A scoreDrl Resource on the Classpath</title>
<simpara>This is the easy way.
The score rules live in a DRL file which is provided as a classpath resource.
Just add the score rules DRL file in the solver configuration as a <literal>&lt;scoreDrl&gt;</literal> element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>In a typical project (following the Maven directory structure), that DRL file would be located at <literal>$PROJECT_DIR/src/main/resources/org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl</literal> (even for a war project).</simpara>
<note>
<simpara>The <literal>&lt;scoreDrl&gt;</literal> element expects a classpath resource, as defined by <literal>ClassLoader.getResource(String)</literal>, it does not accept a <literal>File</literal>, nor an URL, nor a webapp resource.
See below to use a <literal>File</literal> instead.</simpara>
</note>
<simpara>Add multiple <literal>&lt;scoreDrl&gt;</literal> elements if the score rules are split across multiple DRL files.</simpara>
<simpara>Optionally, you can also set drools configuration properties:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
    &lt;kieBaseConfigurationProperties&gt;
      &lt;drools.equalityBehavior&gt;...&lt;/drools.equalityBehavior&gt;
    &lt;/kieBaseConfigurationProperties&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>To enable property reactive by default, without a <literal>@propertyReactive</literal> on the domain classes,
add <literal>&lt;drools.propertySpecific&gt;ALWAYS&lt;/drools.propertySpecific&gt;</literal> in there.
Otherwise Planner automatically changes the Drools default to <literal>ALLOWED</literal> so property reactive is not active by default.</simpara>
</section>
<section xml:id="droolsScoreCalculationScoreDrlFile">
<title>A scoreDrlFile</title>
<simpara>To use <literal>File</literal> on the local file system, instead of a classpath resource, add the score rules DRL file in the solver configuration as a <literal>&lt;scoreDrlFile&gt;</literal> element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrlFile&gt;/home/ge0ffrey/tmp/nQueensScoreRules.drl&lt;/scoreDrlFile&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<warning>
<simpara>For portability reasons, a classpath resource is recommended over a File.
An application build on one computer, but used on another computer, might not find the file on the same location.
Worse, if they use a different Operating System, it is hard to choose a portable file path.</simpara>
</warning>
<simpara>Add multiple <literal>&lt;scoreDrlFile&gt;</literal> elements if the score rules are split across multiple DRL files.</simpara>
</section>
<section xml:id="droolsScoreCalculationKsessionName">
<title>A ksessionName in a Kjar from a Maven repository</title>
<simpara>This way allows you to use score rules defined by the Workbench or build a kjar and deploy it to the Execution Server.
Both the score rules and the solver configuration are resources in a kjar.
Clients can obtain that kjar either from the local classpath, from a local Maven repository or even from a remote Maven repository.</simpara>
<simpara>The score rules still live in a DRL file, but the <literal>KieContainer</literal> finds that DRL file through the <literal>META-INF/kmodule.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;kmodule xmlns="http://www.drools.org/xsd/kmodule"&gt;
  &lt;configuration&gt;
    &lt;!-- Don't enable propertyReactive unless there is a @PropertyReactive annotation on the domain classes --&gt;
    &lt;property key="drools.propertySpecific" value="ALLOWED"/&gt;
  &lt;/configuration&gt;
  &lt;kbase name="nQueensKbase" packages="org.optaplanner.examples.nqueens.solver"&gt;
    &lt;ksession name="nQueensKsession"/&gt;
  &lt;/kbase&gt;
&lt;/kmodule&gt;</programlisting>
<simpara>The kmodule above will pick up all the DRL files in the package <literal>org.optaplanner.examples.nqueens.solver</literal>.
A kbase can even extend another kbase.</simpara>
<note>
<simpara>Starting from version 7.0, Drools enables property reactive by default for all classes.
This means if you have a non-simple getter and forget to apply <literal>@Modifies</literal> correctly, corruption occurs.
To avoid this, simply set <literal>drools.propertySpecific</literal> to <literal>ALLOWED</literal> as shown above.</simpara>
</note>
<simpara>Add the ksession name in the solver configuration as a <literal>&lt;ksessionName&gt;</literal> element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;ksessionName&gt;nQueensKsession&lt;/ksessionName&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>In this approach, it’s required to use a <literal>SolverFactory.createFromKieContainerXmlResource(…​)</literal> method to <link linkend="solverConfigurationByXML">build the <literal>SolverFactory</literal></link>.
If no <literal>&lt;ksessionName&gt;</literal> element is specified, the default ksession of the <literal>kmodule.xml</literal> is used.</simpara>
</section>
</section>
<section xml:id="implementingAScoreRule">
<title>Implementing a Score Rule</title>
<simpara>Here is an example of a score constraint implemented as a score rule in a DRL file:</simpara>
<screen>rule "multipleQueensHorizontal"
    when
        Queen($id : id, row != null, $i : rowIndex)
        Queen(id &gt; $id, rowIndex == $i)
    then
        scoreHolder.addConstraintMatch(kcontext, -1);
end</screen>
<simpara>This score rule will fire once for every two queens with the same <literal>rowIndex</literal>.
The <literal>(id &gt; $id)</literal> condition is needed to assure that for two queens A and B, it can only fire for (A, B) and not for (B, A), (A, A) or (B, B). Let us take a closer look at this score rule on this solution of four queens:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/unsolvedNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>unsolvedNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In this solution the multipleQueensHorizontal score rule will fire for six queen couples: (A, B), (A, C), (A, D), (B, C), (B, D) and (C, D). Because none of the queens are on the same vertical or diagonal line, this solution will have a score of <literal>-6</literal>.
An optimal solution of four queens has a score of <literal>0</literal>.</simpara>
<note>
<simpara>Notice that every score rule will relate to at least one planning entity class (directly or indirectly through a logically inserted fact).</simpara>
<simpara>This is a normal case.
It would be a waste of time to write a score rule that only relates to problem facts, as the consequence will never change during planning, no matter what the possible solution.</simpara>
</note>
<note>
<simpara>The <literal>kcontext</literal> variable is a magic variable in Drools Expert.
The <literal>scoreHolder</literal>'s method uses it to do incremental score calculation correctly and to create a <literal>ConstraintMatch</literal> instance.</simpara>
</note>
</section>
<section xml:id="weighingScoreRules">
<title>Weighing Score Rules</title>
<simpara>A <literal>ScoreHolder</literal> instance is asserted into the <literal>KieSession</literal> as a global called <literal>scoreHolder</literal>.
The score rules need to (directly or indirectly) update that instance.</simpara>
<screen>global SimpleScoreHolder scoreHolder;

rule "multipleQueensHorizontal"
    when
        Queen($id : id, row != null, $i : rowIndex)
        Queen(id &gt; $id, rowIndex == $i)
    then
        scoreHolder.addConstraintMatch(kcontext, -1);
end

// multipleQueensVertical is obsolete because it is always 0

rule "multipleQueensAscendingDiagonal"
    when
        Queen($id : id, row != null, $i : ascendingDiagonalIndex)
        Queen(id &gt; $id, ascendingDiagonalIndex == $i)
    then
        scoreHolder.addConstraintMatch(kcontext, -1);
end

rule "multipleQueensDescendingDiagonal"
    when
        Queen($id : id, row != null, $i : descendingDiagonalIndex)
        Queen(id &gt; $id, descendingDiagonalIndex == $i)
    then
        scoreHolder.addConstraintMatch(kcontext, -1);
end</screen>
<note>
<simpara>To learn more about the Drools rule language (DRL), consult <link xlink:href="https://drools.org/learn/documentation.html">the Drools documentation</link>.</simpara>
</note>
<simpara>Most use cases also weigh their constraint types or even their matches differently, by using a specific weight for each constraint match.
For example in <link linkend="curriculumCourse">course scheduling</link>, assigning a <literal>Lecture</literal> to a <literal>Room</literal> that is lacking two seats is weighted equally bad as having one isolated <literal>Lecture</literal> in a <literal>Curriculum</literal>:</simpara>
<screen>global HardSoftScoreHolder scoreHolder;

// RoomCapacity: For each lecture, the number of students that attend the course must be less or equal
// than the number of seats of all the rooms that host its lectures.
rule "roomCapacity"
    when
        $room : Room($capacity : capacity)
        $lecture : Lecture(room == $room, studentSize &gt; $capacity, $studentSize : studentSize)
    then
        // Each student above the capacity counts as one point of penalty.
        scoreHolder.addSoftConstraintMatch(kcontext, ($capacity - $studentSize));
end

// CurriculumCompactness: Lectures belonging to a curriculum should be adjacent
// to each other (i.e., in consecutive periods).
// For a given curriculum we account for a violation every time there is one lecture not adjacent
// to any other lecture within the same day.
rule "curriculumCompactness"
    when
        ...
    then
        // Each isolated lecture in a curriculum counts as two points of penalty.
        scoreHolder.addSoftConstraintMatch(kcontext, -2);
end</screen>
</section>
</section>
<section xml:id="initializingScoreTrend">
<title>InitializingScoreTrend</title>
<simpara>The <literal>InitializingScoreTrend</literal> specifies how the Score will change as more and more variables are initialized (while the already initialized variables do not change). Some optimization algorithms (such Construction Heuristics and Exhaustive Search) run faster if they have such information.</simpara>
<simpara>For the Score (or each <link linkend="scoreLevel">score level</link> separately), specify a trend:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ANY</literal> (default): Initializing an extra variable can change the score positively or negatively. Gives no performance gain.</simpara>
</listitem>
<listitem>
<simpara><literal>ONLY_UP</literal> (rare): Initializing an extra variable can only change the score positively. Implies that:</simpara>
<itemizedlist>
<listitem>
<simpara>There are only positive constraints</simpara>
</listitem>
<listitem>
<simpara>And initializing the next variable can not unmatch a positive constraint that was matched by a previous initialized variable.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ONLY_DOWN</literal>: Initializing an extra variable can only change the score negatively. Implies that:</simpara>
<itemizedlist>
<listitem>
<simpara>There are only negative constraints</simpara>
</listitem>
<listitem>
<simpara>And initializing the next variable can not unmatch a negative constraint that was matched by a previous initialized variable.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Most use cases only have negative constraints.
Many of those have an <literal>InitializingScoreTrend</literal> that only goes down:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;.../cloudBalancingScoreRules.drl&lt;/scoreDrl&gt;
    &lt;initializingScoreTrend&gt;ONLY_DOWN&lt;/initializingScoreTrend&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>Alternatively, you can also specify the trend for each score level separately:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;.../cloudBalancingScoreRules.drl&lt;/scoreDrl&gt;
    &lt;initializingScoreTrend&gt;ONLY_DOWN/ONLY_DOWN&lt;/initializingScoreTrend&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
</section>
<section xml:id="invalidScoreDetection">
<title>Invalid Score Detection</title>
<simpara>When you put <link linkend="environmentMode">the <literal>environmentMode</literal></link>in <literal>FULL_ASSERT</literal> (or <literal>FAST_ASSERT</literal>),
it will detect score corruption in the <link linkend="incrementalScoreCalculation">incremental score calculation</link>.
However, that will not verify that your score calculator actually implements your score constraints as your business desires.
For example, one score rule might consistently match the wrong pattern.
To verify the score rules against an independent implementation, configure a <literal>assertionScoreDirectorFactory</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;environmentMode&gt;FAST_ASSERT&lt;/environmentMode&gt;
  ...
  &lt;scoreDirectorFactory&gt;
    &lt;scoreDrl&gt;org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
    &lt;assertionScoreDirectorFactory&gt;
      &lt;easyScoreCalculatorClass&gt;org.optaplanner.examples.nqueens.solver.score.NQueensEasyScoreCalculator&lt;/easyScoreCalculatorClass&gt;
    &lt;/assertionScoreDirectorFactory&gt;
  &lt;/scoreDirectorFactory&gt;</programlisting>
<simpara>This way, the <literal>scoreDrl</literal> will be validated by the <literal>EasyScoreCalculator</literal>.</simpara>
<note>
<simpara>This works well to isolate score corruption,
but to verify that the score rules implement the real business needs,
<link linkend="testingScoreConstraints">a unit test with a ScoreVerifier</link> is usually better.</simpara>
</note>
</section>
</section>
<section xml:id="scoreCalculationPerformanceTricks">
<title>Score Calculation Performance Tricks</title>
<section xml:id="scoreCalculationPerformanceTricksOverview">
<title>Overview</title>
<simpara>The <literal>Solver</literal> will normally spend most of its execution time running the score calculation (which is called in its deepest loops). Faster score calculation will return the same solution in less time with the same algorithm, which normally means a better solution in equal time.</simpara>
</section>
<section xml:id="scoreCalculationSpeed">
<title>Score Calculation Speed</title>
<simpara>After solving a problem, the <literal>Solver</literal> will log the <emphasis>score calculation speed per second</emphasis>.
This is a good measurement of Score calculation performance, despite that it is affected by non score calculation execution time.
It depends on the problem scale of the problem dataset.
Normally, even for high scale problems, it is higher than <literal>1000</literal>, except when you are using an <literal>EasyScoreCalculator</literal>.</simpara>
<important>
<simpara>When improving your score calculation, focus on maximizing the score calculation speed, instead of maximizing the best score.
A big improvement in score calculation can sometimes yield little or no best score improvement, for example when the algorithm is stuck in a local or global optima.
If you are watching the calculation speed instead, score calculation improvements are far more visible.</simpara>
<simpara>Furthermore, watching the calculation speed, allows you to remove or add score constraints, and still compare it with the original calculation speed.
Comparing the best score with the original would be wrong, because it is comparing apples and oranges.</simpara>
</important>
</section>
<section xml:id="incrementalScoreCalculation">
<title>Incremental Score Calculation (with Deltas)</title>
<simpara>When a <literal>Solution</literal> changes, incremental score calculation (AKA delta based score calculation),
calculates the delta with the previous state to find the new <literal>Score</literal>,
instead of recalculating the entire score on every solution evaluation.</simpara>
<simpara>For example, when a single queen A moves from row <literal>1</literal> to <literal>2</literal>,
it will not bother to check if queen B and C can attack each other, since neither of them changed:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/incrementalScoreCalculationNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>incrementalScoreCalculationNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Similarly in employee rostering:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/incrementalScoreCalculationEmployeeRostering.png" align="center"/>
</imageobject>
<textobject><phrase>incrementalScoreCalculationEmployeeRostering</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is a huge performance and scalability gain.
<emphasis role="strong">Drools score calculation gives you this huge scalability gain without forcing you to write a complicated incremental score calculation algorithm.</emphasis>
Just let the Drools rule engine do the hard work.</simpara>
<simpara>Notice that the speedup is relative to the size of your planning problem (your <emphasis>n</emphasis>), making incremental score calculation far more scalable.</simpara>
</section>
<section xml:id="avoidCallingRemoteServicesDuringScoreCalculation">
<title>Avoid Calling Remote Services During Score Calculation</title>
<simpara>Do not call remote services in your score calculation (except if you are bridging <literal>EasyScoreCalculator</literal> to a legacy system). The network latency will kill your score calculation performance.
Cache the results of those remote services if possible.</simpara>
<simpara>If some parts of a constraint can be calculated once, when the <literal>Solver</literal> starts, and never change during solving, then turn them into <link linkend="cachedProblemFact">cached problem facts</link>.</simpara>
</section>
<section xml:id="pointlessConstraints">
<title>Pointless Constraints</title>
<simpara>If you know a certain constraint can never be broken (or it is always broken), you need not write a score constraint for it.
For example in n queens, the score calculation does not check if multiple queens occupy the same column, because a <literal>Queen</literal>'s <literal>column</literal> never changes and every <literal>Solution</literal> starts with each <literal>Queen</literal> on a different <literal>column</literal>.</simpara>
<note>
<simpara>Do not go overboard with this.
If some datasets do not use a specific constraint but others do, just return out of the constraint as soon as you can.
There is no need to dynamically change your score calculation based on the dataset.</simpara>
</note>
</section>
<section xml:id="buildInHardConstraint">
<title>Built-in Hard Constraint</title>
<simpara>Instead of implementing a hard constraint, it can sometimes be built in.
For example, If <literal>Lecture</literal> A should never be assigned to <literal>Room</literal> X, but it uses <literal>ValueRangeProvider</literal> on Solution, so the <literal>Solver</literal> will often try to assign it to <literal>Room</literal> X too (only to find out that it breaks a hard constraint). Use <link linkend="valueRangeProviderOnPlanningEntity">a ValueRangeProvider on the planning entity</link> or <link linkend="filteredSelection">filtered selection</link> to define that Course A should only be assigned a <literal>Room</literal> different than X.</simpara>
<simpara>This can give a good performance gain in some use cases, not just because the score calculation is faster, but mainly because most optimization algorithms will spend less time evaluating infeasible solutions.
However, usually this not a good idea because there is a real risk of trading short term benefits for long term harm:</simpara>
<itemizedlist>
<listitem>
<simpara>Many optimization algorithms rely on the freedom to break hard constraints when changing planning entities, to get out of local optima.</simpara>
</listitem>
<listitem>
<simpara>Both implementation approaches have limitations (feature compatibility, disabling automatic performance optimizations), as explained in their documentation.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="otherScoreCalculationPerformanceTricks">
<title>Other Score Calculation Performance Tricks</title>
<itemizedlist>
<listitem>
<simpara>Verify that your score calculation happens in the correct <literal>Number</literal> type. If you are making the sum of <literal>int</literal> values, do not let Drools sum it in a <literal>double</literal> which takes longer.</simpara>
</listitem>
<listitem>
<simpara>For optimal performance, always use server mode (<literal>java -server</literal>). We have seen performance increases of 50% by turning on server mode.</simpara>
</listitem>
<listitem>
<simpara>For optimal performance, use the latest Java version. For example, in the past we have seen performance increases of 30% by switching from java 1.5 to 1.6.</simpara>
</listitem>
<listitem>
<simpara>Always remember that premature optimization is the root of all evil. Make sure your design is flexible enough to allow configuration based tweaking.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="scoreTrap">
<title>Score Trap</title>
<simpara>Make sure that none of your score constraints cause a score trap.
A trapped score constraint uses the same weight for different constraint matches, when it could just as easily use a different weight.
It effectively lumps its constraint matches together, which creates a flatlined score function for that constraint.
This can cause a solution state in which several moves need to be done to resolve or lower the weight of that single constraint.
Some examples of score traps:</simpara>
<itemizedlist>
<listitem>
<simpara>You need two doctors at each table, but you are only moving one doctor at a time. So the solver has no incentive to move a doctor to a table with no doctors. Punish a table with no doctors more then a table with only one doctor in that score constraint in the score function.</simpara>
</listitem>
<listitem>
<simpara>Two exams need to be conducted at the same time, but you are only moving one exam at a time. So the solver has to move one of those exams to another timeslot without moving the other in the same move. Add a coarse-grained move that moves both exams at the same time.</simpara>
</listitem>
</itemizedlist>
<simpara>For example, consider this score trap.
If the blue item moves from an overloaded computer to an empty computer, the hard score should improve.
The trapped score implementation fails to do that:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreTrap.png" align="center"/>
</imageobject>
<textobject><phrase>scoreTrap</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The Solver should eventually get out of this trap, but it will take a lot of effort (especially if there are even more processes on the overloaded computer). Before they do that, they might actually start moving more processes into that overloaded computer, as there is no penalty for doing so.</simpara>
<note>
<simpara>Avoiding score traps does not mean that your score function should be smart enough to avoid local optima.
Leave it to the optimization algorithms to deal with the local optima.</simpara>
<simpara>Avoiding score traps means to avoid, for each score constraint individually, a flatlined score function.</simpara>
</note>
<important>
<simpara>Always specify the degree of infeasibility.
The business will often say "if the solution is infeasible, it does not matter how infeasible it is." While that is true for the business, it is not true for score calculation as it benefits from knowing how infeasible it is.
In practice, soft constraints usually do this naturally and it is just a matter of doing it for the hard constraints too.</simpara>
</important>
<simpara>There are several ways to deal with a score trap:</simpara>
<itemizedlist>
<listitem>
<simpara>Improve the score constraint to make a distinction in the score weight. For example, penalize <literal>-1hard</literal> for every missing CPU, instead of just <literal>-1hard</literal> if any CPU is missing.</simpara>
</listitem>
<listitem>
<simpara>If changing the score constraint is not allowed from the business perspective, add a lower score level with a score constraint that makes such a distinction. For example, penalize <literal>-1subsoft</literal> for every missing CPU, on top of <literal>-1hard</literal> if any CPU is missing. The business ignores the subsoft score level.</simpara>
</listitem>
<listitem>
<simpara>Add coarse-grained moves and union select them with the existing fine-grained moves. A coarse-grained move effectively does multiple moves to directly get out of a score trap with a single move. For example, move multiple items from the same container to another container.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="stepLimitBenchmark">
<title>stepLimit Benchmark</title>
<simpara>Not all score constraints have the same performance cost.
Sometimes one score constraint can kill the score calculation performance outright.
Use the <link linkend="benchmarker">Benchmarker</link> to do a one minute run and check what happens to the score calculation speed if you comment out all but one of the score constraints.</simpara>
</section>
<section xml:id="fairnessScoreConstraints">
<title>Fairness Score Constraints</title>
<simpara>Some use cases have a business requirement to provide a fair schedule (usually as a soft score constraint), for example:</simpara>
<itemizedlist>
<listitem>
<simpara>Fairly distribute the workload amongst the employees, to avoid envy.</simpara>
</listitem>
<listitem>
<simpara>Evenly distribute the workload amongst assets, to improve reliability.</simpara>
</listitem>
</itemizedlist>
<simpara>Implementing such a constraint can seem difficult (especially because there are different ways to formalize fairness), but usually the <emphasis>squared workload</emphasis> implementation behaves most desirable.
For each employee/asset, count the workload <literal>w</literal> and subtract <literal>w²</literal> from the score.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/fairnessScoreConstraint.png" align="center"/>
</imageobject>
<textobject><phrase>fairnessScoreConstraint</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>As shown above, the <emphasis>squared workload</emphasis> implementation guarantees that if you select two employees from a given solution and make their distribution between those two employees fairer, then the resulting new solution will have a better overall score.
Don not just use the difference from the average workload, as that can lead to unfairness, as demonstrated below.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/fairnessScoreConstraintPitfall.png" align="center"/>
</imageobject>
<textobject><phrase>fairnessScoreConstraintPitfall</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Instead of the <emphasis>squared workload</emphasis>, it is also possible to use the <link xlink:href="http://en.wikipedia.org/wiki/Variance">variance</link> (squared difference to the average) or the <link xlink:href="http://en.wikipedia.org/wiki/Standard_deviation">standard deviation</link> (square root of the variance). This has no effect on the score comparison, because the average will not change during planning.
It is just more work to implement (because the average needs to be known) and trivially slower (because the calculation is a bit longer).</simpara>
</note>
<simpara>When the workload is perfect balanced, the user often likes to see a <literal>0</literal> score, instead of the distracting <literal>-34soft</literal> in the image above (for the last solution which is almost perfectly balanced). To nullify this, either add the average multiplied by the number of entities to the score or instead show the variance or standard deviation in the UI.</simpara>
</section>
</section>
<section xml:id="explainingTheScore">
<title>Explaining the Score: Using Score Calculation Outside the <literal>Solver</literal></title>
<simpara>If other parts of your application, for example your webUI, need to calculate the score of a solution,
reuse the <literal>ScoreDirectorFactory</literal> of the <literal>Solver</literal> to build a separate <literal>ScoreDirector</literal> for that webUI:</simpara>
<programlisting language="java" linenumbering="unnumbered">ScoreDirectorFactory&lt;CloudBalance&gt; scoreDirectorFactory = solver.getScoreDirectorFactory();
try (ScoreDirector&lt;CloudBalance&gt; guiScoreDirector = scoreDirectorFactory.buildScoreDirector()) {
    ...
}</programlisting>
<note>
<simpara>The <literal>try</literal> ARM will call <literal>ScoreDirector.close()</literal> when the <literal>ScoreDirector</literal> becomes useless,
to avoid a memory leak, especially with <link linkend="droolsScoreCalculation">Drools score calculation</link>.</simpara>
</note>
<simpara>Then use it when you need to calculate the <literal>Score</literal> of a <literal>Solution</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">guiScoreDirector.setWorkingSolution(cloudBalance);
Score score = guiScoreDirector.calculateScore();</programlisting>
<simpara>Furthermore, the <literal>ScoreDirector</literal> can explain the score with constraint match totals and/or indictments:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ScoreCalculation/scoreVisualization.png" align="center"/>
</imageobject>
<textobject><phrase>scoreVisualization</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="constraintMatchTotal">
<title>Constraint Match Total: Break down the Score by Constraint</title>
<simpara>To break down the score per constraint (so per score rule with Drools score calculation),
get the <literal>ConstraintMatchTotal</literal>s from the <literal>ScoreDirector</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">for (ConstraintMatchTotal constraintMatchTotal : guiScoreDirector.getConstraintMatchTotals()) {
    String constraintName = constraintMatchTotal.getConstraintName();
    // The score impact of that constraint
    Score scoreTotal = constraintMatchTotal.getScoreTotal();

    for (ConstraintMatch constraintMatch : constraintMatchTotal.getConstraintMatchSet()) {
        List&lt;Object&gt; justificationList = constraintMatch.getJustificationList();
        Score score = constraintMatch.getScore();
        ...
    }
}</programlisting>
<simpara>Each <literal>ConstraintMatchTotal</literal> is one constraint (so  one score rule) and has a part of the overall score.
The sum of <literal>ConstraintMatchTotal.getScoreTotal()</literal> equals the overall score.</simpara>
<note>
<simpara><link linkend="droolsScoreCalculation">Drools score calculation</link> supports constraint matches automatically,
but <link linkend="incrementalJavaScoreCalculation">incremental Java score calculation</link> requires
<link linkend="constraintMatchAwareIncrementalScoreCalculator">implementing an extra interface</link>.</simpara>
</note>
</section>
<section xml:id="indictmentHeatMap">
<title>Indictment Heat Map: Visualize the Hot Planning Entities</title>
<simpara>To show a heat map in the UI that highlights the planning entities and problem facts have an impact on the <literal>Score</literal>,
get the <literal>Indictment</literal> map from the <literal>ScoreDirector</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">Map&lt;Object, Indictment&gt; indictmentMap = guiScoreDirector.getIndictmentMap();
for (CloudProcess process = cloudBalance.getProcessList()) {
    Indictment indictment = indictmentMap.get(process);
    if (indictment == null) {
        continue;
    }
    // The score impact of that planning entity
    Score scoreTotal = indictment.getScoreTotal();

    for (ConstraintMatch constraintMatch : indictment.getConstraintMatchSet()) {
        String constraintName = constraintMatch.getConstraintName();
        Score score = constraintMatch.getScore();
        ...
    }
}</programlisting>
<simpara>Each <literal>Indictment</literal> is the sum of all constraints where that justification object is involved with.
The sum of <literal>Indictment.getScoreTotal()</literal> differs from the overall score,
because multiple <literal>Indictment</literal>s can share the same <literal>ConstraintMatch</literal>.</simpara>
<note>
<simpara><link linkend="droolsScoreCalculation">Drools score calculation</link> supports indictments and constraint matches automatically,
but <link linkend="incrementalJavaScoreCalculation">incremental Java score calculation</link> requires
<link linkend="constraintMatchAwareIncrementalScoreCalculator">implementing an extra interface</link>.</simpara>
</note>
</section>
</section>
<section xml:id="testingScoreConstraints">
<title>Testing score constraints with JUnit</title>
<simpara>It’s recommended to write a unit test for each score constraint individually to check that it behaves correctly.</simpara>
<simpara>Add a test scoped dependency to the <literal>optaplanner-test</literal> jar to take advantage of the JUnit integration
and use the <literal>ScoreVerifier</literal> classes to test score rules in DRL (or a constraint match aware incremental score calculator).
For example, suppose we want to test these score rules:</simpara>
<screen>global HardSoftScoreHolder scoreHolder;

rule "requiredCpuPowerTotal"
    when
        ...
    then
        scoreHolder.addHardConstraintMatch(...);
end

...

rule "computerCost"
    when
        ...
    then
        scoreHolder.addSoftConstraintMatch(...);
end</screen>
<simpara>For each score rule, we have a separate <literal>@Test</literal> that only tests the effect of that score rule on the score:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CloudBalancingScoreConstraintTest {

    private HardSoftScoreVerifier&lt;CloudBalance&gt; scoreVerifier = new HardSoftScoreVerifier&lt;&gt;(
            SolverFactory.createFromXmlResource(
                    "org/optaplanner/examples/cloudbalancing/solver/cloudBalancingSolverConfig.xml"));

    @Test
    public void requiredCpuPowerTotal() {
        CloudComputer c1 = new CloudComputer(1L, 1000, 1, 1, 1);
        CloudComputer c2 = new CloudComputer(2L, 200, 1, 1, 1);
        CloudProcess p1 = new CloudProcess(1L, 700, 0, 0);
        CloudProcess p2 = new CloudProcess(2L, 70, 0, 0);
        CloudBalance solution = new CloudBalance(0L,
                Arrays.asList(c1, c2),
                Arrays.asList(p1, p2));
        // Uninitialized
        scoreVerifier.assertHardWeight("requiredCpuPowerTotal", 0, solution);
        p1.setComputer(c1);
        p2.setComputer(c1);
        // Usage 700 + 70 is within capacity 1000 of c1
        scoreVerifier.assertHardWeight("requiredCpuPowerTotal", 0, solution);
        p1.setComputer(c2);
        p2.setComputer(c2);
        // Usage 700 + 70 is above capacity 200 of c2
        scoreVerifier.assertHardWeight("requiredCpuPowerTotal", -570, solution);
    }

    ...

    @Test
    public void computerCost() {
        CloudComputer c1 = new CloudComputer(1L, 1, 1, 1, 200);
        CloudComputer c2 = new CloudComputer(2L, 1, 1, 1, 30);
        CloudProcess p1 = new CloudProcess(1L, 0, 0, 0);
        CloudProcess p2 = new CloudProcess(2L, 0, 0, 0);
        CloudBalance solution = new CloudBalance(0L,
                Arrays.asList(c1, c2),
                Arrays.asList(p1, p2));
        // Uninitialized
        scoreVerifier.assertSoftWeight("computerCost", 0, solution);
        p1.setComputer(c1);
        p2.setComputer(c1);
        // Pay 200 for c1
        scoreVerifier.assertSoftWeight("computerCost", -200, solution);
        p2.setComputer(c2);
        // Pay 200 + 30 for c1 and c2
        scoreVerifier.assertSoftWeight("computerCost", -230, solution);
    }

}</programlisting>
<simpara>There is a <literal>ScoreVerifier</literal> implementation for each <literal>Score</literal> implementation.
In the <literal>assertHardWeight()</literal> and <literal>assertSoftWeight()</literal> methods, the weight of the other score rules is ignored (even those of the same score level).</simpara>
<note>
<simpara>A ScoreVerifier does not work well to isolate score corruption,
use <link linkend="invalidScoreDetection">an <literal>assertionScoreDirectorFactory</literal></link> instead.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="optimizationAlgorithms">
<title>Optimization Algorithms</title>
<section xml:id="searchSpaceSize">
<title>Search Space Size in the Real World</title>
<simpara>The number of possible solutions for a planning problem can be mind blowing.
For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Four queens has <literal>256</literal> possible solutions (<literal>4^4</literal>) and two optimal solutions.</simpara>
</listitem>
<listitem>
<simpara>Five queens has <literal>3125</literal> possible solutions (<literal>5^5</literal>) and one optimal solution.</simpara>
</listitem>
<listitem>
<simpara>Eight queens has <literal>16777216</literal> possible solutions (<literal>8^8</literal>) and 92 optimal solutions.</simpara>
</listitem>
<listitem>
<simpara>64 queens has more than <literal>10^115</literal> possible solutions (<literal>64^64</literal>).</simpara>
</listitem>
<listitem>
<simpara>Most real-life planning problems have an incredible number of possible solutions and only one or a few optimal solutions.</simpara>
</listitem>
</itemizedlist>
<simpara>For comparison: the minimal number of atoms in the known universe (10^80). As a planning problem gets bigger, the search space tends to blow up really fast.
Adding only one extra planning entity or planning value can heavily multiply the running time of some algorithms.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/cloudBalanceSearchSpaceSize.png" align="center"/>
</imageobject>
<textobject><phrase>cloudBalanceSearchSpaceSize</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Calculating the number of possible solutions depends on the design of the domain model:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/searchSpaceSizeCalculation.png" align="center"/>
</imageobject>
<textobject><phrase>searchSpaceSizeCalculation</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>This search space size calculation includes infeasible solutions (if they can be represented by the model), because:</simpara>
<itemizedlist>
<listitem>
<simpara>The optimal solution might be infeasible.</simpara>
</listitem>
<listitem>
<simpara>There are many types of hard constraints that cannot be incorporated in the formula practically. For example, in Cloud Balancing, try incorporating the CPU capacity constraint in the formula.</simpara>
</listitem>
</itemizedlist>
<simpara>Even in cases where adding some of the hard constraints in the formula is practical (for example, Course Scheduling), the resulting search space is still huge.</simpara>
</note>
<simpara>An algorithm that checks every possible solution (even with pruning, such as in <link linkend="branchAndBound">Branch And Bound</link>) can easily run for billions of years on a single real-life planning problem.
The aim is to find the best solution in the available timeframe.
Planning competitions (such as the International Timetabling Competition) show that Local Search variations
(<link linkend="tabuSearch">Tabu Search</link>, <link linkend="simulatedAnnealing">Simulated Annealing</link>, <link linkend="lateAcceptance">Late Acceptance</link>, …​)
usually perform best for real-world problems given real-world time limitations.</simpara>
</section>
<section xml:id="doesPlannerFindTheOptimalSolution">
<title>Does Planner Find the Optimal Solution?</title>
<simpara>The business wants the optimal solution, but they also have other requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>Scale out: Large production data sets must not crash and have also good results.</simpara>
</listitem>
<listitem>
<simpara>Optimize the right problem: The constraints must match the actual business needs.</simpara>
</listitem>
<listitem>
<simpara>Available time: The solution must be found in time, before it becomes useless to execute.</simpara>
</listitem>
<listitem>
<simpara>Reliability: Every data set must have at least a decent result (better than a human planner).</simpara>
</listitem>
</itemizedlist>
<simpara>Given these requirements, and despite the promises of some salesmen, it is usually impossible for anyone or anything to find the optimal solution.
Therefore, Planner focuses on finding the best solution in available time.
In <link linkend="examplesOverview">"realistic, independent competitions"</link>, it often comes out as the best <emphasis>reusable</emphasis> software.</simpara>
<simpara>The nature of NP-complete problems make scaling a prime concern.</simpara>
<note>
<simpara>The quality of a result from a small data set is no indication of the quality of a result from a large data set.</simpara>
</note>
<simpara>Scaling issues cannot be mitigated by hardware purchases later on.
Start testing with a production sized data set as soon as possible.
Do not assess quality on small data sets (unless production encounters only such data sets). Instead, solve a production sized data set and compare the results of longer executions, different algorithms and - if available - the human planner.</simpara>
</section>
<section xml:id="architectureOverview">
<title>Architecture Overview</title>
<simpara>Planner is the first framework to combine optimization algorithms (metaheuristics, …​) with score calculation by a rule engine (such as Drools Expert). This combination is very efficient, because:</simpara>
<itemizedlist>
<listitem>
<simpara>A rule engine, such as Drools Expert, is <emphasis role="strong">great for calculating the score</emphasis> of a solution of a planning problem. It makes it easy and scalable to add additional soft or hard constraints such as, "a teacher should not teach more then seven hours a day". It does delta-based score calculation without any extra code. However it tends to be not suitable to actually find new solutions.</simpara>
</listitem>
<listitem>
<simpara>An optimization algorithm is <emphasis role="strong">great at finding new improving solutions</emphasis> for a planning problem, without necessarily brute-forcing every possibility. However, it needs to know the score of a solution and offers no support in calculating that score efficiently.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/architectureOverview.png" align="center"/>
</imageobject>
<textobject><phrase>architectureOverview</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="optimizationAlgorithmsOverview">
<title>Optimization Algorithms Overview</title>
<simpara>Planner supports three <emphasis>families</emphasis> of optimization algorithms: Exhaustive Search, Construction Heuristics and Metaheuristics.
In practice, Metaheuristics (in combination with Construction Heuristics to initialize) are the recommended choice:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/scalabilityOfOptimizationAlgorithms.png" align="center"/>
</imageobject>
<textobject><phrase>scalabilityOfOptimizationAlgorithms</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each of these algorithm families have multiple optimization algorithms:</simpara>
<table frame="all" rowsep="1" colsep="1">
<title>Optimization Algorithms Overview</title>
<tgroup cols="6">
<colspec colname="col_1" colwidth="17*"/>
<colspec colname="col_2" colwidth="17*"/>
<colspec colname="col_3" colwidth="17*"/>
<colspec colname="col_4" colwidth="17*"/>
<colspec colname="col_5" colwidth="17*"/>
<colspec colname="col_6" colwidth="17*"/>
<thead>
<row>
<entry align="left" valign="top">Algorithm</entry>
<entry align="left" valign="top">Scalable?</entry>
<entry align="left" valign="top">Optimal?</entry>
<entry align="left" valign="top">Easy to use?</entry>
<entry align="left" valign="top">Tweakable?</entry>
<entry align="left" valign="top">Requires CH?</entry>
</row>
</thead>
<tbody>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_6"><simpara><emphasis role="strong">Exhaustive Search (ES)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="bruteForce">Brute Force</link></simpara></entry>
<entry align="left" valign="top"><simpara>0/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>0/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="branchAndBound">Branch And Bound</link></simpara></entry>
<entry align="left" valign="top"><simpara>0/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_6"><simpara><emphasis role="strong">Construction heuristics (CH)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="firstFit">First Fit</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>1/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>1/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="firstFitDecreasing">First Fit Decreasing</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="weakestFit">Weakest Fit</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="weakestFitDecreasing">Weakest Fit Decreasing</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="strongestFit">Strongest Fit</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="strongestFitDecreasing">Strongest Fit Decreasing</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="cheapestInsertion">Cheapest Insertion</link></simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>  <link linkend="regretInsertion">Regret Insertion</link></simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>No</simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_6"><simpara><emphasis role="strong">Metaheuristics (MH)</emphasis></simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_6"><simpara>  Local Search (LS)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="hillClimbing">Hill Climbing</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="tabuSearch">Tabu Search</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="simulatedAnnealing">Simulated Annealing</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="lateAcceptance">Late Acceptance</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="stepCountingHillClimbing">Step Counting Hill Climbing</link></simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top" namest="col_1" nameend="col_6"><simpara>  Evolutionary Algorithms (EA)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="evolutionaryStrategies">Evolutionary Strategies</link></simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>    <link linkend="geneticAlgorithms">Genetic Algorithms</link></simpara></entry>
<entry align="left" valign="top"><simpara>4/5</simpara></entry>
<entry align="left" valign="top"><simpara>3/5</simpara></entry>
<entry align="left" valign="top"><simpara>2/5</simpara></entry>
<entry align="left" valign="top"><simpara>5/5</simpara></entry>
<entry align="left" valign="top"><simpara>Yes</simpara></entry>
</row>
</tbody>
</tgroup>
</table>
<simpara>To learn more about metaheuristics, see  <link xlink:href="http://www.cs.gmu.edu/~sean/book/metaheuristics/">Essentials of Metaheuristics</link> or <link xlink:href="http://www.cleveralgorithms.com/">Clever Algorithms</link>.</simpara>
</section>
<section xml:id="whichOptimizationAlgorithmsShouldIUse">
<title>Which Optimization Algorithms Should I Use?</title>
<simpara>The best optimization algorithms configuration to use depends heavily on your use case.
However, this basic procedure provides a good starting configuration that will produce better than average results.</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Start with a quick configuration that involves little or no configuration and optimization code:
See <link linkend="firstFit">First Fit</link>.</simpara>
</listitem>
<listitem>
<simpara>Next, implement <link linkend="planningEntityDifficulty">planning entity difficulty</link> comparison and turn it into <link linkend="firstFitDecreasing">First Fit Decreasing</link>.</simpara>
</listitem>
<listitem>
<simpara>Next, add Late Acceptance behind it:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>First Fit Decreasing.</simpara>
</listitem>
<listitem>
<simpara><link linkend="lateAcceptance">Late Acceptance</link>.</simpara>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
<simpara>At this point, the return on invested time lowers and the result is likely to be sufficient.</simpara>
<simpara>However, this can be improved at a lower return on invested time.
Use the <link linkend="benchmarker">Benchmarker</link> and try a couple of different Tabu Search, Simulated Annealing and Late Acceptance configurations, for example:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>First Fit Decreasing: <link linkend="tabuSearch">Tabu Search</link>.</simpara>
</listitem>
</orderedlist>
<simpara>Use the <link linkend="benchmarker">Benchmarker</link> to improve the values for the size parameters.</simpara>
<simpara>Other experiments can also be run. For example, the following multiple algorithms can be combined together:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>First Fit Decreasing</simpara>
</listitem>
<listitem>
<simpara>Late Acceptance (relatively long time)</simpara>
</listitem>
<listitem>
<simpara>Tabu Search (relatively short time)</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="powerTweaking">
<title>Power tweaking or default parameter values</title>
<simpara>Many optimization algorithms have parameters that affect results and scalability.
Planner applies <emphasis>configuration by exception</emphasis>, so all optimization algorithms have default parameter values.
This is very similar to the Garbage Collection parameters in a JVM: most users have no need to tweak them, but power users often do.</simpara>
<simpara>The default parameter values are sufficient for many cases (and especially for prototypes), but if development time allows, it may be beneficial to power tweak them with the <link linkend="benchmarker">benchmarker</link> for better results and scalability on a specific use case.
The documentation for each optimization algorithm also declares the advanced configuration for power tweaking.</simpara>
<warning>
<simpara>The default value of parameters will change between minor versions, to improve them for most users. The advanced configuration can be used to prevent unwanted changes, however, this is not recommended.</simpara>
</warning>
</section>
<section xml:id="solverPhase">
<title>Solver Phase</title>
<simpara>A <literal>Solver</literal> can use multiple optimization algorithms in sequence.
<emphasis role="strong">Each optimization algorithm is represented by one solver <literal>Phase</literal>.</emphasis>
There is never more than one <literal>Phase</literal> solving at the same time.</simpara>
<note>
<simpara>Some <literal>Phase</literal> implementations can combine techniques from multiple optimization algorithms, but it is still just one <literal>Phase</literal>.
For example: a Local Search <literal>Phase</literal> can do Simulated Annealing with entity Tabu.</simpara>
</note>
<simpara>Here is a configuration that runs three phases in sequence:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;constructionHeuristic&gt;
    ... &lt;!-- First phase: First Fit Decreasing --&gt;
  &lt;/constructionHeuristic&gt;
  &lt;localSearch&gt;
    ... &lt;!-- Second phase: Late Acceptance --&gt;
  &lt;/localSearch&gt;
  &lt;localSearch&gt;
    ... &lt;!-- Third phase: Tabu Search --&gt;
  &lt;/localSearch&gt;
&lt;/solver&gt;</programlisting>
<simpara>The solver phases are run in the order defined by solver configuration.</simpara>
<itemizedlist>
<listitem>
<simpara>When the first <literal>Phase</literal> terminates, the second <literal>Phase</literal> starts, and so on.</simpara>
</listitem>
<listitem>
<simpara>When the last <literal>Phase</literal> terminates, the <literal>Solver</literal> terminates.</simpara>
</listitem>
</itemizedlist>
<simpara>Usually, a <literal>Solver</literal> will first run a construction heuristic and then run one or multiple metaheuristics:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/generalPhaseSequence.png" align="center"/>
</imageobject>
<textobject><phrase>generalPhaseSequence</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If no phases are configured, Planner will default to a Construction Heuristic phase followed by a Local Search phase.</simpara>
<simpara>Some phases (especially construction heuristics) will terminate automatically.
Other phases (especially metaheuristics) will only terminate if the <literal>Phase</literal> is configured to terminate:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;termination&gt;&lt;!-- Solver termination --&gt;
    &lt;secondsSpentLimit&gt;90&lt;/secondsSpentLimit&gt;
  &lt;/termination&gt;
  &lt;localSearch&gt;
    &lt;termination&gt;&lt;!-- Phase termination --&gt;
      &lt;secondsSpentLimit&gt;60&lt;/secondsSpentLimit&gt;&lt;!-- Give the next phase a chance to run too, before the Solver terminates --&gt;
    &lt;/termination&gt;
    ...
  &lt;/localSearch&gt;
  &lt;localSearch&gt;
    ...
  &lt;/localSearch&gt;
&lt;/solver&gt;</programlisting>
<simpara>If the <literal>Solver</literal> terminates (before the last <literal>Phase</literal> terminates itself,
the current phase is terminated and all subsequent phases will not run.</simpara>
</section>
<section xml:id="scopeOverview">
<title>Scope Overview</title>
<simpara>A solver will iteratively run phases. Each phase will usually iteratively run steps. Each step, in turn, usually iteratively runs moves.
These form four nested scopes:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Solver</simpara>
</listitem>
<listitem>
<simpara>Phase</simpara>
</listitem>
<listitem>
<simpara>Step</simpara>
</listitem>
<listitem>
<simpara>Move</simpara>
</listitem>
</orderedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/scopeOverview.png" align="center"/>
</imageobject>
<textobject><phrase>scopeOverview</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Configure <link linkend="logging">logging</link> to display the log messages of each scope.</simpara>
</section>
<section xml:id="termination">
<title>Termination</title>
<simpara>Not all phases terminate automatically and may take a significant amount of time.
A <literal>Solver</literal> can be terminated synchronously by up-front configuration, or asynchronously from another thread.</simpara>
<simpara>Metaheuristic phases in particular need to be instructed to stop solving.
This can be because of a number of reasons, for example, if the time is up, or the perfect score has been reached just before its solution is used.
Finding the optimal solution cannot be relied on (unless you know the optimal score), because a metaheuristic algorithm is generally unaware of the optimal solution.</simpara>
<simpara>This is not an issue for real-life problems, as finding the optimal solution may take more time than is available.
Finding the best solution in the available time is the most important outcome.</simpara>
<important>
<simpara>If no termination is configured (and a metaheuristic algorithm is used), the <literal>Solver</literal> will run forever, until <link linkend="asynchronousTermination">terminateEarly()</link> is called from another thread.
This is especially common during <link linkend="realTimePlanning">real-time planning</link>.</simpara>
</important>
<simpara>For synchronous termination, configure a <literal>Termination</literal> on a <literal>Solver</literal> or a <literal>Phase</literal> when it needs to stop.
The built-in implementations of these should be sufficient, however a custom <literal>Termination</literal> can also be used.
Every <literal>Termination</literal> can calculate a <emphasis>time gradient</emphasis> (needed for some optimization algorithms), which is a ratio between the time already spent solving and the estimated entire solving time of the <literal>Solver</literal> or <literal>Phase</literal>.</simpara>
<section xml:id="timeMillisSpentTermination">
<title>TimeMillisSpentTermination</title>
<simpara>Terminates when an amount of time has been used.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;millisecondsSpentLimit&gt;500&lt;/millisecondsSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;secondsSpentLimit&gt;10&lt;/secondsSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;minutesSpentLimit&gt;5&lt;/minutesSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;hoursSpentLimit&gt;1&lt;/hoursSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;daysSpentLimit&gt;2&lt;/daysSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>Multiple time types can be used together, for example to configure 150 minutes, either configure it directly:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;minutesSpentLimit&gt;150&lt;/minutesSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>Or use a combination that sums up to 150 minutes:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;hoursSpentLimit&gt;2&lt;/hoursSpentLimit&gt;
    &lt;minutesSpentLimit&gt;30&lt;/minutesSpentLimit&gt;
  &lt;/termination&gt;</programlisting>
<note>
<simpara>This <literal>Termination</literal> will most likely sacrifice perfect reproducibility (even with <literal>environmentMode</literal> <literal>REPRODUCIBLE</literal>) because the available CPU time differs frequently between runs:</simpara>
<itemizedlist>
<listitem>
<simpara>The available CPU time influences the number of steps that can be taken, which might be a few more or less.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Termination</literal> might produce slightly different time gradient values, which will send time gradient-based algorithms (such as Simulated Annealing) on a radically different path.</simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="unimprovedTimeMillisSpentTermination">
<title>UnimprovedTimeMillisSpentTermination</title>
<simpara>Terminates when the best score has not improved in a specified amount of time.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;unimprovedMillisecondsSpentLimit&gt;500&lt;/unimprovedMillisecondsSpentLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;unimprovedSecondsSpentLimit&gt;10&lt;/unimprovedSecondsSpentLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;unimprovedMinutesSpentLimit&gt;5&lt;/unimprovedMinutesSpentLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;unimprovedHoursSpentLimit&gt;1&lt;/unimprovedHoursSpentLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;unimprovedDaysSpentLimit&gt;1&lt;/unimprovedDaysSpentLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>This termination should not be applied to Construction Heuristics as they only update the best solution at the end.
Configuring it on a specific <literal>Phase</literal> (such as <literal>&lt;localSearch&gt;</literal>), instead of on the <literal>Solver</literal> itself may be a better option.</simpara>
<note>
<simpara>This <literal>Termination</literal> will most likely sacrifice perfect reproducibility (even with <literal>environmentMode</literal> <literal>REPRODUCIBLE</literal>) as the available CPU time differs frequently between runs:</simpara>
<itemizedlist>
<listitem>
<simpara>The available CPU time influences the number of steps that can be taken, which might be a few more or less.</simpara>
</listitem>
<listitem>
<simpara>The <literal>Termination</literal> might produce slightly different time gradient values, which will send time gradient based algorithms (such as Simulated Annealing) on a radically different path.</simpara>
</listitem>
</itemizedlist>
</note>
</section>
<section xml:id="bestScoreTermination">
<title>BestScoreTermination</title>
<simpara><literal>BestScoreTermination</literal> terminates when a certain score has been reached.
Use this <literal>Termination</literal> where the perfect score is known, for example for four queens (which uses a <link linkend="simpleScore">SimpleScore</link>):</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;bestScoreLimit&gt;0&lt;/bestScoreLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>A planning problem with a <link linkend="hardSoftScore">HardSoftScore</link> may look like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;bestScoreLimit&gt;0hard/-5000soft&lt;/bestScoreLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>A planning problem with a <link linkend="bendableScore">BendableScore</link> with three hard levels and one soft level may look like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;bestScoreLimit&gt;[0/0/0]hard/[-5000]soft&lt;/bestScoreLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>In this instance, <literal>Termination</literal> once a feasible solution has been reached is not practical because it requires a <literal>bestScoreLimit</literal> such as <literal>0hard/-2147483648soft</literal>. Use the next termination instead.</simpara>
</section>
<section xml:id="bestScoreFeasibleTermination">
<title>BestScoreFeasibleTermination</title>
<simpara>Terminates as soon as a feasible solution has been discovered.
Requires that <literal>Score</literal> implements <literal>FeasibilityScore</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;bestScoreFeasible&gt;true&lt;/bestScoreFeasible&gt;
  &lt;/termination&gt;</programlisting>
<simpara>This <literal>Termination</literal> is usually combined with other terminations.</simpara>
</section>
<section xml:id="stepCountTermination">
<title>StepCountTermination</title>
<simpara>Terminates when a number of steps has been reached.
This is useful for hardware performance independent runs.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;stepCountLimit&gt;100&lt;/stepCountLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>This <literal>Termination</literal> can only be used for a <literal>Phase</literal> (such as <literal>&lt;localSearch&gt;</literal>), not for the <literal>Solver</literal> itself.</simpara>
</section>
<section xml:id="unimprovedStepCountTermination">
<title>UnimprovedStepCountTermination</title>
<simpara>Terminates when the best score has not improved in a number of steps.
This is useful for hardware performance independent runs.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;termination&gt;
      &lt;unimprovedStepCountLimit&gt;100&lt;/unimprovedStepCountLimit&gt;
    &lt;/termination&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>If the score has not improved recently, it is unlikely to improve in a reasonable timeframe.
It has been observed that once a new best solution is found (even after a long time without improvement on the best solution), the next few steps tend to improve the best solution.</simpara>
<simpara>This <literal>Termination</literal> can only be used for a <literal>Phase</literal> (such as <literal>&lt;localSearch&gt;</literal>), not for the <literal>Solver</literal> itself.</simpara>
</section>
<section xml:id="scoreCalculationCountTermination">
<title>ScoreCalculationCountTermination</title>
<simpara><literal>ScoreCalculationCountTermination</literal> terminates when a number of score calculations have been reached.
This is often the sum of the number of moves and the number of steps.
This is useful for benchmarking.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;scoreCalculationCountLimit&gt;100000&lt;/scoreCalculationCountLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>Switching <link linkend="environmentMode">EnvironmentMode</link> can heavily impact when this termination ends.</simpara>
</section>
<section xml:id="combiningMultipleTerminations">
<title>Combining Multiple Terminations</title>
<simpara>Terminations can be combined, for example: terminate after <literal>100</literal> steps or if a score of <literal>0</literal> has been reached:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;terminationCompositionStyle&gt;OR&lt;/terminationCompositionStyle&gt;
    &lt;stepCountLimit&gt;100&lt;/stepCountLimit&gt;
    &lt;bestScoreLimit&gt;0&lt;/bestScoreLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>Alternatively you can use <literal>AND</literal>, for example: terminate after reaching a feasible score of at least <literal>-100</literal> and no improvements in <literal>5</literal> steps:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;termination&gt;
    &lt;terminationCompositionStyle&gt;AND&lt;/terminationCompositionStyle&gt;
    &lt;unimprovedStepCountLimit&gt;5&lt;/unimprovedStepCountLimit&gt;
    &lt;bestScoreLimit&gt;-100&lt;/bestScoreLimit&gt;
  &lt;/termination&gt;</programlisting>
<simpara>This example ensures it does not just terminate after finding a feasible solution, but also completes any obvious improvements on that solution before terminating.</simpara>
</section>
<section xml:id="asynchronousTermination">
<title>Asynchronous Termination from Another Thread</title>
<simpara>Asychronous termination from another thread occurs when a <literal>Solver</literal> needs to be terminated early from another thread, for example, due to a user action or a server restart.
This cannot be configured by a <literal>Termination</literal> as it is impossible to predict when and if it will occur.
Therefore the <literal>Solver</literal> interface has the following thread-safe methods:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Solver&lt;Solution_&gt; {
    ...

    boolean terminateEarly();
    boolean isTerminateEarly();

}</programlisting>
<simpara>When calling the <literal>terminateEarly()</literal> method from another thread, the <literal>Solver</literal> will terminate at its earliest convenience and the <literal>solve(Solution)</literal> method will return (in the original <literal>Solver</literal> thread).</simpara>
<note>
<simpara>Interrupting the Solver thread (which is the thread that called <literal>Solver.solve(Solution)</literal>) has the same affect as calling <literal>terminateEarly()</literal> except that it leaves that thread in the interrupted state.
This guarantees a graceful shutdown when an <literal>ExecutorService</literal> (such as a thread pool) is shutdown because that only interrupts all active threads in the pool.</simpara>
</note>
</section>
</section>
<section xml:id="SolverEventListener">
<title>SolverEventListener</title>
<simpara>Each time a new best solution is found, a new <literal>BestSolutionChangedEvent</literal> is fired in the <literal>Solver</literal> thread.</simpara>
<simpara>To listen to such events, add a <literal>SolverEventListener</literal> to the <literal>Solver</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Solver&lt;Solution_&gt; {
    ...

    void addEventListener(SolverEventListener&lt;S&gt; eventListener);
    void removeEventListener(SolverEventListener&lt;S&gt; eventListener);

}</programlisting>
<simpara>The <literal>BestSolutionChangedEvent</literal>'s <literal>newBestSolution</literal> may not be initialized or feasible.
Use the <literal>isFeasible()</literal> method on <literal>BestSolutionChangedEvent</literal>'s new best <literal>Score</literal> to detect such cases:</simpara>
<programlisting language="java" linenumbering="unnumbered">    solver.addEventListener(new SolverEventListener&lt;CloudBalance&gt;() {
        public void bestSolutionChanged(BestSolutionChangedEvent&lt;CloudBalance&gt; event) {
            // Ignore infeasible (including uninitialized) solutions
            if (event.getNewBestSolution().getScore().isFeasible()) {
                ...
            }
        }
    });</programlisting>
<simpara>Use <literal>Score.isSolutionInitialized()</literal> instead of <literal>Score.isFeasible()</literal> to only ignore uninitialized solutions, but also accept infeasible solutions.</simpara>
<warning>
<simpara>The <literal>bestSolutionChanged()</literal> method is called in the solver’s thread, as part of <literal>Solver.solve()</literal>.
So it should return quickly to avoid slowing down the solving.</simpara>
</warning>
</section>
<section xml:id="customSolverPhase">
<title>Custom Solver Phase</title>
<simpara>Run a custom optmization algorithm etween phases or before the first phase to initialize the <literal>Solution</literal>, or to get a better score quickly.
You will still want to reuse the score calculation.
For example, to implement a custom Construction Heuristic without implementing an entire <literal>Phase</literal>.</simpara>
<note>
<simpara>Most of the time, a custom solver phase is not worth the development time investment.
The supported <link linkend="constructionHeuristics">Constructions Heuristics</link> are configurable (use the <link linkend="benchmarker">Benchmarker</link> to tweak them),
<literal>Termination</literal> aware and support partially initialized solutions too.</simpara>
</note>
<simpara>The <literal>CustomPhaseCommand</literal> interface appears as follows:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface CustomPhaseCommand&lt;Solution_&gt; {
    ...

    void changeWorkingSolution(ScoreDirector&lt;Solution_&gt; scoreDirector);

}</programlisting>
<simpara>For example, extend <literal>AbstractCustomPhaseCommand</literal> and implement the <literal>changeWorkingSolution()</literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class ToOriginalMachineSolutionInitializer extends AbstractCustomPhaseCommand&lt;MachineReassignment&gt; {

    public void changeWorkingSolution(ScoreDirector&lt;MachineReassignment&gt; scoreDirector) {
        MachineReassignment machineReassignment = scoreDirector.getWorkingSolution();
        for (MrProcessAssignment processAssignment : machineReassignment.getProcessAssignmentList()) {
            scoreDirector.beforeVariableChanged(processAssignment, "machine");
            processAssignment.setMachine(processAssignment.getOriginalMachine());
            scoreDirector.afterVariableChanged(processAssignment, "machine");
            scoreDirector.triggerVariableListeners();
        }
    }

}</programlisting>
<warning>
<simpara>Any change on the planning entities in a <literal>CustomPhaseCommand</literal> must be notified to the <literal>ScoreDirector</literal>.</simpara>
</warning>
<warning>
<simpara>Do not change any of the problem facts in a <literal>CustomPhaseCommand</literal>.
That will corrupt the <literal>Solver</literal> because any previous score or solution was for a different problem.
To do that, read about <link linkend="repeatedPlanning">repeated planning</link> and do it with a <link linkend="problemFactChange">ProblemFactChange</link> instead.</simpara>
</warning>
<simpara><literal>CustomPhaseCommand</literal> can be configured using the following:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;customPhase&gt;
    &lt;customPhaseCommandClass&gt;org.optaplanner.examples.machinereassignment.solver.solution.initializer.ToOriginalMachineSolutionInitializer&lt;/customPhaseCommandClass&gt;
  &lt;/customPhase&gt;
  ... &lt;!-- Other phases --&gt;
&lt;/solver&gt;</programlisting>
<simpara>Configure multiple <literal>customPhaseCommandClass</literal> instances to run them in sequence.</simpara>
<important>
<simpara>If the changes of a <literal>CustomPhaseCommand</literal> do not result in a better score, the best solution will not be changed
(so effectively nothing will have changed for the next <literal>Phase</literal> or <literal>CustomPhaseCommand</literal>).
To force such changes anyway, use <literal>forceUpdateBestSolution</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;customPhase&gt;
    &lt;customPhaseCommandClass&gt;...MyCustomPhase&lt;/customPhaseCommandClass&gt;
    &lt;forceUpdateBestSolution&gt;true&lt;/forceUpdateBestSolution&gt;
  &lt;/customPhase&gt;</programlisting>
</important>
<note>
<simpara>If the <literal>Solver</literal> or a <literal>Phase</literal> wants to terminate while a <literal>CustomPhaseCommand</literal> is still running,
it will wait to terminate until the <literal>CustomPhaseCommand</literal> is complete.
This may take a significant amount of time.
The built-in solver phases do not have this issue.</simpara>
</note>
<simpara>To configure values of a <literal>CustomPhaseCommand</literal> dynamically in the solver configuration
(so the <link linkend="benchmarker">Benchmarker</link> can tweak those parameters), add the <literal>customProperties</literal> element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;customPhase&gt;
    &lt;customProperties&gt;
      &lt;mySelectionSize&gt;5&lt;/mySelectionSize&gt;
    &lt;/customProperties&gt;
  &lt;/customPhase&gt;</programlisting>
<simpara>Then add a public setter for each custom property, which is called when a <literal>Solver</literal> is build.
Most value types are supported (including boolean, integers, doubles and strings).</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MyCustomPhase extends AbstractCustomPhaseCommand&lt;MySolution&gt; {

    private int mySelectionSize = 10;

    @SuppressWarnings("unused")
    public void setMySelectionSize(int mySelectionSize) {
        this.mySelectionSize = mySelectionSize;
    }

    ...
}</programlisting>
</section>
<section xml:id="noChangeSolverPhase">
<title>No Change Solver Phase</title>
<simpara>In rare cases, it can be useful to configure that no solver phase should be run.
But by default, configuring no phase will trigger the use of the default phases.
To avoid those, configure a <literal>NoChangePhase</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;noChangePhase/&gt;
&lt;/solver&gt;</programlisting>
</section>
<section xml:id="multiThreadedSolving">
<title>Multi-threaded Solving</title>
<simpara>There are several ways of doing multi-threaded solving:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/OptimizationAlgorithms/multiThreadingStrategies.png" align="center"/>
</imageobject>
<textobject><phrase>multiThreadingStrategies</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>For now, only Partitioned Search is supported out of the box.</simpara>
<note>
<simpara>A <link linkend="logging">logging level</link> of <literal>debug</literal> or <literal>trace</literal> might cause congestion multi-threaded solving
and slow down the <link linkend="scoreCalculationSpeed">score calculation speed</link>.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="moveAndNeighborhoodSelection">
<title><literal>Move</literal> and Neighborhood Selection</title>
<section xml:id="moveAndNeighborhoodSelectionIntroduction">
<title><literal>Move</literal> and Neighborhood Introduction</title>
<section xml:id="whatIsAMove">
<title>What is a <literal>Move</literal>?</title>
<simpara>A <literal>Move</literal> is a change (or set of changes) from a solution A to a solution B.
For example, the move below changes queen <literal>C</literal> from row <literal>0</literal> to row <literal>2</literal>:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/singleMoveNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>singleMoveNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The new solution is called a <emphasis>neighbor</emphasis> of the original solution, because it can be reached in a single <literal>Move</literal>.
Although a single move can change multiple queens, the neighbors of a solution should always be a very small subset of all possible solutions.
For example, on that original solution, these are all possible <literal>changeMove</literal>'s:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/possibleMovesNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>possibleMovesNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>If we ignore the four <literal>changeMove</literal>'s that have not impact and are therefore not doable, we can see that number of moves is <literal>n * (n - 1) = 12</literal>.
This is far less than the number of possible solutions, which is <literal>n ^ n = 256</literal>.
As the problem scales out, the number of possible moves increases far less than the number of possible solutions.</simpara>
<simpara>Yet, in four <literal>changeMove</literal>'s or less we can reach any solution.
For example we can reach a very different solution in three <literal>changeMove</literal>'s:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/sequentialMovesNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>sequentialMovesNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>There are many other types of moves besides <literal>changeMove</literal>'s.
Many move types are included out-of-the-box, but you can also implement custom moves.</simpara>
<simpara>A <literal>Move</literal> can affect multiple entities or even create/delete entities.
But it must not change the problem facts.</simpara>
</note>
<simpara>All optimization algorithms use <literal>Move</literal>'s to transition from one solution to a neighbor solution.
Therefore, all the optimization algorithms are confronted with <literal>Move</literal> selection: the craft of creating and iterating moves efficiently and the art of finding the most promising subset of random moves to evaluate first.</simpara>
</section>
<section xml:id="whatIsAMoveSelector">
<title>What is a <literal>MoveSelector</literal>?</title>
<simpara>A <literal>MoveSelector</literal>'s main function is to create <literal>Iterator&lt;Move&gt;</literal> when needed.
An optimization algorithm will iterate through a subset of those moves.</simpara>
<simpara>Here’s an example how to configure a <literal>changeMoveSelector</literal> for the optimization algorithm Local Search:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;changeMoveSelector/&gt;
    ...
  &lt;/localSearch&gt;</programlisting>
<simpara>Out of the box, this works and all properties of the <literal>changeMoveSelector</literal> are defaulted sensibly (unless that fails fast due to ambiguity). On the other hand, the configuration can be customized significantly for specific use cases.
For example: you might want to configure a <link linkend="filteredSelection">filter</link> to discard pointless moves.</simpara>
</section>
<section xml:id="subselectingOfEntitiesValuesAndOtherMoves">
<title>Subselecting of Entities, Values and Other Moves</title>
<simpara>To create a <literal>Move</literal>, a <literal>MoveSelector</literal> needs to select one or more planning entities and/or planning values to move.
Just like <literal>MoveSelector</literal>s, <literal>EntitySelector</literal>s and <literal>ValueSelector</literal>s need to support a similar feature set (such as scalable just-in-time selection). Therefore, they all implement a common interface <literal>Selector</literal> and they are configured similarly.</simpara>
<simpara>A MoveSelector is often composed out of <literal>EntitySelector</literal>s, <literal>ValueSelector</literal>s or even other <literal>MoveSelector</literal>s, which can be configured individually if desired:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector&gt;
          ...
        &lt;/entitySelector&gt;
        &lt;valueSelector&gt;
          ...
        &lt;/valueSelector&gt;
        ...
      &lt;/changeMoveSelector&gt;
      &lt;swapMoveSelector&gt;
        ...
      &lt;/swapMoveSelector&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>Together, this structure forms a <literal>Selector</literal> tree:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/selectorTree.png" align="center"/>
</imageobject>
<textobject><phrase>selectorTree</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The root of this tree is a <literal>MoveSelector</literal> which is injected into the optimization algorithm implementation to be (partially) iterated in every step.</simpara>
</section>
</section>
<section xml:id="genericMoveSelectors">
<title>Generic MoveSelectors</title>
<section xml:id="changeMoveSelector">
<title>changeMoveSelector</title>
<simpara>For one planning variable, the <literal>ChangeMove</literal> selects one planning entity and one planning value and assigns the entity’s variable to that value.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/changeMove.png" align="center"/>
</imageobject>
<textobject><phrase>changeMove</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector/&gt;</programlisting>
<simpara>If there are multiple entity classes or multiple planning variables for one entity class, a simple configuration will automatically unfold into a <link linkend="unionMoveSelector">union</link> of <literal>ChangeMove</literal> selectors for every planning variable.</simpara>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;entitySelector&gt;
        &lt;entityClass&gt;...Lecture&lt;/entityClass&gt;
        ...
      &lt;/entitySelector&gt;
      &lt;valueSelector variableName="room"&gt;
        ...
        &lt;nearbySelection&gt;...&lt;/nearbySelection&gt;
      &lt;/valueSelector&gt;
    &lt;/changeMoveSelector&gt;</programlisting>
<simpara>A <literal>ChangeMove</literal> is the finest grained move.</simpara>
<important>
<simpara>Almost every <literal>moveSelector</literal> configuration injected into a metaheuristic algorithm should include a changeMoveSelector or a custom implementation.
This guarantees that every possible <literal>Solution</literal> can be reached through applying a number of moves in sequence (not taking <link linkend="scoreTrap">score traps</link> into account). Of course, normally it is unioned with other, more coarse grained move selectors.</simpara>
</important>
</section>
<section xml:id="swapMoveSelector">
<title>swapMoveSelector</title>
<simpara>The <literal>SwapMove</literal> selects two different planning entities and swaps the planning values of all their planning variables.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/swapMove.png" align="center"/>
</imageobject>
<textobject><phrase>swapMove</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Although a <literal>SwapMove</literal> on a single variable is essentially just two <literal>ChangeMove</literal>s, it’s often the winning step where the first of the two <literal>ChangeMove</literal>s would not be the winning step because it leaves the solution in a state with broken hard constraints.
For example: swapping the room of two lectures doesn’t bring the solution in a intermediate state where both lectures are in the same room which breaks a hard constraint.</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;swapMoveSelector/&gt;</programlisting>
<simpara>If there are multiple entity classes, a simple configuration will automatically unfold into a <link linkend="unionMoveSelector">union</link> of <literal>SwapMove</literal> selectors for every entity class.</simpara>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;swapMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;entitySelector&gt;
        &lt;entityClass&gt;...Lecture&lt;/entityClass&gt;
        ...
      &lt;/entitySelector&gt;
      &lt;secondaryEntitySelector&gt;
        &lt;entityClass&gt;...Lecture&lt;/entityClass&gt;
        ...
        &lt;nearbySelection&gt;...&lt;/nearbySelection&gt;
      &lt;/secondaryEntitySelector&gt;
      &lt;variableNameInclude&gt;room&lt;/variableNameInclude&gt;
      &lt;variableNameInclude&gt;...&lt;/variableNameInclude&gt;
    &lt;/swapMoveSelector&gt;</programlisting>
<simpara>The <literal>secondaryEntitySelector</literal> is rarely needed: if it is not specified, entities from the same <literal>entitySelector</literal> are swapped.</simpara>
<simpara>If one or more <literal>variableNameInclude</literal> properties are specified, not all planning variables will be swapped, but only those specified.
For example for course scheduling, specifying only <literal>variableNameInclude</literal> room will make it only swap room, not period.</simpara>
</section>
<section xml:id="pillarChangeMoveSelector">
<title>pillarChangeMoveSelector</title>
<simpara>A <emphasis>pillar</emphasis> is a set of planning entities which have the same planning value(s) for their planning variable(s). The <literal>PillarChangeMove</literal> selects one entity pillar (or subset of those) and changes the value of one variable (which is the same for all entities) to another value.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/pillarChangeMove.png" align="center"/>
</imageobject>
<textobject><phrase>pillarChangeMove</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the example above, queen A and C have the same value (row 0) and are moved to row 2.
Also the yellow and blue process have the same value (computer Y) and are moved to computer X.</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;pillarChangeMoveSelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;pillarSwapMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;pillarSelector&gt;
        &lt;entitySelector&gt;
          &lt;entityClass&gt;...Lecture&lt;/entityClass&gt;
          ...
        &lt;/entitySelector&gt;
        &lt;subPillarEnabled&gt;true&lt;/subPillarEnabled&gt;
        &lt;minimumSubPillarSize&gt;1&lt;/minimumSubPillarSize&gt;
        &lt;maximumSubPillarSize&gt;1000&lt;/maximumSubPillarSize&gt;
      &lt;/pillarSelector&gt;
      &lt;valueSelector variableName="room"&gt;
        ...
      &lt;/valueSelector&gt;
    &lt;/pillarSwapMoveSelector&gt;</programlisting>
<simpara>A sub pillar is a subset of entities that share the same value(s) for their variable(s). For example if queen A, B, C and D are all located on row 0, they are a pillar and <literal>[A, D]</literal> is one of the many sub pillars.
If <literal>subPillarEnabled</literal> (defaults to <literal>true</literal>) is false, no sub pillars are selected.
If sub pillars are enabled, the pillar itself is also included and the properties <literal>minimumSubPillarSize</literal> (defaults to <literal>1</literal>) and <literal>maximumSubPillarSize</literal> (defaults to <literal>infinity</literal>) limit the size of the selected (sub) pillar.</simpara>
<note>
<simpara>The number of sub pillars of a pillar is exponential to the size of the pillar.
For example a pillar of size 32 has <literal>(2^32 - 1)</literal> subpillars.
Therefore a <literal>pillarSelector</literal> only supports <link linkend="justInTimeRandomSelection">JIT random selection</link> (which is the default).</simpara>
</note>
<simpara>The other properties are explained in <link linkend="changeMoveSelector">changeMoveSelector</link>.</simpara>
</section>
<section xml:id="pillarSwapMoveSelector">
<title>pillarSwapMoveSelector</title>
<simpara>A <emphasis>pillar</emphasis> is a set of planning entities which have the same planning value(s) for their planning variable(s). The <literal>PillarSwapMove</literal> selects two different entity pillars and swaps the values of all their variables for all their entities.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/pillarSwapMove.png" align="center"/>
</imageobject>
<textobject><phrase>pillarSwapMove</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;pillarSwapMoveSelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;pillarSwapMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;pillarSelector&gt;
        &lt;entitySelector&gt;
          &lt;entityClass&gt;...Lecture&lt;/entityClass&gt;
          ...
        &lt;/entitySelector&gt;
        &lt;subPillarEnabled&gt;true&lt;/subPillarEnabled&gt;
        &lt;minimumSubPillarSize&gt;1&lt;/minimumSubPillarSize&gt;
        &lt;maximumSubPillarSize&gt;1000&lt;/maximumSubPillarSize&gt;
      &lt;/pillarSelector&gt;
      &lt;secondaryPillarSelector&gt;
        &lt;entitySelector&gt;
          ...
        &lt;/entitySelector&gt;
        ...
      &lt;/secondaryPillarSelector&gt;
      &lt;variableNameInclude&gt;room&lt;/variableNameInclude&gt;
      &lt;variableNameInclude&gt;...&lt;/variableNameInclude&gt;
    &lt;/pillarSwapMoveSelector&gt;</programlisting>
<simpara>The <literal>secondaryPillarSelector</literal> is rarely needed: if it is not specified, entities from the same <literal>pillarSelector</literal> are swapped.</simpara>
<simpara>The other properties are explained in <link linkend="swapMoveSelector">swapMoveSelector</link> and <link linkend="pillarChangeMoveSelector">pillarChangeMoveSelector</link>.</simpara>
</section>
<section xml:id="tailChainSwapMoveSelector">
<title>tailChainSwapMoveSelector or 2-opt (chained variables only)</title>
<simpara>A <emphasis>tailChain</emphasis> is a set of planning entities with a chained planning variable which form a last part of a chain.
The <literal>tailChainSwapMove</literal> selects a tail chain and swaps it with the tail chain of another planning value (in a different or the same anchor chain). If the targeted planning value, doesn’t have a tail chain, it swaps with nothing (resulting in a change like move). If it occurs within the same anchor chain, a partial chain reverse occurs.
In academic papers, this is often called a 2-opt move.</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;tailChainSwapMoveSelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;subChainChangeMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;entitySelector&gt;
        &lt;entityClass&gt;...Customer&lt;/entityClass&gt;
        ...
      &lt;/entitySelector&gt;
      &lt;valueSelector variableName="previousStandstill"&gt;
        ...
        &lt;nearbySelection&gt;...&lt;/nearbySelection&gt;
      &lt;/valueSelector&gt;
    &lt;/subChainChangeMoveSelector&gt;</programlisting>
<simpara>The <literal>entitySelector</literal> selects the start of the tail chain that is being moved.
The valueSelector selects to where that tail chain is moved.
If it has a tail chain itself, that is moved to the location of the original tail chain.
It uses a <literal>valueSelector</literal> instead of a <literal>secondaryEntitySelector</literal> to be able to include all possible 2opt moves (such as moving to the end of a tail) and to work correctly with <link linkend="nearbySelection">nearby selection</link> (because of asymmetric distances and also swapped entity distance gives an incorrect selection probability).</simpara>
<note>
<simpara>Although <literal>subChainChangeMoveSelector</literal> and <literal>subChainSwapMoveSelector</literal> include almost every possible <literal>tailChainSwapMove</literal>, experiments have shown that focusing on <literal>tailChainSwapMove</literal>s increases efficiency.</simpara>
</note>
</section>
<section xml:id="subChainChangeMoveSelector">
<title>subChainChangeMoveSelector (chained variables only)</title>
<simpara>A <emphasis>subChain</emphasis> is a set of planning entities with a chained planning variable which form part of a chain.
The <literal>subChainChangeMoveSelector</literal> selects a subChain and moves it to another place (in a different or the same anchor chain).</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;subChainChangeMoveSelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;subChainChangeMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;entityClass&gt;...Customer&lt;/entityClass&gt;
      &lt;subChainSelector&gt;
        &lt;valueSelector variableName="previousStandstill"&gt;
          ...
        &lt;/valueSelector&gt;
        &lt;minimumSubChainSize&gt;2&lt;/minimumSubChainSize&gt;
        &lt;maximumSubChainSize&gt;40&lt;/maximumSubChainSize&gt;
      &lt;/subChainSelector&gt;
      &lt;valueSelector variableName="previousStandstill"&gt;
        ...
      &lt;/valueSelector&gt;
      &lt;selectReversingMoveToo&gt;true&lt;/selectReversingMoveToo&gt;
    &lt;/subChainChangeMoveSelector&gt;</programlisting>
<simpara>The <literal>subChainSelector</literal> selects a number of entities, no less than <literal>minimumSubChainSize</literal> (defaults to <literal>1</literal>) and no more than <literal>maximumSubChainSize</literal> (defaults to <literal>infinity</literal>).</simpara>
<note>
<simpara>If <literal>minimumSubChainSize</literal> is <literal>1</literal> (which is the default), this selector might select the same move as a <literal>ChangeMoveSelector</literal>, at a far lower selection probability (because each move <emphasis>type</emphasis> has the same selection chance by default (not every move instance) and there are far more <literal>SubChainChangeMove</literal> instances than <literal>ChangeMove</literal> instances). However, don’t just remove the <literal>ChangeMoveSelector</literal>, because experiments show that it’s good to focus on <literal>ChangeMove</literal>s.</simpara>
<simpara>Furthermore, in a <literal>SubChainSwapMoveSelector</literal>, setting <literal>minimumSubChainSize</literal> prevents swapping a subchain of size <literal>1</literal> with a subchain of at least size <literal>2</literal>.</simpara>
</note>
<simpara>The <literal>selectReversingMoveToo</literal> property (defaults to true) enables selecting the reverse of every subchain too.</simpara>
</section>
<section xml:id="subChainSwapMoveSelector">
<title>subChainSwapMoveSelector (chained variables only)</title>
<simpara>The <literal>subChainSwapMoveSelector</literal> selects two different subChains and moves them to another place in a different or the same anchor chain.</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;subChainSwapMoveSelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;subChainSwapMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;entityClass&gt;...Customer&lt;/entityClass&gt;
      &lt;subChainSelector&gt;
        &lt;valueSelector variableName="previousStandstill"&gt;
          ...
        &lt;/valueSelector&gt;
        &lt;minimumSubChainSize&gt;2&lt;/minimumSubChainSize&gt;
        &lt;maximumSubChainSize&gt;40&lt;/maximumSubChainSize&gt;
      &lt;/subChainSelector&gt;
      &lt;secondarySubChainSelector&gt;
        &lt;valueSelector variableName="previousStandstill"&gt;
          ...
        &lt;/valueSelector&gt;
        &lt;minimumSubChainSize&gt;2&lt;/minimumSubChainSize&gt;
        &lt;maximumSubChainSize&gt;40&lt;/maximumSubChainSize&gt;
      &lt;/secondarySubChainSelector&gt;
      &lt;selectReversingMoveToo&gt;true&lt;/selectReversingMoveToo&gt;
    &lt;/subChainSwapMoveSelector&gt;</programlisting>
<simpara>The <literal>secondarySubChainSelector</literal> is rarely needed: if it is not specified, entities from the same <literal>subChainSelector</literal> are swapped.</simpara>
<simpara>The other properties are explained in <link linkend="subChainChangeMoveSelector">subChainChangeMoveSelector</link>.</simpara>
</section>
</section>
<section xml:id="combiningMultipleMoveSelectors">
<title>Combining Multiple <literal>MoveSelector</literal>s</title>
<section xml:id="unionMoveSelector">
<title>unionMoveSelector</title>
<simpara>A <literal>unionMoveSelector</literal> selects a <literal>Move</literal> by selecting one of its <literal>MoveSelector</literal> children to supply the next <literal>Move</literal>.</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;...MoveSelector/&gt;
      &lt;...MoveSelector/&gt;
      &lt;...MoveSelector/&gt;
      ...
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;selectorProbabilityWeightFactoryClass&gt;...ProbabilityWeightFactory&lt;/selectorProbabilityWeightFactoryClass&gt;
      &lt;changeMoveSelector&gt;
        &lt;fixedProbabilityWeight&gt;...&lt;/fixedProbabilityWeight&gt;
        ...
      &lt;/changeMoveSelector&gt;
      &lt;swapMoveSelector&gt;
        &lt;fixedProbabilityWeight&gt;...&lt;/fixedProbabilityWeight&gt;
        ...
      &lt;/swapMoveSelector&gt;
      &lt;...MoveSelector&gt;
        &lt;fixedProbabilityWeight&gt;...&lt;/fixedProbabilityWeight&gt;
        ...
      &lt;/...MoveSelector&gt;
      ...
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>The <literal>selectorProbabilityWeightFactory</literal> determines in <literal>selectionOrder</literal> <literal>RANDOM</literal> how often a <literal>MoveSelector</literal> child is selected to supply the next Move.
By default, each <literal>MoveSelector</literal> child has the same chance of being selected.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/selectorProbabilityInUnion.png" align="center"/>
</imageobject>
<textobject><phrase>selectorProbabilityInUnion</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Change the <literal>fixedProbabilityWeight</literal> of such a child to select it more often.
For example, the <literal>unionMoveSelector</literal> can return a <literal>SwapMove</literal> twice as often as a <literal>ChangeMove</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;fixedProbabilityWeight&gt;1.0&lt;/fixedProbabilityWeight&gt;
        ...
      &lt;/changeMoveSelector&gt;
      &lt;swapMoveSelector&gt;
        &lt;fixedProbabilityWeight&gt;2.0&lt;/fixedProbabilityWeight&gt;
        ...
      &lt;/swapMoveSelector&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>The number of possible <literal>ChangeMove</literal>s is very different from the number of possible <literal>SwapMove</literal>s and furthermore it’s problem dependent.
To give each individual <literal>Move</literal> the same selection chance (as opposed to each <literal>MoveSelector</literal>), use the <literal>FairSelectorProbabilityWeightFactory</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;selectorProbabilityWeightFactoryClass&gt;org.optaplanner.core.impl.heuristic.selector.common.decorator.FairSelectorProbabilityWeightFactory&lt;/selectorProbabilityWeightFactoryClass&gt;
      &lt;changeMoveSelector/&gt;
      &lt;swapMoveSelector/&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
</section>
<section xml:id="cartesianProductMoveSelector">
<title>cartesianProductMoveSelector</title>
<simpara>A <literal>cartesianProductMoveSelector</literal> selects a new <literal>CompositeMove</literal>.
It builds that <literal>CompositeMove</literal> by selecting one <literal>Move</literal> per <literal>MoveSelector</literal> child and adding it to the <literal>CompositeMove</literal>.</simpara>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;cartesianProductMoveSelector&gt;
      &lt;...MoveSelector/&gt;
      &lt;...MoveSelector/&gt;
      &lt;...MoveSelector/&gt;
      ...
    &lt;/cartesianProductMoveSelector&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;cartesianProductMoveSelector&gt;
      ... &lt;!-- Normal selector properties --&gt;
      &lt;ignoreEmptyChildIterators&gt;true&lt;/ignoreEmptyChildIterators&gt;
      &lt;changeMoveSelector&gt;
        ...
      &lt;/changeMoveSelector&gt;
      &lt;swapMoveSelector&gt;
        ...
      &lt;/swapMoveSelector&gt;
      &lt;...MoveSelector&gt;
        ...
      &lt;/...MoveSelector&gt;
      ...
    &lt;/cartesianProductMoveSelector&gt;</programlisting>
<simpara>The <literal>ignoreEmptyChildIterators</literal> property (true by default) will ignore every empty <literal>childMoveSelector</literal> to avoid returning no moves.
For example: a cartesian product of <literal>changeMoveSelector</literal> A and B, for which B is empty (because all it’s entities are immovable) returns no move if <literal>ignoreEmptyChildIterators</literal> is <literal>false</literal> and the moves of A if <literal>ignoreEmptyChildIterators</literal> is <literal>true</literal>.</simpara>
<simpara>To enforce that two child selectors use the same entity or value efficiently, use <link linkend="mimicSelection">mimic selection</link>, not move filtering.</simpara>
</section>
</section>
<section xml:id="entitySelector">
<title>EntitySelector</title>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">      &lt;entitySelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">      &lt;entitySelector&gt;
        ... &lt;!-- Normal selector properties --&gt;
        &lt;entityClass&gt;org.optaplanner.examples.curriculumcourse.domain.Lecture&lt;/entityClass&gt;
      &lt;/entitySelector&gt;</programlisting>
<simpara>The <literal>entityClass</literal> property is only required if it cannot be deduced automatically because there are multiple entity classes.</simpara>
</section>
<section xml:id="valueSelector">
<title>ValueSelector</title>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">      &lt;valueSelector/&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">      &lt;valueSelector variableName="room"&gt;
        ... &lt;!-- Normal selector properties --&gt;
      &lt;/valueSelector&gt;</programlisting>
<simpara>The <literal>variableName</literal> property is only required if it cannot be deduced automatically because there are multiple variables (for the related entity class).</simpara>
<simpara>In exotic Construction Heuristic configurations, the <literal>entityClass</literal> from the <literal>EntitySelector</literal> sometimes needs to be downcasted, which can be done with the property <literal>downcastEntityClass</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">      &lt;valueSelector variableName="period"&gt;
        &lt;downcastEntityClass&gt;...LeadingExam&lt;/downcastEntityClass&gt;
      &lt;/valueSelector&gt;</programlisting>
<simpara>If a selected entity cannot be downcasted, the <literal>ValueSelector</literal> is empty for that entity.</simpara>
</section>
<section xml:id="generalSelectorFeatures">
<title>General <literal>Selector</literal> Features</title>
<section xml:id="cacheType">
<title><literal>CacheType</literal>: Create Moves Ahead of Time or Just In Time</title>
<simpara>A <literal>Selector</literal>'s <literal>cacheType</literal> determines when a selection (such as a <literal>Move</literal>, an entity, a value, …​) is created and how long it lives.</simpara>
<simpara>Almost every <literal>Selector</literal> supports setting a <literal>cacheType</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      ...
    &lt;/changeMoveSelector&gt;</programlisting>
<simpara>The following <literal>cacheType</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>JUST_IN_TIME</literal> (default): Not cached. Construct each selection (<literal>Move</literal>, …​) just before it’s used. This scales up well in memory footprint.</simpara>
</listitem>
<listitem>
<simpara><literal>STEP</literal>: Cached. Create each selection (<literal>Move</literal>, …​) at the beginning of a step and cache them in a list for the remainder of the step. This scales up badly in memory footprint.</simpara>
</listitem>
<listitem>
<simpara><literal>PHASE</literal>: Cached. Create each selection (<literal>Move</literal>, …​) at the beginning of a solver phase and cache them in a list for the remainder of the phase. Some selections cannot be phase cached because the list changes every step. This scales up badly in memory footprint, but has a slight performance gain.</simpara>
</listitem>
<listitem>
<simpara><literal>SOLVER</literal>: Cached. Create each selection (<literal>Move</literal>, …​) at the beginning of a <literal>Solver</literal> and cache them in a list for the remainder of the <literal>Solver</literal>. Some selections cannot be solver cached because the list changes every step. This scales up badly in memory footprint, but has a slight performance gain.</simpara>
</listitem>
</itemizedlist>
<simpara>A <literal>cacheType</literal> can be set on composite selectors too:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;changeMoveSelector/&gt;
      &lt;swapMoveSelector/&gt;
      ...
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>Nested selectors of a cached selector cannot be configured to be cached themselves, unless it’s a higher <literal>cacheType</literal>.
For example: a <literal>STEP</literal> cached <literal>unionMoveSelector</literal> can hold a <literal>PHASE</literal> cached <literal>changeMoveSelector</literal>, but not a <literal>STEP</literal> cached <literal>changeMoveSelector</literal>.</simpara>
</section>
<section xml:id="selectionOrder">
<title>SelectionOrder: Original, Sorted, Random, Shuffled or Probabilistic</title>
<simpara>A <literal>Selector</literal>'s <literal>selectionOrder</literal> determines the order in which the selections (such as <literal>Move</literal>s, entities, values, …​) are iterated.
An optimization algorithm will usually only iterate through a subset of its <literal>MoveSelector</literal>'s selections, starting from the start, so the <literal>selectionOrder</literal> is critical to decide which <literal>Move</literal>s are actually evaluated.</simpara>
<simpara>Almost every <literal>Selector</literal> supports setting a <literal>selectionOrder</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector&gt;
      ...
      &lt;selectionOrder&gt;RANDOM&lt;/selectionOrder&gt;
      ...
    &lt;/changeMoveSelector&gt;</programlisting>
<simpara>The following <literal>selectionOrder</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>ORIGINAL</literal>: Select the selections (<literal>Move</literal>s, entities, values, …​) in default order. Each selection will be selected only once.</simpara>
<itemizedlist>
<listitem>
<simpara>For example: A0, A1, A2, A3, …​, B0, B1, B2, B3, …​, C0, C1, C2, C3, …​</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>SORTED: Select the selections (<literal>Move</literal>s, entities, values, …​) in sorted order. Each selection will be selected only once. Requires <literal>cacheType &gt;= STEP</literal>. Mostly used on an <literal>entitySelector</literal> or <literal>valueSelector</literal> for construction heuristics. See <link linkend="sortedSelection">sorted selection</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>For example: A0, B0, C0, …​, A2, B2, C2, …​, A1, B1, C1, …​</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>RANDOM (default): Select the selections (<literal>Move</literal>s, entities, values, …​) in non-shuffled random order. A selection might be selected multiple times. This scales up well in performance because it does not require caching.</simpara>
<itemizedlist>
<listitem>
<simpara>For example: C2, A3, B1, C2, A0, C0, …​</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>SHUFFLED: Select the selections (<literal>Move</literal>s, entities, values, …​) in shuffled random order. Each selection will be selected only once. Requires <literal>cacheType &gt;= STEP</literal>. This scales up badly in performance, not just because it requires caching, but also because a random number is generated for each element, even if it’s not selected (which is the grand majority when scaling up).</simpara>
<itemizedlist>
<listitem>
<simpara>For example: C2, A3, B1, A0, C0, …​</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>PROBABILISTIC: Select the selections (<literal>Move</literal>s, entities, values, …​) in random order, based on the selection probability of each element. A selection with a higher probability has a higher chance to be selected than elements with a lower probability. A selection might be selected multiple times. Requires <literal>cacheType &gt;= STEP</literal>. Mostly used on an <literal>entitySelector</literal> or <literal>valueSelector</literal>. See <link linkend="probabilisticSelection">probabilistic selection</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>For example: B1, B1, A1, B2, B1, C2, B1, B1, …​</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>A <literal>selectionOrder</literal> can be set on composite selectors too.</simpara>
<note>
<simpara>When a <literal>Selector</literal> is cached, all of its nested <literal>Selector</literal>s will naturally default to <literal>selectionOrder</literal> <literal>ORIGINAL</literal>.
Avoid overwriting the <literal>selectionOrder</literal> of those nested <literal>Selector</literal>s.</simpara>
</note>
</section>
<section xml:id="recommendedCombinationsOfCacheTypeAndSelectionOrder">
<title>Recommended Combinations of <literal>CacheType</literal> and <literal>SelectionOrder</literal></title>
<section xml:id="justInTimeRandomSelection">
<title>Just in Time Random Selection (default)</title>
<simpara>This combination is great for big use cases (10 000 entities or more), as it scales up well in memory footprint and performance.
Other combinations are often not even viable on such sizes.
It works for smaller use cases too, so it’s a good way to start out.
It’s the default, so this explicit configuration of <literal>cacheType</literal> and <literal>selectionOrder</literal> is actually obsolete:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;cacheType&gt;JUST_IN_TIME&lt;/cacheType&gt;
      &lt;selectionOrder&gt;RANDOM&lt;/selectionOrder&gt;

      &lt;changeMoveSelector/&gt;
      &lt;swapMoveSelector/&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>Here’s how it works.
When <literal>Iterator&lt;Move&gt;.next()</literal> is called, a child <literal>MoveSelector</literal> is randomly selected (1), which creates a random <literal>Move</literal> (2, 3, 4) and is then returned (5):</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/jitRandomSelection.png" align="center"/>
</imageobject>
<textobject><phrase>jitRandomSelection</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice that <emphasis role="strong">it never creates a list of <literal><emphasis role="strong">Move</emphasis></literal>s</emphasis> and it generates random numbers only for <literal>Move</literal>s that are actually selected.</simpara>
</section>
<section xml:id="cachedShuffledSelection">
<title>Cached Shuffled Selection</title>
<simpara>This combination often wins for small and medium use cases (5000 entities or less). Beyond that size, it scales up badly in memory footprint and performance.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SHUFFLED&lt;/selectionOrder&gt;

      &lt;changeMoveSelector/&gt;
      &lt;swapMoveSelector/&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>Here’s how it works: At the start of the phase (or step depending on the <literal>cacheType</literal>), all moves are created (1) and cached (2). When <literal>MoveSelector.iterator()</literal> is called, the moves are shuffled (3). When <literal>Iterator&lt;Move&gt;.next()</literal> is called, the next element in the shuffled list is returned (4):</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/cachedShuffledSelection.png" align="center"/>
</imageobject>
<textobject><phrase>cachedShuffledSelection</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice that <emphasis role="strong">each <literal>Move</literal> will only be selected once</emphasis>, even though they are selected in random order.</simpara>
<simpara>Use cacheType PHASE if none of the (possibly nested) Selectors require <literal>STEP</literal>.
Otherwise, do something like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;cacheType&gt;STEP&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SHUFFLED&lt;/selectionOrder&gt;

      &lt;changeMoveSelector&gt;
        &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;/changeMoveSelector&gt;
      &lt;swapMoveSelector/&gt;
        &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;/swapMoveSelector&gt;
      &lt;pillarSwapMoveSelector/&gt;&lt;!-- Does not support cacheType PHASE --&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
</section>
<section xml:id="cachedRandomSelection">
<title>Cached Random Selection</title>
<simpara>This combination is often a worthy competitor for medium use cases, especially with fast stepping optimization algorithms (such as Simulated Annealing). Unlike cached shuffled selection, it doesn’t waste time shuffling the moves list at the beginning of every step.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;RANDOM&lt;/selectionOrder&gt;

      &lt;changeMoveSelector/&gt;
      &lt;swapMoveSelector/&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
</section>
</section>
<section xml:id="filteredSelection">
<title>Filtered Selection</title>
<simpara>There can be certain moves that you don’t want to select, because:</simpara>
<itemizedlist>
<listitem>
<simpara>The move is pointless and would only waste CPU time. For example, swapping two lectures of the same course will result in the same score and the same schedule because all lectures of one course are interchangeable (same teacher, same students, same topic).</simpara>
</listitem>
<listitem>
<simpara>Doing the move would break <link linkend="buildInHardConstraint">a built-in hard constraint</link>, so the solution would be infeasible but the score function doesn’t check built-in hard constraints (for performance gain). For example, don’t change a gym lecture to a room which is not a gym room.</simpara>
<note>
<simpara>Any built-in hard constraint must probably be filtered on every move type of every solver phase.
For example if it’s filters the change move of Local Search, it must also filter the swap move that swaps the room of a gym lecture with another lecture for which the other lecture’s original room isn’t a gym room.
Furthermore, it must also filter the change moves of the Construction Heuristics (which requires an advanced configuration).</simpara>
</note>
</listitem>
</itemizedlist>
<simpara>If a move is unaccepted by the filter, it’s not executed and the score isn’t calculated.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/filteredSelection.png" align="center"/>
</imageobject>
<textobject><phrase>filteredSelection</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Filtering uses the interface <literal>SelectionFilter</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SelectionFilter&lt;Solution_, T&gt; {

    boolean accept(ScoreDirector&lt;Solution_&gt; scoreDirector, T selection);

}</programlisting>
<simpara>Implement the <literal>accept</literal> method to return <literal>false</literal> on a discarded <literal>selection</literal> (see below). Filtered selection can happen on any Selector in the selector tree, including any <literal>MoveSelector</literal>, <literal>EntitySelector</literal> or <literal>ValueSelector</literal>.
It works with any <literal>cacheType</literal> and <literal>selectionOrder</literal>.</simpara>
<note>
<simpara>Apply the filter on the lowest level possible.
In most cases, you’ll need to know both the entity and the value involved so you’ll have to apply it on the move selector.</simpara>
</note>
<section xml:id="filteredMoveSelection">
<title>Filtered Move Selection</title>
<simpara>Unaccepted moves will not be selected and will therefore never have their <literal>doMove()</literal> method called:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class DifferentCourseSwapMoveFilter implements SelectionFilter&lt;SwapMove&gt; {

    @Override
    public boolean accept(ScoreDirector scoreDirector, SwapMove move) {
        Lecture leftLecture = (Lecture) move.getLeftEntity();
        Lecture rightLecture = (Lecture) move.getRightEntity();
        return !leftLecture.getCourse().equals(rightLecture.getCourse());
    }

}</programlisting>
<simpara>Configure the <literal>filterClass</literal> on every targeted <literal>moveSelector</literal> (potentially both in the Local Search and the Construction Heuristics if it filters <literal>ChangeMove</literal>s):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;swapMoveSelector&gt;
      &lt;filterClass&gt;org.optaplanner.examples.curriculumcourse.solver.move.DifferentCourseSwapMoveFilter&lt;/filterClass&gt;
    &lt;/swapMoveSelector&gt;</programlisting>
<simpara>You can configure multiple <literal>filterClass</literal> elements on a single move selector.</simpara>
</section>
<section xml:id="filteredEntitySelection">
<title>Filtered Entity Selection</title>
<simpara>Unaccepted entities will not be selected and will therefore never be used to create a move.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class LongLectureSelectionFilter implements SelectionFilter&lt;Lecture&gt; {

    @Override
    public boolean accept(ScoreDirector&lt;CourseSchedule&gt; scoreDirector, Lecture lecture) {
        return lecture.isLong();
    }

}</programlisting>
<simpara>Configure the <literal>filterClass</literal> on every targeted <literal>entitySelector</literal> (potentially both in the Local Search and the Construction Heuristics):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector&gt;
      &lt;entitySelector&gt;
        &lt;filterClass&gt;org.optaplanner.examples.curriculumcourse.solver.move.LongLectureSelectionFilter&lt;/filterClass&gt;
      &lt;/entitySelector&gt;
    &lt;/changeMoveSelector&gt;</programlisting>
<simpara>If that filter should apply on all entities, configure it as a <link linkend="immovablePlanningEntities">global movableEntitySelectionFilter</link> instead.</simpara>
<simpara>You can configure multiple <literal>filterClass</literal> elements on a single entity selector.</simpara>
</section>
<section xml:id="filteredValueSelection">
<title>Filtered Value Selection</title>
<simpara>Unaccepted values will not be selected and will therefore never be used to create a move.</simpara>
<programlisting language="java" linenumbering="unnumbered">public class LongPeriodSelectionFilter implements SelectionFilter&lt;Period&gt; {

    @Override
    public boolean accept(ScoreDirector&lt;CourseSchedule&gt; scoreDirector, Period period) {
        return period();
    }

}</programlisting>
<simpara>Configure the <literal>filterClass</literal> on every targeted <literal>valueSelector</literal> (potentially both in the Local Search and the Construction Heuristics):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector&gt;
      &lt;valueSelector&gt;
        &lt;filterClass&gt;org.optaplanner.examples.curriculumcourse.solver.move.LongPeriodSelectionFilter&lt;/filterClass&gt;
      &lt;/valueSelector&gt;
    &lt;/changeMoveSelector&gt;</programlisting>
<simpara>You can configure multiple <literal>filterClass</literal> elements on a single value selector.</simpara>
</section>
</section>
<section xml:id="sortedSelection">
<title>Sorted Selection</title>
<simpara>Sorted selection can happen on any Selector in the selector tree, including any <literal>MoveSelector</literal>, <literal>EntitySelector</literal> or <literal>ValueSelector</literal>.
It does not work with <literal>cacheType</literal> <literal>JUST_IN_TIME</literal> and it only works with <literal>selectionOrder</literal> <literal>SORTED</literal>.</simpara>
<simpara>It’s mostly used in construction heuristics.</simpara>
<note>
<simpara>If the chosen construction heuristic implies sorting, for example <literal>FIRST_FIT_DECREASING</literal> implies that the <literal>EntitySelector</literal> is sorted, there is no need to explicitly configure a <literal>Selector</literal> with sorting.
If you do explicitly configure the <literal>Selector</literal>, it overwrites the default settings of that construction heuristic.</simpara>
</note>
<section xml:id="sortedSelectionBySorterManner">
<title>Sorted Selection by <literal>SorterManner</literal></title>
<simpara>Some <literal>Selector</literal> types implement a <literal>SorterManner</literal> out of the box:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>EntitySelector</literal> supports:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DECREASING_DIFFICULTY</literal>: Sorts the planning entities according to decreasing <link linkend="planningEntityDifficulty">planning entity difficulty</link>. Requires that planning entity difficulty is annotated on the domain model.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;entitySelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
      &lt;sorterManner&gt;DECREASING_DIFFICULTY&lt;/sorterManner&gt;
    &lt;/entitySelector&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>ValueSelector</literal> supports:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>INCREASING_STRENGTH</literal>: Sorts the planning values according to increasing <link linkend="planningValueStrength">planning value strength</link>. Requires that planning value strength is annotated on the domain model.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;valueSelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
      &lt;sorterManner&gt;INCREASING_STRENGTH&lt;/sorterManner&gt;
    &lt;/valueSelector&gt;</programlisting>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</section>
<section xml:id="sortedSelectionByComparator">
<title>Sorted Selection by <literal>Comparator</literal></title>
<simpara>An easy way to sort a <literal>Selector</literal> is with a plain old <literal>Comparator</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CloudProcessDifficultyComparator implements Comparator&lt;CloudProcess&gt; {

    public int compare(CloudProcess a, CloudProcess b) {
        return new CompareToBuilder()
                .append(a.getRequiredMultiplicand(), b.getRequiredMultiplicand())
                .append(a.getId(), b.getId())
                .toComparison();
    }

}</programlisting>
<simpara>You 'll also need to configure it (unless it’s annotated on the domain model and automatically applied by the optimization algorithm):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;entitySelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
      &lt;sorterComparatorClass&gt;...CloudProcessDifficultyComparator&lt;/sorterComparatorClass&gt;
      &lt;sorterOrder&gt;DESCENDING&lt;/sorterOrder&gt;
    &lt;/entitySelector&gt;</programlisting>
</section>
<section xml:id="sortedSelectionBySelectionSorterWeightFactory">
<title>Sorted Selection by <literal>SelectionSorterWeightFactory</literal></title>
<simpara>If you need the entire <literal>Solution</literal> to sort a <literal>Selector</literal>, use a <literal>SelectionSorterWeightFactory</literal> instead:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SelectionSorterWeightFactory&lt;Solution_, T&gt; {

    Comparable createSorterWeight(Solution_ solution, T selection);

}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public class QueenDifficultyWeightFactory implements SelectionSorterWeightFactory&lt;NQueens, Queen&gt; {

    public QueenDifficultyWeight createSorterWeight(NQueens nQueens, Queen queen) {
        int distanceFromMiddle = calculateDistanceFromMiddle(nQueens.getN(), queen.getColumnIndex());
        return new QueenDifficultyWeight(queen, distanceFromMiddle);
    }

    ...

    public static class QueenDifficultyWeight implements Comparable&lt;QueenDifficultyWeight&gt; {

        private final Queen queen;
        private final int distanceFromMiddle;

        public QueenDifficultyWeight(Queen queen, int distanceFromMiddle) {
            this.queen = queen;
            this.distanceFromMiddle = distanceFromMiddle;
        }

        public int compareTo(QueenDifficultyWeight other) {
            return new CompareToBuilder()
                    // The more difficult queens have a lower distance to the middle
                    .append(other.distanceFromMiddle, distanceFromMiddle) // Decreasing
                    // Tie breaker
                    .append(queen.getColumnIndex(), other.queen.getColumnIndex())
                    .toComparison();
        }

    }

}</programlisting>
<simpara>You 'll also need to configure it (unless it’s annotated on the domain model and automatically applied by the optimization algorithm):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;entitySelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
      &lt;sorterWeightFactoryClass&gt;...QueenDifficultyWeightFactory&lt;/sorterWeightFactoryClass&gt;
      &lt;sorterOrder&gt;DESCENDING&lt;/sorterOrder&gt;
    &lt;/entitySelector&gt;</programlisting>
</section>
<section xml:id="sortedSelectionBySelectionSorter">
<title>Sorted Selection by <literal>SelectionSorter</literal></title>
<simpara>Alternatively, you can also use the interface <literal>SelectionSorter</literal> directly:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SelectionSorter&lt;Solution_, T&gt; {

    void sort(ScoreDirector&lt;Solution_&gt; scoreDirector, List&lt;T&gt; selectionList);

}</programlisting>
<programlisting language="xml" linenumbering="unnumbered">    &lt;entitySelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
      &lt;sorterClass&gt;...MyEntitySorter&lt;/sorterClass&gt;
    &lt;/entitySelector&gt;</programlisting>
</section>
</section>
<section xml:id="probabilisticSelection">
<title>Probabilistic Selection</title>
<simpara>Probabilistic selection can happen on any Selector in the selector tree, including any <literal>MoveSelector</literal>, <literal>EntitySelector</literal> or <literal>ValueSelector</literal>.
It does not work with <literal>cacheType</literal> <literal>JUST_IN_TIME</literal> and it only works with <literal>selectionOrder</literal> <literal>PROBABILISTIC</literal>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/probabilisticSelection.png" align="center"/>
</imageobject>
<textobject><phrase>probabilisticSelection</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Each selection has a <literal>probabilityWeight</literal>, which determines the chance that selection will be selected:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SelectionProbabilityWeightFactory&lt;Solution_, T&gt; {

    double createProbabilityWeight(ScoreDirector&lt;Solution_&gt; scoreDirector, T selection);

}</programlisting>
<programlisting language="xml" linenumbering="unnumbered">    &lt;entitySelector&gt;
      &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
      &lt;selectionOrder&gt;PROBABILISTIC&lt;/selectionOrder&gt;
      &lt;probabilityWeightFactoryClass&gt;...MyEntityProbabilityWeightFactoryClass&lt;/probabilityWeightFactoryClass&gt;
    &lt;/entitySelector&gt;</programlisting>
<simpara>For example, if there are three entities: process A (probabilityWeight 2.0), process B (probabilityWeight 0.5) and process C (probabilityWeight 0.5), then process A will be selected four times more than B and C.</simpara>
</section>
<section xml:id="limitedSelection">
<title>Limited Selection</title>
<simpara>Selecting all possible moves sometimes does not scale well enough, especially for construction heuristics (which don’t support <link linkend="acceptedCountLimit">acceptedCountLimit</link>).</simpara>
<simpara>To limit the number of selected selection per step, apply a <literal>selectedCountLimit</literal> on the selector:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;changeMoveSelector&gt;
      &lt;selectedCountLimit&gt;100&lt;/selectedCountLimit&gt;
    &lt;/changeMoveSelector&gt;</programlisting>
<note>
<simpara>To scale Local Search, setting <link linkend="acceptedCountLimit">acceptedCountLimit</link> is usually better than using <literal>selectedCountLimit</literal>.</simpara>
</note>
</section>
<section xml:id="mimicSelection">
<title>Mimic Selection (Record/Replay)</title>
<simpara>During mimic selection, one normal selector records its selection and one or multiple other special selectors replay that selection.
The recording selector acts as a normal selector and supports all other configuration properties.
A replaying selector mimics the recording selection and support no other configuration properties.</simpara>
<simpara>The recording selector needs an <literal>id</literal>.
A replaying selector must reference a recorder’s id with a <literal>mimicSelectorRef</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">      &lt;cartesianProductMoveSelector&gt;
        &lt;changeMoveSelector&gt;
          &lt;entitySelector id="entitySelector"/&gt;
          &lt;valueSelector variableName="period"/&gt;
        &lt;/changeMoveSelector&gt;
        &lt;changeMoveSelector&gt;
          &lt;entitySelector mimicSelectorRef="entitySelector"/&gt;
          &lt;valueSelector variableName="room"/&gt;
        &lt;/changeMoveSelector&gt;
      &lt;/cartesianProductMoveSelector&gt;</programlisting>
<simpara>Mimic selection is useful to create <link linkend="cartesianProductMoveSelector">a composite move</link> from two moves that affect the same entity.</simpara>
</section>
<section xml:id="nearbySelection">
<title>Nearby Selection</title>
<simpara>In some use cases (such as TSP and VRP, but also in non-chained variable cases), changing entities to nearby values or swapping nearby entities can <emphasis role="strong">heavily increase scalability</emphasis> and improve solution quality.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/nearbySelectionMotivation.png" align="center"/>
</imageobject>
<textobject><phrase>nearbySelectionMotivation</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Nearby selection increases the probability of selecting an entity or value which is nearby to the first entity being moved in that move.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/MoveAndNeighborhoodSelection/nearbySelectionRandomDistribution.png" align="center"/>
</imageobject>
<textobject><phrase>nearbySelectionRandomDistribution</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The distance between two entities or values is domain specific.
Therefore, implement the <literal>NearbyDistanceMeter</literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface NearbyDistanceMeter&lt;O, D&gt; {

    double getNearbyDistance(O origin, D destination);

}</programlisting>
<simpara>It returns a <literal>double</literal> which represents the distance:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CustomerNearbyDistanceMeter implements NearbyDistanceMeter&lt;Customer, Standstill&gt; {

    public double getNearbyDistance(Customer origin, Standstill destination) {
        return origin.getDistanceTo(destination);
    }

}</programlisting>
<simpara>To configure nearby selection, add a <literal>nearbySelection</literal> element in the <literal>entitySelector</literal> or <literal>valueSelector</literal>
and use <link linkend="mimicSelection">mimic selection</link> to specify which entity should be near by the selection.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;unionMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector id="entitySelector1"/&gt;
        &lt;valueSelector&gt;
          &lt;nearbySelection&gt;
            &lt;originEntitySelector mimicSelectorRef="entitySelector1"/&gt;
            &lt;nearbyDistanceMeterClass&gt;...CustomerNearbyDistanceMeter&lt;/nearbyDistanceMeterClass&gt;
            &lt;parabolicDistributionSizeMaximum&gt;40&lt;/parabolicDistributionSizeMaximum&gt;
          &lt;/nearbySelection&gt;
        &lt;/valueSelector&gt;
      &lt;/changeMoveSelector&gt;
      &lt;swapMoveSelector&gt;
        &lt;entitySelector id="entitySelector2"/&gt;
        &lt;secondaryEntitySelector&gt;
          &lt;nearbySelection&gt;
            &lt;originEntitySelector mimicSelectorRef="entitySelector2"/&gt;
            &lt;nearbyDistanceMeterClass&gt;...CustomerNearbyDistanceMeter&lt;/nearbyDistanceMeterClass&gt;
            &lt;parabolicDistributionSizeMaximum&gt;40&lt;/parabolicDistributionSizeMaximum&gt;
          &lt;/nearbySelection&gt;
        &lt;/secondaryEntitySelector&gt;
      &lt;/swapMoveSelector&gt;
      &lt;tailChainSwapMoveSelector&gt;
        &lt;entitySelector id="entitySelector3"/&gt;
        &lt;valueSelector&gt;
          &lt;nearbySelection&gt;
            &lt;originEntitySelector mimicSelectorRef="entitySelector3"/&gt;
            &lt;nearbyDistanceMeterClass&gt;...CustomerNearbyDistanceMeter&lt;/nearbyDistanceMeterClass&gt;
            &lt;parabolicDistributionSizeMaximum&gt;40&lt;/parabolicDistributionSizeMaximum&gt;
          &lt;/nearbySelection&gt;
        &lt;/valueSelector&gt;
      &lt;/tailChainSwapMoveSelector&gt;
    &lt;/unionMoveSelector&gt;</programlisting>
<simpara>A <literal>distributionSizeMaximum</literal> parameter should not be 1 because if the nearest is already the planning value of the current entity, then the only move that is selectable is not doable.</simpara>
<simpara>To allow every element to be selected, regardless of the number of entities, only set the distribution type (so without a <literal>distributionSizeMaximum</literal> parameter):</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;nearbySelection&gt;
    &lt;nearbySelectionDistributionType&gt;PARABOLIC_DISTRIBUTION&lt;/nearbySelectionDistributionType&gt;
  &lt;/nearbySelection&gt;</programlisting>
<simpara>The following <literal>NearbySelectionDistributionType</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>BLOCK_DISTRIBUTION</literal>: Only the n nearest are selected, with an equal probability. For example, select the 20 nearest:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;nearbySelection&gt;
    &lt;blockDistributionSizeMaximum&gt;20&lt;/blockDistributionSizeMaximum&gt;
  &lt;/nearbySelection&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>LINEAR_DISTRIBUTION</literal>: Nearest elements are selected with a higher probability. The probability decreases linearly.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;nearbySelection&gt;
    &lt;linearDistributionSizeMaximum&gt;40&lt;/linearDistributionSizeMaximum&gt;
  &lt;/nearbySelection&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>PARABOLIC_DISTRIBUTION</literal> (recommended): Nearest elements are selected with a higher probability.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;nearbySelection&gt;
    &lt;parabolicDistributionSizeMaximum&gt;80&lt;/parabolicDistributionSizeMaximum&gt;
  &lt;/nearbySelection&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>BETA_DISTRIBUTION</literal>: Selection according to a beta distribution. Slows down the solver significantly.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;nearbySelection&gt;
    &lt;betaDistributionAlpha&gt;1&lt;/betaDistributionAlpha&gt;
    &lt;betaDistributionBeta&gt;5&lt;/betaDistributionBeta&gt;
  &lt;/nearbySelection&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>As always, use the <link linkend="benchmarker">Benchmarker</link> to tweak values if desired.</simpara>
</section>
</section>
<section xml:id="customMoves">
<title>Custom Moves</title>
<section xml:id="whichMoveTypesMightBeMissing">
<title>Which Move Types Might be Missing in my Implementation?</title>
<simpara>To determine which move types might be missing in your implementation, run a <link linkend="benchmarker">Benchmarker</link><emphasis>for a short amount of time</emphasis> and <link linkend="writeTheOutputSolutionOfBenchmarkRuns">configure it to write the best solutions to disk</link>.
Take a look at such a best solution: it will likely be a local optima.
Try to figure out if there’s a move that could get out of that local optima faster.</simpara>
<simpara>If you find one, implement that coarse-grained move, mix it with the existing moves and benchmark it against the previous configurations to see if you want to keep it.</simpara>
</section>
<section xml:id="customMovesIntroduction">
<title>Custom Moves Introduction</title>
<simpara>Instead of using the generic <literal>Move</literal>s (such as <literal>ChangeMove</literal>) you can also implement your own <literal>Move</literal>.
Generic and custom <literal>MoveSelector</literal>s can be <link linkend="combiningMultipleMoveSelectors">combined</link> as desired.</simpara>
<simpara>A custom <literal>Move</literal> can be tailored to work to the advantage of your constraints.
For example in examination scheduling, changing the period of an exam A
would also change the period of all the other exams that need to coincide with exam A.</simpara>
<simpara>A custom <literal>Move</literal> is also slightly faster than a generic <literal>Move</literal>.
However, it’s far more work to implement and much harder to avoid bugs.
After implementing a custom <literal>Move</literal>, turn on <literal>environmentMode</literal> <literal>FULL_ASSERT</literal> to check for score corruptions.</simpara>
</section>
<section xml:id="theInterfaceMove">
<title>The Interface <literal>Move</literal></title>
<simpara>All moves implements the <literal>Move</literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Move&lt;Solution_&gt; {

    boolean isMoveDoable(ScoreDirector&lt;Solution_&gt; scoreDirector);
    Move&lt;Solution_&gt; doMove(ScoreDirector&lt;Solution_&gt; scoreDirector);

    ...
}</programlisting>
<simpara>To implement a custom move, it’s recommend to extend <literal>AbstractMove</literal> instead implementing <literal>Move</literal> directly.
Planner calls <literal>AbstractMove.doMove(ScoreDirector)</literal>, which calls <literal>doMoveOnGenuineVariables(ScoreDirector)</literal>.
For example in cloud balancing, this move changes one process to another computer:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CloudComputerChangeMove extends AbstractMove&lt;CloudBalance&gt; {

    private CloudProcess cloudProcess;
    private CloudComputer toCloudComputer;

    public CloudComputerChangeMove(CloudProcess cloudProcess, CloudComputer toCloudComputer) {
        this.cloudProcess = cloudProcess;
        this.toCloudComputer = toCloudComputer;
    }

    @Override
    protected void doMoveOnGenuineVariables(ScoreDirector&lt;CloudBalance&gt; scoreDirector) {
        scoreDirector.beforeVariableChanged(cloudProcess, "computer");
        cloudProcess.setComputer(toCloudComputer);
        scoreDirector.afterVariableChanged(cloudProcess, "computer");
    }

    // ...

}</programlisting>
<simpara>The implementation must notify the <literal>ScoreDirector</literal> of any changes it makes to planning entity’s variables:
Call the <literal>scoreDirector.beforeVariableChanged(Object, String)</literal> and <literal>scoreDirector.afterVariableChanged(Object, String)</literal>
methods directly before and after modifying an entity’s planning variable.</simpara>
<simpara>The example move above is a fine-grained move because changes only one planning variable.
On the other hand, a coarse-grained move changes multiple entities or multiple planning variables
in a single move, usually to avoid breaking hard constraints by making multiple related changes at once.
For example, a swap move is really just two change moves, but it keeps those two changes together.</simpara>
<warning>
<simpara>A <literal>Move</literal> can only change/add/remove planning entities,
it must not change any of the problem facts as that will cause score corruption.
Use <link linkend="realTimePlanning">real-time planning</link> to change problem facts while solving.</simpara>
</warning>
<simpara>Planner automatically filters out <emphasis>non doable moves</emphasis> by calling the <literal>isMoveDoable(ScoreDirector)</literal> method on each selected move.
A <emphasis>non doable move</emphasis> is:</simpara>
<itemizedlist>
<listitem>
<simpara>A move that changes nothing on the current solution.
For example, moving process <literal>P1</literal> on computer <literal>X</literal> to computer <literal>X</literal> is not doable, because it is already there.</simpara>
</listitem>
<listitem>
<simpara>A move that is impossible to do on the current solution.
For example, moving process <literal>P1</literal> to computer <literal>Q</literal>  (when <literal>Q</literal> isn’t in the list of computers) is not doable
because it would assign a planning value that’s not inside the planning variable’s value range.</simpara>
</listitem>
</itemizedlist>
<simpara>In the cloud balancing example, a move which assigns a process to the computer it’s already assigned to is not doable:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @Override
    public boolean isMoveDoable(ScoreDirector&lt;CloudBalance&gt; scoreDirector) {
        return !Objects.equals(cloudProcess.getComputer(), toCloudComputer);
    }</programlisting>
<simpara>We don’t need to check if <literal>toCloudComputer</literal> is in the value range,
because we only generates moves for which that is the case.
A move that is currently not doable can become doable when the working <literal>Solution</literal> changes in a later step,
otherwise we probably shouldn’t have created it in the first place.</simpara>
<simpara>Each move has an <emphasis>undo move</emphasis>: a move (normally of the same type) which does the exact opposite.
In the cloud balancing example the undo move of <literal>P1 {X → Y}</literal> is the move <literal>P1 {Y → X}</literal>.
The undo move of a move is created when the <literal>Move</literal> is being done on the current solution,
before the genuine variables change:</simpara>
<programlisting language="java" linenumbering="unnumbered">    @Override
    public CloudComputerChangeMove createUndoMove(ScoreDirector&lt;CloudBalance&gt; scoreDirector) {
        return new CloudComputerChangeMove(cloudProcess, cloudProcess.getComputer());
    }</programlisting>
<simpara>Notice that if <literal>P1</literal> would have already been moved to <literal>Y</literal>, the undo move would create the move <literal>P1 {Y → Y}</literal>,
instead of the move <literal>P1 {Y → X}</literal>.</simpara>
<simpara>A solver phase might do and undo the same <literal>Move</literal> more than once.
In fact, many solver phases will iteratively do and undo a number of moves to evaluate them,
before selecting one of those and doing that move again (without undoing it the last time).</simpara>
<simpara>A <literal>Move</literal> must also implement the <literal>getPlanningEntities()</literal> and <literal>getPlanningValues()</literal> methods.
Those are used by <link linkend="tabuSearch">entity tabu and value tabu</link> respectively.
They are called after the <literal>Move</literal> has already been done.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @Override
    public Collection&lt;? extends Object&gt; getPlanningEntities() {
        return Collections.singletonList(cloudProcess);
    }

    @Override
    public Collection&lt;? extends Object&gt; getPlanningValues() {
        return Collections.singletonList(toCloudComputer);
    }</programlisting>
<simpara>If the <literal>Move</literal> changes multiple planning entities, such as in a swap move,
return all of them in <literal>getPlanningEntities()</literal>
and return all their values (to which they are changing) in <literal>getPlanningValues()</literal>.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @Override
    public Collection&lt;? extends Object&gt; getPlanningEntities() {
        return Arrays.asList(leftCloudProcess, rightCloudProcess);
    }

    @Override
    public Collection&lt;? extends Object&gt; getPlanningValues() {
        return Arrays.asList(leftCloudProcess.getComputer(), rightCloudProcess.getComputer());
    }</programlisting>
<simpara>A <literal>Move</literal> must implement the <literal>equals()</literal> and <literal>hashCode()</literal> methods for <link linkend="tabuSearch">move tabu</link>.
Two moves which make the same change on a solution, should be equal ideally.</simpara>
<programlisting language="java" linenumbering="unnumbered">    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        } else if (o instanceof CloudComputerChangeMove) {
            CloudComputerChangeMove other = (CloudComputerChangeMove) o;
            return new EqualsBuilder()
                    .append(cloudProcess, other.cloudProcess)
                    .append(toCloudComputer, other.toCloudComputer)
                    .isEquals();
        } else {
            return false;
        }
    }

    @Override
    public int hashCode() {
        return new HashCodeBuilder()
                .append(cloudProcess)
                .append(toCloudComputer)
                .toHashCode();
    }</programlisting>
<simpara>Notice that it checks if the other move is an instance of the same move type.
This <literal>instanceof</literal> check is important because a move will be compared to a move with another move type
if you have multiple move selectors.</simpara>
<simpara>Implement the <literal>toString()</literal> method to keep Planner’s logs readable:</simpara>
<programlisting language="java" linenumbering="unnumbered">    public String toString() {
        return cloudProcess + " {" + cloudProcess.getComputer() + " -&gt; " + toCloudComputer + "}";
    }</programlisting>
<simpara>Now, let’s generate instances of this custom <literal>Move</literal> class.</simpara>
</section>
<section xml:id="moveListFactory">
<title><literal>MoveListFactory</literal>: the Easy Way to Generate Custom Moves</title>
<simpara>The easiest way to generate custom moves is by implementing the interface <literal>MoveListFactory</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface MoveListFactory&lt;Solution_&gt; {

    List&lt;Move&gt; createMoveList(Solution_ solution);

}</programlisting>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CloudComputerChangeMoveFactory implements MoveListFactory&lt;CloudBalance&gt; {

    @Override
    public List&lt;CloudComputerChangeMove&gt; createMoveList(CloudBalance cloudBalance) {
        List&lt;CloudComputerChangeMove&gt; moveList = new ArrayList&lt;&gt;();
        List&lt;CloudComputer&gt; cloudComputerList = cloudBalance.getComputerList();
        for (CloudProcess cloudProcess : cloudBalance.getProcessList()) {
            for (CloudComputer cloudComputer : cloudComputerList) {
                moveList.add(new CloudComputerChangeMove(cloudProcess, cloudComputer));
            }
        }
        return moveList;
    }

}</programlisting>
<simpara>Simple configuration (which can be nested in a <literal>unionMoveSelector</literal> just like any other <literal>MoveSelector</literal>):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;moveListFactory&gt;
      &lt;moveListFactoryClass&gt;org.optaplanner.examples.cloudbalancing.optional.move.CloudComputerChangeMoveFactory&lt;/moveListFactoryClass&gt;
    &lt;/moveListFactory&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;moveListFactory&gt;
      ... &lt;!-- Normal moveSelector properties --&gt;
      &lt;moveListFactoryClass&gt;org.optaplanner.examples.cloudbalancing.optional.move.CloudComputerChangeMoveFactory&lt;/moveListFactoryClass&gt;
    &lt;/moveListFactory&gt;</programlisting>
<simpara>Because the <literal>MoveListFactory</literal> generates all moves at once in a <literal>List&lt;Move&gt;</literal>,
it does not support <literal>cacheType</literal> <literal>JUST_IN_TIME</literal>.
Therefore, <literal>moveListFactory</literal> uses <literal>cacheType</literal> <literal>STEP</literal> by default and it scales badly.</simpara>
</section>
<section xml:id="moveIteratorFactory">
<title><literal>MoveIteratorFactory</literal>: Generate Custom Moves Just in Time</title>
<simpara>Use this advanced form to generate custom moves Just In Time
by implementing the <literal>MoveIteratorFactory</literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface MoveIteratorFactory&lt;Solution_&gt; {

    long getSize(ScoreDirector&lt;Solution_&gt; scoreDirector);

    Iterator&lt;Move&gt; createOriginalMoveIterator(ScoreDirector&lt;Solution_&gt; scoreDirector);

    Iterator&lt;Move&gt; createRandomMoveIterator(ScoreDirector&lt;Solution_&gt; scoreDirector, Random workingRandom);

}</programlisting>
<simpara>The <literal>getSize()</literal> method must return an estimation of the size.
It doesn’t need to be correct, but it’s better too big than too small.
The <literal>createOriginalMoveIterator</literal> method is called if the <literal>selectionOrder</literal> is <literal>ORIGINAL</literal> or if it is cached.
The <literal>createRandomMoveIterator</literal> method is called for <literal>selectionOrder</literal> <literal>RANDOM</literal> combined with cacheType <literal>JUST_IN_TIME</literal>.</simpara>
<important>
<simpara>Don’t create a collection (array, list, set or map) of <literal>Move</literal>s when creating the <literal>Iterator&lt;Move&gt;</literal>:
the whole purpose of <literal>MoveIteratorFactory</literal> over <literal>MoveListFactory</literal> is to create a <literal>Move</literal> just in time
in a custom <literal>Iterator.next()</literal>.</simpara>
</important>
<simpara>Simple configuration (which can be nested in a <literal>unionMoveSelector</literal> just like any other <literal>MoveSelector</literal>):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;moveIteratorFactory&gt;
      &lt;moveIteratorFactoryClass&gt;...&lt;/moveIteratorFactoryClass&gt;
    &lt;/moveIteratorFactory&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;moveIteratorFactory&gt;
      ... &lt;!-- Normal moveSelector properties --&gt;
      &lt;moveIteratorFactoryClass&gt;...&lt;/moveIteratorFactoryClass&gt;
    &lt;/moveIteratorFactory&gt;</programlisting>
</section>
</section>
</chapter>
<chapter xml:id="exhaustiveSearch">
<title>Exhaustive Search</title>
<section xml:id="exhaustiveSearchOverview">
<title>Overview</title>
<simpara>Exhaustive Search will always find the global optimum and recognize it too.
That being said, it doesn’t scale (not even beyond toy data sets) and is therefore mostly useless.</simpara>
</section>
<section xml:id="bruteForce">
<title>Brute Force</title>
<section xml:id="bruteForceAlgorithm">
<title>Algorithm Description</title>
<simpara>The Brute Force algorithm creates and evaluates every possible solution.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ExhaustiveSearch/bruteForceNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>bruteForceNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice that it creates a search tree that explodes exponentially as the problem size increases, so it hits a scalability wall.</simpara>
<important>
<simpara><emphasis role="strong">Brute Force is mostly unusable for a real-world problem due to time limitations</emphasis>,
as shown in <link linkend="scalabilityOfExhaustiveSearch">scalability of Exhaustive  Search</link>.</simpara>
</important>
</section>
<section xml:id="bruteForceConfiguration">
<title>Configuration</title>
<simpara>Simplest configuration of Brute Force:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRUTE_FORCE&lt;/exhaustiveSearchType&gt;
  &lt;/exhaustiveSearch&gt;
&lt;/solver&gt;</programlisting>
</section>
</section>
<section xml:id="branchAndBound">
<title>Branch And Bound</title>
<section xml:id="branchAndBoundAlgorithm">
<title>Algorithm Description</title>
<simpara>Branch And Bound also explores nodes in an exponential search tree, but it investigates more promising nodes first and prunes away worthless nodes.</simpara>
<simpara>For each node, Branch And Bound calculates the optimistic bound: the best possible score to which that node can lead to.
If the optimistic bound of a node is lower or equal to the global pessimistic bound, then it prunes away that node (including the entire branch of all its subnodes).</simpara>
<note>
<simpara>Academic papers use the term lower bound instead of optimistic bound (and the term upper bound instead of pessimistic bound), because they minimize the score.</simpara>
<simpara>Planner maximizes the score (because it supports combining negative and positive constraints). Therefore, for clarity, it uses different terms, as it would be confusing to use the term lower bound for a bound which is always higher.</simpara>
</note>
<simpara>For example: at index 14, it sets the global pessimistic bound to <literal>-2</literal>.
Because all solutions reachable from the node visited at index 11 will have a score lower or equal to <literal>-2</literal> (the node’s optimistic bound), they can be pruned away.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ExhaustiveSearch/depthFirstBranchAndBoundNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>depthFirstBranchAndBoundNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice that Branch And Bound (much like <link linkend="bruteForce">Brute Force</link>) creates a search tree that explodes exponentially as the problem size increases.
So it hits the same scalability wall, only a little bit later.</simpara>
<important>
<simpara><emphasis role="strong">Branch And Bound is mostly unusable for a real-world problem due to time limitations</emphasis>,
as shown in <link linkend="scalabilityOfExhaustiveSearch">scalability of Exhaustive Search</link>.</simpara>
</important>
</section>
<section xml:id="branchAndBoundConfiguration">
<title>Configuration</title>
<simpara>Simplest configuration of Branch And Bound:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  ...
  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
  &lt;/exhaustiveSearch&gt;
&lt;/solver&gt;</programlisting>
<important>
<simpara>For the pruning to work with the default <literal>ScoreBounder</literal>, the <link linkend="initializingScoreTrend">InitializingScoreTrend</link> should be set.
Especially an <link linkend="initializingScoreTrend">InitializingScoreTrend</link> of <literal>ONLY_DOWN</literal> (or at least has <literal>ONLY_DOWN</literal> in the leading score levels) prunes a lot.</simpara>
</important>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;DEPTH_FIRST&lt;/nodeExplorationType&gt;
    &lt;entitySorterManner&gt;DECREASING_DIFFICULTY_IF_AVAILABLE&lt;/entitySorterManner&gt;
    &lt;valueSorterManner&gt;INCREASING_STRENGTH_IF_AVAILABLE&lt;/valueSorterManner&gt;
  &lt;/exhaustiveSearch&gt;</programlisting>
<simpara>The <literal>nodeExplorationType</literal> options are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DEPTH_FIRST</literal> (default): Explore deeper nodes first (and then a better score and then a better optimistic bound). Deeper nodes (especially leaf nodes) often improve the pessimistic bound. A better pessimistic bound allows pruning more nodes to reduce the search space.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;DEPTH_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>BREADTH_FIRST</literal> (not recommended): Explore nodes layer by layer (and then a better score and then a better optimistic bound). Scales terribly in memory (and usually in performance too).</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;BREADTH_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>SCORE_FIRST</literal>: Explore nodes with a better score first (and then a better optimistic bound and then deeper nodes first). Might scale as terribly as <literal>BREADTH_FIRST</literal> in some cases.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;SCORE_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>OPTIMISTIC_BOUND_FIRST</literal>: Explore nodes with a better optimistic bound first (and then a better score and then deeper nodes first). Might scale as terribly as <literal>BREADTH_FIRST</literal> in some cases.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;exhaustiveSearch&gt;
    &lt;exhaustiveSearchType&gt;BRANCH_AND_BOUND&lt;/exhaustiveSearchType&gt;
    &lt;nodeExplorationType&gt;OPTIMISTIC_BOUND_FIRST&lt;/nodeExplorationType&gt;
  &lt;/exhaustiveSearch&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>The <literal>entitySorterManner</literal> options are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DECREASING_DIFFICULTY</literal>: Initialize the more difficult planning entities first. This usually increases pruning (and therefore improves scalability).
Requires the model to support <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>DECREASING_DIFFICULTY_IF_AVAILABLE</literal> (default): If the model supports <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>, behave like <literal>DECREASING_DIFFICULTY</literal>, else like <literal>NONE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>NONE</literal>: Initialize the planning entities in original order.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>valueSorterManner</literal> options are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>INCREASING_STRENGTH</literal>: Evaluate the planning values in increasing strength. Requires the model to support <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>INCREASING_STRENGTH_IF_AVAILABLE</literal> (default): If the model supports <link linkend="planningValueStrength">planning value strength comparison</link>, behave like <literal>INCREASING_STRENGTH</literal>, else like <literal>NONE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>DECREASING_STRENGTH</literal>: Evaluate the planning values in decreasing strength. Requires the model to support <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>DECREASING_STRENGTH_IF_AVAILABLE</literal>: If the model supports <link linkend="planningValueStrength">planning value strength comparison</link>, behave like <literal>DECREASING_STRENGTH</literal>, else like <literal>NONE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>NONE</literal>: Try the planning values in original order.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="scalabilityOfExhaustiveSearch">
<title>Scalability of Exhaustive Search</title>
<simpara>Exhaustive Search variants suffer from two big scalability issues:</simpara>
<itemizedlist>
<listitem>
<simpara>They scale terribly memory wise.</simpara>
</listitem>
<listitem>
<simpara>They scale horribly performance wise.</simpara>
</listitem>
</itemizedlist>
<simpara>As shown in these time spent graphs from the <link linkend="benchmarker">Benchmarker</link>, Brute Force and Branch And Bound both hit a performance scalability wall.
For example, on N queens it hits wall at a few dozen queens:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ExhaustiveSearch/exhaustiveSearchScalabilityNQueens.png" align="center"/>
</imageobject>
<textobject><phrase>exhaustiveSearchScalabilityNQueens</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In most use cases, such as Cloud Balancing, the wall appears out of thin air:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ExhaustiveSearch/exhaustiveSearchScalabilityCloudBalance.png" align="center"/>
</imageobject>
<textobject><phrase>exhaustiveSearchScalabilityCloudBalance</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><emphasis role="strong">Exhaustive Search hits this wall on small datasets already, so in production these optimizations algorithms are mostly useless.</emphasis> Use Construction Heuristics with Local Search instead: those can handle thousands of queens/computers easily.</simpara>
<note>
<simpara>Throwing hardware at these scalability issues has no noticeable impact.
Newer and more hardware are just a drop in the ocean.
Moore’s law cannot win against the onslaught of a few more planning entities in the dataset.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="constructionHeuristics">
<title>Construction Heuristics</title>
<section xml:id="constructionHeuristicsOverview">
<title>Overview</title>
<simpara>A construction heuristic builds a pretty good initial solution in a finite length of time.
Its solution isn’t always feasible, but it finds it fast so metaheuristics can finish the job.</simpara>
<simpara>Construction heuristics terminate automatically, so there’s usually no need to configure a <literal>Termination</literal> on the construction heuristic phase specifically.</simpara>
</section>
<section xml:id="firstFit">
<title>First Fit</title>
<section xml:id="firstFitAlgorithm">
<title>Algorithm Description</title>
<simpara>The First Fit algorithm cycles through all the planning entities (in default order), initializing one planning entity at a time.
It assigns the planning entity to the best available planning value, taking the already initialized planning entities into account.
It terminates when all planning entities have been initialized.
It never changes a planning entity after it has been assigned.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ConstructionHeuristics/firstFitNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>firstFitNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice that it starts with putting <literal>Queen</literal> A into row 0 (and never moving it later), which makes it impossible to reach the optimal solution.
Suffixing this construction heuristic with metaheuristics can remedy that.</simpara>
</section>
<section xml:id="firstFitConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
</section>
</section>
<section xml:id="firstFitDecreasing">
<title>First Fit Decreasing</title>
<section xml:id="firstFitDecreasingAlgorithm">
<title>Algorithm Description</title>
<simpara>Like <link linkend="firstFit">First Fit</link>, but assigns the more difficult planning entities first, because they are less likely to fit in the leftovers.
So it sorts the planning entities on decreasing difficulty.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ConstructionHeuristics/firstFitDecreasingNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>firstFitDecreasingNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Requires the model to support <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>.</simpara>
<note>
<simpara>One would expect that this algorithm has better results than First Fit.
That’s usually the case, but not always.</simpara>
</note>
</section>
<section xml:id="firstFitDecreasingConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
</section>
</section>
<section xml:id="weakestFit">
<title>Weakest Fit</title>
<section xml:id="weakestFitAlgorithm">
<title>Algorithm Description</title>
<simpara>Like First Fit, but uses the weaker planning values first, because the strong planning values are more likely to be able to accommodate later planning entities.
So it sorts the planning values on increasing strength.</simpara>
<simpara>Requires the model to support <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
<note>
<simpara>Do not presume that this algorithm has better results than First Fit.
That’s often not the case.</simpara>
</note>
</section>
<section xml:id="weakestFitConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;WEAKEST_FIT&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;WEAKEST_FIT&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
</section>
</section>
<section xml:id="weakestFitDecreasing">
<title>Weakest Fit Decreasing</title>
<section xml:id="weakestFitDecreasingAlgorithm">
<title>Algorithm Description</title>
<simpara>Combines First Fit Decreasing and Weakest Fit.
So it sorts the planning entities on decreasing difficulty and the planning values on increasing strength.</simpara>
<simpara>Requires the model to support <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>
and <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
<note>
<simpara>Do not presume that this algorithm has better results than First Fit Decreasing.
That’s often not the case.
However, it is usually better than Weakest Fit.</simpara>
</note>
</section>
<section xml:id="weakestFitDecreasingConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;WEAKEST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;WEAKEST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
</section>
</section>
<section xml:id="strongestFit">
<title>Strongest Fit</title>
<section xml:id="strongestFitAlgorithm">
<title>Algorithm Description</title>
<simpara>Like First Fit, but uses the strong planning values first, because the strong planning values are more likely to have a lower soft cost to use.
So it sorts the planning values on decreasing strength.</simpara>
<simpara>Requires the model to support <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
<note>
<simpara>Do not presume that this algorithm has better results than First Fit or Weakest Fit.
That’s often not the case.</simpara>
</note>
</section>
<section xml:id="strongestFitConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;STRONGEST_FIT&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;STRONGEST_FIT&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
</section>
</section>
<section xml:id="strongestFitDecreasing">
<title>Strongest Fit Decreasing</title>
<section xml:id="strongestFitDecreasingAlgorithm">
<title>Algorithm Description</title>
<simpara>Combines First Fit Decreasing and Strongest Fit.
So it sorts the planning entities on decreasing difficulty and the planning values on decreasing strength.</simpara>
<simpara>Requires the model to support <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>
and <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
<note>
<simpara>Do not presume that this algorithm has better results than First Fit Decreasing or Weakest Fit Decreasing.
That’s often not the case.
However, it is usually better than Strongest Fit.</simpara>
</note>
</section>
<section xml:id="strongestFitDecreasingConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;STRONGEST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;STRONGEST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
</section>
</section>
<section xml:id="allocateEntityFromQueue">
<title>Allocate Entity From Queue</title>
<section xml:id="allocateEntityFromQueueAlgorithm">
<title>Algorithm Description</title>
<simpara>Allocate Entity From Queue is a versatile, generic form of <link linkend="firstFit">First Fit</link>, <link linkend="firstFitDecreasing">First Fit Decreasing</link>,
<link linkend="weakestFit">Weakest Fit</link>, <link linkend="weakestFitDecreasing">Weakest Fit Decreasing</link>,
<link linkend="strongestFit">Strongest Fit</link> and <link linkend="strongestFitDecreasing">Strongest Fit Decreasing</link>.
It works like this:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Put all entities in a queue.</simpara>
</listitem>
<listitem>
<simpara>Assign the first entity (from that queue) to the best value.</simpara>
</listitem>
<listitem>
<simpara>Repeat until all entities are assigned.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="allocateEntityFromQueueConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;ALLOCATE_ENTITY_FROM_QUEUE&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Verbose simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;ALLOCATE_ENTITY_FROM_QUEUE&lt;/constructionHeuristicType&gt;
    &lt;entitySorterManner&gt;DECREASING_DIFFICULTY_IF_AVAILABLE&lt;/entitySorterManner&gt;
    &lt;valueSorterManner&gt;INCREASING_STRENGTH_IF_AVAILABLE&lt;/valueSorterManner&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>The <literal>entitySorterManner</literal> options are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>DECREASING_DIFFICULTY</literal>: Initialize the more difficult planning entities first.
This usually increases pruning (and therefore improves scalability).
Requires the model to support <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>DECREASING_DIFFICULTY_IF_AVAILABLE</literal> (default): If the model supports <link linkend="planningEntityDifficulty">planning entity difficulty comparison</link>, behave like <literal>DECREASING_DIFFICULTY</literal>, else like <literal>NONE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>NONE</literal>: Initialize the planning entities in original order.</simpara>
</listitem>
</itemizedlist>
<simpara>The <literal>valueSorterManner</literal> options are:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>INCREASING_STRENGTH</literal>: Evaluate the planning values in increasing strength.
Requires the model to support <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>INCREASING_STRENGTH_IF_AVAILABLE</literal> (default): If the model supports <link linkend="planningValueStrength">planning value strength comparison</link>, behave like <literal>INCREASING_STRENGTH</literal>, else like <literal>NONE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>DECREASING_STRENGTH</literal>: Evaluate the planning values in decreasing strength.
Requires the model to support <link linkend="planningValueStrength">planning value strength comparison</link>.</simpara>
</listitem>
<listitem>
<simpara><literal>DECREASING_STRENGTH_IF_AVAILABLE</literal>: If the model supports <link linkend="planningValueStrength">planning value strength comparison</link>, behave like <literal>DECREASING_STRENGTH</literal>, else like <literal>NONE</literal>.</simpara>
</listitem>
<listitem>
<simpara><literal>NONE</literal>: Try the planning values in original order.</simpara>
</listitem>
</itemizedlist>
<simpara>Advanced configuration with <link linkend="weakestFitDecreasing">Weakest Fit Decreasing</link> for a single entity class with one variable:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;queuedEntityPlacer&gt;
      &lt;entitySelector id="placerEntitySelector"&gt;
        &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
        &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
        &lt;sorterManner&gt;DECREASING_DIFFICULTY&lt;/sorterManner&gt;
      &lt;/entitySelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector mimicSelectorRef="placerEntitySelector"/&gt;
        &lt;valueSelector&gt;
          &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
          &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
          &lt;sorterManner&gt;INCREASING_STRENGTH&lt;/sorterManner&gt;
        &lt;/valueSelector&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/queuedEntityPlacer&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Per step, the <literal>QueuedEntityPlacer</literal> selects one uninitialized entity from the <literal>EntitySelector</literal>
and applies the winning <literal>Move</literal> (out of all the moves for that entity generated by the <literal>MoveSelector</literal>).
The <link linkend="mimicSelection">mimic selection</link> ensures that the winning <literal>Move</literal> changes only the selected entity.</simpara>
<simpara>To customize the entity or value sorting, see <link linkend="sortedSelection">sorted selection</link>.
For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.</simpara>
<simpara>If there are multiple planning variables, there’s one <literal>ChangeMoveSelector</literal> per planning variable,
which are either in a cartesian product or in sequential steps,
similar to <link linkend="scalingMultiplePlanningVariablesInConstructionHeuristics">the less verbose configuration</link>.</simpara>
</section>
<section xml:id="allocateEntityFromQueueMultipleEntityClasses">
<title>Multiple Entity Classes</title>
<simpara>The easiest way to deal with multiple entity classes is to run a separate Construction Heuristic for each entity class:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;queuedEntityPlacer&gt;
      &lt;entitySelector id="placerEntitySelector"&gt;
        &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
        &lt;entityClass&gt;...DogEntity&lt;/entityClass&gt;
      &lt;/entitySelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector mimicSelectorRef="placerEntitySelector"/&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/queuedEntityPlacer&gt;
    ...
  &lt;/constructionHeuristic&gt;
  &lt;constructionHeuristic&gt;
    &lt;queuedEntityPlacer&gt;
      &lt;entitySelector id="placerEntitySelector"&gt;
        &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
        &lt;entityClass&gt;...CatEntity&lt;/entityClass&gt;
      &lt;/entitySelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector mimicSelectorRef="placerEntitySelector"/&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/queuedEntityPlacer&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
</section>
<section xml:id="constructionHeuristicsPickEarlyType">
<title>Pick Early Type</title>
<simpara>There are several pick early types for Construction Heuristics:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NEVER</literal>: Evaluate all the selected moves to initialize the variable(s).
This is the default if the <link linkend="initializingScoreTrend">InitializingScoreTrend</link> is not <literal>ONLY_DOWN</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    ...
    &lt;forager&gt;
      &lt;pickEarlyType&gt;NEVER&lt;/pickEarlyType&gt;
    &lt;/forager&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>FIRST_NON_DETERIORATING_SCORE</literal>: Initialize the variable(s) with the first move that doesn’t deteriorate the score, ignore the remaining selected moves.
This is the default if the <link linkend="initializingScoreTrend">InitializingScoreTrend</link> is <literal>ONLY_DOWN</literal>.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    ...
    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_NON_DETERIORATING_SCORE&lt;/pickEarlyType&gt;
    &lt;/forager&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<note>
<simpara>If there are only negative constraints, but the <link linkend="initializingScoreTrend">InitializingScoreTrend</link> is strictly not <literal>ONLY_DOWN</literal>,
it can sometimes make sense to apply FIRST_NON_DETERIORATING_SCORE.
Use the <link linkend="benchmarker">Benchmarker</link> to decide if the score quality loss is worth the time gain.</simpara>
</note>
</listitem>
<listitem>
<simpara><literal>FIRST_FEASIBLE_SCORE</literal>: Initialize the variable(s) with the first move that has a feasible score.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    ...
    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_FEASIBLE_SCORE&lt;/pickEarlyType&gt;
    &lt;/forager&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>If the <link linkend="initializingScoreTrend">InitializingScoreTrend</link> is <literal>ONLY_DOWN</literal>, use <literal>FIRST_FEASIBLE_SCORE_OR_NON_DETERIORATING_HARD</literal> instead, because that’s faster without any disadvantages.</simpara>
</listitem>
<listitem>
<simpara><literal>FIRST_FEASIBLE_SCORE_OR_NON_DETERIORATING_HARD</literal>: Initialize the variable(s) with the first move that doesn’t deteriorate the feasibility of the score any further.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    ...
    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_FEASIBLE_SCORE_OR_NON_DETERIORATING_HARD&lt;/pickEarlyType&gt;
    &lt;/forager&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="allocateToValueFromQueue">
<title>Allocate To Value From Queue</title>
<section xml:id="allocateToValueFromQueueAlgorithm">
<title>Algorithm Description</title>
<simpara>Allocate To Value From Queue works like this:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Put all values in a round-robin queue.</simpara>
</listitem>
<listitem>
<simpara>Assign the best entity to the first value (from that queue).</simpara>
</listitem>
<listitem>
<simpara>Repeat until all entities are assigned.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="allocateToValueFromQueueConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;ALLOCATE_TO_VALUE_FROM_QUEUE&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Verbose simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;ALLOCATE_TO_VALUE_FROM_QUEUE&lt;/constructionHeuristicType&gt;
    &lt;entitySorterManner&gt;DECREASING_DIFFICULTY_IF_AVAILABLE&lt;/entitySorterManner&gt;
    &lt;valueSorterManner&gt;INCREASING_STRENGTH_IF_AVAILABLE&lt;/valueSorterManner&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration for a single entity class with a single variable:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;queuedValuePlacer&gt;
      &lt;valueSelector id="placerValueSelector"&gt;
        &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
        &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
        &lt;sorterManner&gt;INCREASING_STRENGTH&lt;/sorterManner&gt;
      &lt;/valueSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector&gt;
          &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
          &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
          &lt;sorterManner&gt;DECREASING_DIFFICULTY&lt;/sorterManner&gt;
        &lt;/entitySelector&gt;
        &lt;valueSelector mimicSelectorRef="placerValueSelector"/&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/queuedValuePlacer&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.</simpara>
</section>
</section>
<section xml:id="cheapestInsertion">
<title>Cheapest Insertion</title>
<section xml:id="cheapestInsertionAlgorithm">
<title>Algorithm Description</title>
<simpara>The Cheapest Insertion algorithm cycles through all the planning values for all the planning entities, initializing one planning entity at a time.
It assigns a planning entity to the best available planning value (out of all the planning entities and values), taking the already initialized planning entities into account.
It terminates when all planning entities have been initialized.
It never changes a planning entity after it has been assigned.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ConstructionHeuristics/cheapestInsertionNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>cheapestInsertionNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Cheapest Insertion scales considerably worse than First Fit, etc.</simpara>
</note>
</section>
<section xml:id="cheapestInsertionConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;CHEAPEST_INSERTION&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;CHEAPEST_INSERTION&lt;/constructionHeuristicType&gt;
    &lt;...MoveSelector/&gt;
    &lt;...MoveSelector/&gt;
    ...
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.
For a very advanced configuration, see <link linkend="allocateFromPool">Allocate from pool</link>.</simpara>
</section>
</section>
<section xml:id="regretInsertion">
<title>Regret Insertion</title>
<section xml:id="regretInsertionAlgorithm">
<title>Algorithm Description</title>
<simpara>The Regret Insertion algorithm behaves like the Cheapest Insertion algorithm.
It also cycles through all the planning values for all the planning entities, initializing one planning entity at a time.
But instead of picking the entity-value combination with the best score, it picks the entity which has the largest score loss between its best and second best value assignment.
It then assigns that entity to its best value, to avoid regretting not having done that.</simpara>
</section>
<section xml:id="regretInsertionConfiguration">
<title>Configuration</title>
<simpara>This algorithm has not been implemented yet.</simpara>
</section>
</section>
<section xml:id="allocateFromPool">
<title>Allocate From Pool</title>
<section xml:id="allocateFromPoolAlgorithm">
<title>Algorithm Description</title>
<simpara>Allocate From Pool is a versatile, generic form of <link linkend="cheapestInsertion">Cheapest Insertion</link> and <link linkend="regretInsertion">Regret Insertion</link>.
It works like this:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Put all entity-value combinations in a pool.</simpara>
</listitem>
<listitem>
<simpara>Assign the best entity to best value.</simpara>
</listitem>
<listitem>
<simpara>Repeat until all entities are assigned.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="allocateFromPoolConfiguration">
<title>Configuration</title>
<simpara>Simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;ALLOCATE_FROM_POOL&lt;/constructionHeuristicType&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Verbose simple configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;ALLOCATE_FROM_POOL&lt;/constructionHeuristicType&gt;
    &lt;entitySorterManner&gt;DECREASING_DIFFICULTY_IF_AVAILABLE&lt;/entitySorterManner&gt;
    &lt;valueSorterManner&gt;INCREASING_STRENGTH_IF_AVAILABLE&lt;/valueSorterManner&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>The <literal>entitySorterManner</literal> and <literal>valueSorterManner</literal> options are described in <link linkend="allocateEntityFromQueue">Allocate Entity From Queue</link>.</simpara>
<simpara>Advanced configuration with <link linkend="cheapestInsertion">Cheapest Insertion</link> for a single entity class with a single variable:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;pooledEntityPlacer&gt;
      &lt;changeMoveSelector&gt;
        &lt;entitySelector id="placerEntitySelector"&gt;
          &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
          &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
          &lt;sorterManner&gt;DECREASING_DIFFICULTY&lt;/sorterManner&gt;
        &lt;/entitySelector&gt;
        &lt;valueSelector&gt;
          &lt;cacheType&gt;PHASE&lt;/cacheType&gt;
          &lt;selectionOrder&gt;SORTED&lt;/selectionOrder&gt;
          &lt;sorterManner&gt;INCREASING_STRENGTH&lt;/sorterManner&gt;
        &lt;/valueSelector&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/pooledEntityPlacer&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
<simpara>Per step, the <literal>PooledEntityPlacer</literal> applies the winning <literal>Move</literal> (out of all the moves for that entity generated by the <literal>MoveSelector</literal>).</simpara>
<simpara>To customize the entity or value sorting, see <link linkend="sortedSelection">sorted selection</link>.
Other <literal>Selector</literal> customization (such as <link linkend="filteredSelection">filtering</link> and <link linkend="limitedSelection">limiting</link>) is supported too.</simpara>
<simpara>For scaling out, see <link linkend="scalingConstructionHeuristics">scaling construction heuristics</link>.</simpara>
</section>
</section>
<section xml:id="scalingConstructionHeuristics">
<title>Scaling Construction Heuristics</title>
<simpara>If the Construction Heuristic takes a long time to solve and create an initial solution,
there is too little time left for <link linkend="localSearch">Local Search</link> to reach a near optimal solution.</simpara>
<simpara>Ideally, a Construction Heuristic should take less than 20 seconds from scratch
and less than 50 milliseconds in <link linkend="realTimePlanning">real-time planning</link>,
so there plenty of time left for <link linkend="localSearch">Local Search</link>.
If the <link linkend="benchmarker">Benchmarker</link> proves that this is not the case, there’s a number of improvements that can be done:</simpara>
<section xml:id="initializingScoreTrendShortcuts">
<title>InitializingScoreTrend shortcuts</title>
<simpara>If the <link linkend="initializingScoreTrend">InitializingScoreTrend</link> is <literal>ONLY_DOWN</literal>, a Construction Heuristic algorithm (such as First Fit) is faster:
for an entity, it picks the first move for which the score does not deteriorate the last step score, ignoring all subsequent moves in that step.</simpara>
<simpara>It can take that shortcut without reducing solution quality,
because a down trend guarantees that initializing any additional planning variable can only make the score the same or worse.
So if a move has the same score as before the planning variable was initialized, then no other move can have a better score.</simpara>
</section>
<section xml:id="scalingMultiplePlanningVariablesInConstructionHeuristics">
<title>Scaling Multiple Planning Variables in Construction Heuristics</title>
<simpara>There are two ways to deal with multiple planning variables,
depending on how their <literal>ChangeMove</literal>s are combined:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Cartesian product</emphasis> (default): All variables of the selected entity are assigned together.
This usually results in a better solution quality, but it scales poorly because it tries every combination of variables. For example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
    &lt;cartesianProductMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;valueSelector variableName="period"/&gt;
      &lt;/changeMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;valueSelector variableName="room"/&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/cartesianProductMoveSelector&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis role="strong">Sequential</emphasis>: One variable is assigned at a time.
Scales better, at the cost of solution quality. The order of the planning variables matters. For example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
    &lt;changeMoveSelector&gt;
      &lt;valueSelector variableName="period"/&gt;
    &lt;/changeMoveSelector&gt;
    &lt;changeMoveSelector&gt;
      &lt;valueSelector variableName="room"/&gt;
    &lt;/changeMoveSelector&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>The second way scales better, so it can be worth to switch to it.
For example, in a course scheduling example with 200 rooms and 40 periods,
a cartesian product selects 8000 moves per entity (1 step per entity).
On the other hand, a sequential approach only selects 240 moves per entity (2 steps per entity),
ending the Construction Heuristic 3 times faster.
Especially for three or more planning variables, the scaling difference is huge.
For example, with three variables of 1000 values each,
a cartesian product selects 1000000000 moves per entity (1 step per entity).
A sequential approach only selects 240 moves per entity (3 steps per entity),
ending the Construction Heuristic 300 000 times faster.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/ConstructionHeuristics/multiVariableConstructionHeuristics.png" align="center"/>
</imageobject>
<textobject><phrase>multiVariableConstructionHeuristics</phrase></textobject>
</mediaobject>
</informalfigure>
<important>
<simpara>The order of the variables is important, especially in the sequential technique.
In the sequential example above, it’s better to select the <literal>period</literal> first and the <literal>room</literal> second (instead of the other way around),
because there are more hard constraints that do not involve the room, such as <emphasis>no teacher should teach two lectures at the same time</emphasis>.</simpara>
<simpara>Let the <link linkend="benchmarker">Benchmarker</link> guide you.</simpara>
</important>
<simpara>With three or more variables, it’s possible to combine the cartesian product and sequential techniques:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;constructionHeuristic&gt;
    &lt;constructionHeuristicType&gt;FIRST_FIT_DECREASING&lt;/constructionHeuristicType&gt;
    &lt;cartesianProductMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;valueSelector variableName="period"/&gt;
      &lt;/changeMoveSelector&gt;
      &lt;changeMoveSelector&gt;
        &lt;valueSelector variableName="room"/&gt;
      &lt;/changeMoveSelector&gt;
    &lt;/cartesianProductMoveSelector&gt;
    &lt;changeMoveSelector&gt;
      &lt;valueSelector variableName="teacher"/&gt;
    &lt;/changeMoveSelector&gt;
  &lt;/constructionHeuristic&gt;</programlisting>
</section>
<section xml:id="otherScalingTechniquesInConstructionHeuristics">
<title>Other Scaling Techniques in Construction Heuristics</title>
<simpara><link linkend="partitionedSearch">Partitioned Search</link> reduces the number of moves per step.
On top of that, it runs the Construction Heuristic on the partitions in parallel.
It is supported to only partition the Construction Heuristic phase.</simpara>
<simpara>Other <literal>Selector</literal> customizations can also reduce the number of moves generated by step:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="filteredSelection">Filtered selection</link></simpara>
</listitem>
<listitem>
<simpara><link linkend="limitedSelection">Limited selection</link></simpara>
</listitem>
</itemizedlist>
</section>
</section>
</chapter>
<chapter xml:id="localSearch">
<title>Local Search</title>
<section xml:id="localSearchOverview">
<title>Overview</title>
<simpara>Local Search starts from an initial solution and evolves that single solution into a mostly better and better solution.
It uses a single search path of solutions, not a search tree.
At each solution in this path it evaluates a number of moves on the solution and applies the most suitable move to take the step to the next solution.
It does that for a high number of iterations until it’s terminated (usually because its time has run out).</simpara>
<simpara>Local Search acts a lot like a human planner: it uses a single search path and moves facts around to find a good feasible solution.
Therefore it’s pretty natural to implement.</simpara>
<simpara><emphasis role="strong">Local Search needs to start from an initialized solution</emphasis>, therefore it’s usually required to configure a Construction Heuristic phase before it.</simpara>
</section>
<section xml:id="localSearchConcepts">
<title>Local Search Concepts</title>
<section xml:id="localSearchStepByStep">
<title>Step by Step</title>
<simpara>A step is the winning <literal>Move</literal>.
Local Search tries a number of moves on the current solution and picks the best accepted move as the step:</simpara>
<figure>
<title>Decide the next step at step 0 (four queens example)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/decideNextStepNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>decideNextStepNQueens04</phrase></textobject>
</mediaobject>
</figure>
<simpara>Because the move <emphasis>B0 to B3</emphasis> has the highest score (<literal>-3</literal>), it is picked as the next step.
If multiple moves have the same highest score, one is picked randomly, in this case <emphasis>B0 to B3</emphasis>.
Note that <emphasis>C0 to C3</emphasis> (not shown) could also have been picked because it also has the score <literal>-3</literal>.</simpara>
<simpara>The step is applied on the solution.
From that new solution, Local Search tries every move again, to decide the next step after that.
It continually does this in a loop, and we get something like this:</simpara>
<figure>
<title>All steps (four queens example)</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/allStepsNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>allStepsNQueens04</phrase></textobject>
</mediaobject>
</figure>
<simpara>Notice that Local Search doesn’t use a search tree, but a search path.
The search path is highlighted by the green arrows.
At each step it tries all selected moves, but unless it’s the step, it doesn’t investigate that solution further.
This is one of the reasons why Local Search is very scalable.</simpara>
<simpara>As shown above, Local Search solves the four queens problem by starting with the starting solution and make the following steps sequentially:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis>B0 to B3</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>D0 to B2</emphasis></simpara>
</listitem>
<listitem>
<simpara><emphasis>A0 to B1</emphasis></simpara>
</listitem>
</orderedlist>
<simpara>Turn on <literal>debug</literal> logging for the category <literal>org.optaplanner</literal> to show those steps in the log:</simpara>
<screen>INFO  Solving started: time spent (0), best score (-6), environment mode (REPRODUCIBLE), random (JDK with seed 0).
DEBUG     LS step (0), time spent (20), score (-3), new best score (-3), accepted/selected move count (12/12), picked move (Queen-1 {Row-0 -&gt; Row-3}).
DEBUG     LS step (1), time spent (31), score (-1), new best score (-1), accepted/selected move count (12/12), picked move (Queen-3 {Row-0 -&gt; Row-2}).
DEBUG     LS step (2), time spent (40), score (0), new best score (0), accepted/selected move count (12/12), picked move (Queen-0 {Row-0 -&gt; Row-1}).
INFO  Local Search phase (0) ended: time spent (41), best score (0), score calculation speed (5000/sec), step total (3).
INFO  Solving ended: time spent (41), best score (0), score calculation speed (5000/sec), phase total (1), environment mode (REPRODUCIBLE).</screen>
<simpara>Notice that a log message includes the <literal>toString()</literal> method of the <literal>Move</literal> implementation which returns for example "<literal>Queen-1 {Row-0 → Row-3}</literal>".</simpara>
<simpara>A naive Local Search configuration solves the four queens problem in three steps, by evaluating only 37 possible solutions (three steps with 12 moves each + one starting solution), which is only fraction of all 256 possible solutions.
It solves 16 queens in 31 steps, by evaluating only 7441 out of 18446744073709551616 possible solutions.
By using a <link linkend="constructionHeuristics">Construction Heuristics</link> phase first, it’s even a lot more efficient.</simpara>
</section>
<section xml:id="localSearchConceptsDecideTheNextStep">
<title>Decide the Next Step</title>
<simpara>Local Search decides the next step with the aid of three configurable components:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>MoveSelector</literal> which selects the possible moves of the current solution. See the chapter <link linkend="moveAndNeighborhoodSelection">move and neighborhood selection</link>.</simpara>
</listitem>
<listitem>
<simpara>An <literal>Acceptor</literal> which filters out unacceptable moves.</simpara>
</listitem>
<listitem>
<simpara>A <literal>Forager</literal> which gathers accepted moves and picks the next step from them.</simpara>
</listitem>
</itemizedlist>
<simpara>The solver phase configuration looks like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;unionMoveSelector&gt;
      ...
    &lt;/unionMoveSelector&gt;
    &lt;acceptor&gt;
      ...
    &lt;/acceptor&gt;
    &lt;forager&gt;
      ...
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>In the example below, the <literal>MoveSelector</literal> generated the moves shown with the blue lines, the <literal>Acceptor</literal> accepted all of them and the <literal>Forager</literal> picked the move <emphasis>B0 to B3</emphasis>.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/decideNextStepNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>decideNextStepNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara><link linkend="logging">Turn on <literal>trace</literal> logging</link> to show the decision making in the log:</simpara>
<screen>INFO  Solver started: time spent (0), score (-6), new best score (-6), random (JDK with seed 0).
TRACE         Move index (0) not doable, ignoring move (Queen-0 {Row-0 -&gt; Row-0}).
TRACE         Move index (1), score (-4), accepted (true), move (Queen-0 {Row-0 -&gt; Row-1}).
TRACE         Move index (2), score (-4), accepted (true), move (Queen-0 {Row-0 -&gt; Row-2}).
TRACE         Move index (3), score (-4), accepted (true), move (Queen-0 {Row-0 -&gt; Row-3}).
...
TRACE         Move index (6), score (-3), accepted (true), move (Queen-1 {Row-0 -&gt; Row-3}).
...
TRACE         Move index (9), score (-3), accepted (true), move (Queen-2 {Row-0 -&gt; Row-3}).
...
TRACE         Move index (12), score (-4), accepted (true), move (Queen-3 {Row-0 -&gt; Row-3}).
DEBUG     LS step (0), time spent (6), score (-3), new best score (-3), accepted/selected move count (12/12), picked move (Queen-1 {Row-0 -&gt; Row-3}).
...</screen>
<simpara>Because the last solution can degrade (for example in Tabu Search), the <literal>Solver</literal> remembers the best solution it has encountered through the entire search path.
Each time the current solution is better than the last best solution, the current solution is <link linkend="cloningASolution">cloned</link> and referenced as the new best solution.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/localSearchScoreOverTime.png" align="center"/>
</imageobject>
<textobject><phrase>localSearchScoreOverTime</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="localSearchAcceptor">
<title>Acceptor</title>
<simpara>An <literal>Acceptor</literal> is used (together with a <literal>Forager</literal>) to active Tabu Search, Simulated Annealing, Late Acceptance, …​ For each move it checks whether it is accepted or not.</simpara>
<simpara>By changing a few lines of configuration, you can easily switch from Tabu Search to Simulated Annealing or Late Acceptance and back.</simpara>
<simpara>You can implement your own <literal>Acceptor</literal>, but the built-in acceptors should suffice for most needs.
You can also combine multiple acceptors.</simpara>
</section>
<section xml:id="localSearchForager">
<title>Forager</title>
<simpara>A <literal>Forager</literal> gathers all accepted moves and picks the move which is the next step.
Normally it picks the accepted move with the highest score.
If several accepted moves have the highest score, one is picked randomly to break the tie.
Breaking ties randomly leads to better results.</simpara>
<note>
<simpara>It is possible to disable breaking ties randomly by explicitly setting <literal>breakTieRandomly</literal> to <literal>false</literal>, but that’s almost never a good idea:</simpara>
<itemizedlist>
<listitem>
<simpara>If an earlier move is better than a later move with the same score, the score calculator should add an extra softer <link linkend="scoreLevel">score level</link> to score the first move as slightly better. Don’t rely on move selection order to enforce that.</simpara>
</listitem>
<listitem>
<simpara>Random tie breaking does not affect <link linkend="environmentMode">reproducibility</link>.</simpara>
</listitem>
</itemizedlist>
</note>
<section xml:id="acceptedCountLimit">
<title>Accepted Count Limit</title>
<simpara>When there are many possible moves, it becomes inefficient to evaluate all of them at every step.
To evaluate only a random subset of all the moves, use:</simpara>
<itemizedlist>
<listitem>
<simpara>An <literal>acceptedCountLimit</literal> integer, which specifies how many accepted moves should be evaluated during each step. By default, all accepted moves are evaluated at every step.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;forager&gt;
    &lt;acceptedCountLimit&gt;1000&lt;/acceptedCountLimit&gt;
  &lt;/forager&gt;</programlisting>
</listitem>
</itemizedlist>
<simpara>Unlike the n queens problem, real world problems require the use of <literal>acceptedCountLimit</literal>.
Start from an <literal>acceptedCountLimit</literal> that takes a step in less then two seconds. <link linkend="logging">Turn on INFO logging</link> to see the step times.
Use the <link linkend="benchmarker">Benchmarker</link> to tweak the value.</simpara>
<important>
<simpara>With a low <literal>acceptedCountLimit</literal> (so a fast stepping algorithm), it is recommended to avoid using <literal>selectionOrder</literal> SHUFFLED because the shuffling generates a random number for every element in the selector, taking up a lot of time, but only a few elements are actually selected.</simpara>
</important>
</section>
<section xml:id="localSearchPickEarlyType">
<title>Pick Early Type</title>
<simpara>A forager can pick a move early during a step, ignoring subsequent selected moves.
There are three pick early types for Local Search:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>NEVER</literal>: A move is never picked early: all accepted moves are evaluated that the selection allows. This is the default.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;forager&gt;
      &lt;pickEarlyType&gt;NEVER&lt;/pickEarlyType&gt;
    &lt;/forager&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>FIRST_BEST_SCORE_IMPROVING</literal>: Pick the first accepted move that improves the best score. If none improve the best score, it behaves exactly like the pickEarlyType NEVER.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_BEST_SCORE_IMPROVING&lt;/pickEarlyType&gt;
    &lt;/forager&gt;</programlisting>
</listitem>
<listitem>
<simpara><literal>FIRST_LAST_STEP_SCORE_IMPROVING</literal>: Pick the first accepted move that improves the last step score. If none improve the last step score, it behaves exactly like the pickEarlyType NEVER.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;forager&gt;
      &lt;pickEarlyType&gt;FIRST_LAST_STEP_SCORE_IMPROVING&lt;/pickEarlyType&gt;
    &lt;/forager&gt;</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
</section>
<section xml:id="hillClimbing">
<title>Hill Climbing (Simple Local Search)</title>
<section xml:id="hillClimbingAlgorithm">
<title>Algorithm Description</title>
<simpara>Hill Climbing tries all selected moves and then takes the best move, which is the move which leads to the solution with the highest score.
That best move is called the step move.
From that new solution, it again tries all selected moves and takes the best move and continues like that iteratively.
If multiple selected moves tie for the best move, one of them is randomly chosen as the best move.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/hillClimbingNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>hillClimbingNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Notice that once a queen has moved, it can be moved again later.
This is a good thing, because in an NP-complete problem it’s impossible to predict what will be the optimal final value for a planning variable.</simpara>
</section>
<section xml:id="hillClimbingStuckInLocalOptima">
<title>Stuck in Local Optima</title>
<simpara>Hill Climbing always takes improving moves.
This may seem like a good thing, but it’s not: <emphasis role="strong">Hill Climbing can easily get stuck in a local optimum.</emphasis> This happens when it reaches a solution for which all the moves deteriorate the score.
Even if it picks one of those moves, the next step might go back to the original solution and which case chasing its own tail:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/hillClimbingGetsStuckInLocalOptimaNQueens04.png" align="center"/>
</imageobject>
<textobject><phrase>hillClimbingGetsStuckInLocalOptimaNQueens04</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Improvements upon Hill Climbing (such as Tabu Search, Simulated Annealing and Late Acceptance) address the problem of being stuck in local optima.
Therefore, it’s recommend to never use Hill Climbing, unless you’re absolutely sure there are no local optima in your planning problem.</simpara>
</section>
<section xml:id="hillClimbingConfigure">
<title>Configuration</title>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;localSearchType&gt;HILL_CLIMBING&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;acceptorType&gt;HILL_CLIMBING&lt;/acceptorType&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
</section>
</section>
<section xml:id="tabuSearch">
<title>Tabu Search</title>
<section xml:id="tabuSearchAlgorithm">
<title>Algorithm Description</title>
<simpara>Tabu Search works like Hill Climbing, but it maintains a tabu list to avoid getting stuck in local optima.
The tabu list holds recently used objects that are <emphasis>taboo</emphasis> to use for now.
Moves that involve an object in the tabu list, are not accepted.
The tabu list objects can be anything related to the move, such as the planning entity, planning value, move, solution, …​
Here’s an example with entity tabu for four queens, so the queens are put in the tabu list:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/entityTabuSearch.png" align="center"/>
</imageobject>
<textobject><phrase>entityTabuSearch</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>It’s called Tabu Search, not Taboo Search.
There is no spelling error.</simpara>
</note>
<simpara>Scientific paper: <emphasis>Tabu Search - Part 1 and Part 2</emphasis> by Fred Glover (1989 - 1990)</simpara>
</section>
<section xml:id="tabuSearchConfiguration">
<title>Configuration</title>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;localSearchType&gt;TABU_SEARCH&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>When Tabu Search takes steps it creates one or more tabu’s.
For a number of steps, it does not accept a move if that move breaks tabu.
That number of steps is the tabu size.
Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1000&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
<important>
<simpara>A Tabu Search acceptor should be combined with a high <literal>acceptedCountLimit</literal>, such as <literal>1000</literal>.</simpara>
</important>
<simpara>Planner implements several tabu types:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Planning entity tabu</emphasis> (recommended) makes the planning entities of recent steps tabu. For example, for N queens it makes the recently moved queens tabu. It’s recommended to start with this tabu type.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;</programlisting>
<simpara>To avoid hard coding the tabu size, configure a tabu ratio, relative to the number of entities, for example 2%:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;entityTabuRatio&gt;0.02&lt;/entityTabuRatio&gt;
    &lt;/acceptor&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis>Planning value tabu</emphasis> makes the planning values of recent steps tabu. For example, for N queens it makes the recently moved to rows tabu.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;valueTabuSize&gt;7&lt;/valueTabuSize&gt;
    &lt;/acceptor&gt;</programlisting>
<simpara>To avoid hard coding the tabu size, configure a tabu ratio, relative to the number of values, for example 2%:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;valueTabuRatio&gt;0.02&lt;/valueTabuRatio&gt;
    &lt;/acceptor&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis>Move tabu</emphasis> makes recent steps tabu. It does not accept a move equal to one of those steps.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;moveTabuSize&gt;7&lt;/moveTabuSize&gt;
    &lt;/acceptor&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis>Undo move tabu </emphasis>makes the undo move of recent steps tabu.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;undoMoveTabuSize&gt;7&lt;/undoMoveTabuSize&gt;
    &lt;/acceptor&gt;</programlisting>
</listitem>
<listitem>
<simpara><emphasis>Solution tabu</emphasis> makes recently visited solutions tabu. It does not accept a move that leads to one of those solutions. It requires that the <literal>Solution</literal> implements <literal>equals()</literal> and <literal>hashCode()</literal> properly. If you can spare the memory, don’t be cheap on the tabu size.</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;solutionTabuSize&gt;1000&lt;/solutionTabuSize&gt;
    &lt;/acceptor&gt;</programlisting>
<simpara>For non-trivial cases, solution tabu is usually useless because the <link linkend="searchSpaceSize">search space size</link> makes it statistically highly unlikely to reach the same solution twice.
Therefore its use is not recommended, except for small datasets.</simpara>
</listitem>
</itemizedlist>
<simpara>Sometimes it’s useful to combine tabu types:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
      &lt;valueTabuSize&gt;3&lt;/valueTabuSize&gt;
    &lt;/acceptor&gt;</programlisting>
<simpara>If the tabu size is too small, the solver can still get stuck in a local optimum.
On the other hand, if the tabu size is too large, the solver can be inefficient by bouncing of the walls.
Use the <link linkend="benchmarker">Benchmarker</link> to fine tweak your configuration.</simpara>
</section>
</section>
<section xml:id="simulatedAnnealing">
<title>Simulated Annealing</title>
<section xml:id="simulatedAnnealingAlgorithm">
<title>Algorithm Description</title>
<simpara>Simulated Annealing evaluates only a few moves per step, so it steps quickly.
In the classic implementation, the first accepted move is the winning step.
A move is accepted if it doesn’t decrease the score or - in case it does decrease the score - it passes a random check.
The chance that a decreasing move passes the random check decreases relative to the size of the score decrement and the time the phase has been running (which is represented as the temperature).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/simulatedAnnealing.png" align="center"/>
</imageobject>
<textobject><phrase>simulatedAnnealing</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Simulated Annealing does not always pick the move with the highest score, neither does it evaluate many moves per step.
At least at first.
Instead, it gives non improving moves also a chance to be picked, depending on its score and the time gradient of the <literal>Termination</literal>.
In the end, it gradually turns into Hill Climbing, only accepting improving moves.</simpara>
</section>
<section xml:id="simulatedAnnealingConfiguration">
<title>Configuration</title>
<simpara>Start with a <literal>simulatedAnnealingStartingTemperature</literal> set to the maximum score delta a single move can cause.
Use the <link linkend="benchmarker">Benchmarker</link> to tweak the value.
Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;simulatedAnnealingStartingTemperature&gt;2hard/100soft&lt;/simulatedAnnealingStartingTemperature&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>Simulated Annealing should use a low <literal>acceptedCountLimit</literal>.
The classic algorithm uses an <literal>acceptedCountLimit</literal> of <literal>1</literal>, but often <literal>4</literal> performs better.</simpara>
<simpara>Simulated Annealing can be combined with a tabu acceptor at the same time.
That gives Simulated Annealing salted with a bit of Tabu.
Use a lower tabu size than in a pure Tabu Search configuration.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;simulatedAnnealingStartingTemperature&gt;2hard/100soft&lt;/simulatedAnnealingStartingTemperature&gt;
      &lt;entityTabuSize&gt;5&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
</section>
</section>
<section xml:id="lateAcceptance">
<title>Late Acceptance</title>
<section xml:id="lateAcceptanceAlgorithm">
<title>Algorithm Description</title>
<simpara>Late Acceptance (also known as Late Acceptance Hill Climbing) also evaluates only a few moves per step.
A move is accepted if it does not decrease the score, or if it leads to a score that is at least the late score (which is the winning score of a fixed number of steps ago).</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/LocalSearch/lateAcceptance.png" align="center"/>
</imageobject>
<textobject><phrase>lateAcceptance</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Scientific paper: <link xlink:href="http://www.cs.stir.ac.uk/research/publications/techreps/pdf/TR192.pdf">The Late Acceptance Hill-Climbing Heuristic by Edmund K. Burke, Yuri Bykov (2012)</link></simpara>
</section>
<section xml:id="lateAcceptanceConfiguration">
<title>Configuration</title>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    &lt;localSearchType&gt;LATE_ACCEPTANCE&lt;/localSearchType&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>Late Acceptance accepts any move that has a score which is higher than the best score of a number of steps ago.
That number of steps is the <literal>lateAcceptanceSize</literal>.
Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;lateAcceptanceSize&gt;400&lt;/lateAcceptanceSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>Late Acceptance should use a low <literal>acceptedCountLimit</literal>.</simpara>
<simpara>Late Acceptance can be combined with a tabu acceptor at the same time.
That gives Late Acceptance salted with a bit of Tabu.
Use a lower tabu size than in a pure Tabu Search configuration.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;lateAcceptanceSize&gt;400&lt;/lateAcceptanceSize&gt;
      &lt;entityTabuSize&gt;5&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
</section>
</section>
<section xml:id="stepCountingHillClimbing">
<title>Step Counting Hill Climbing</title>
<section xml:id="stepCountingHillClimbingAlgorithm">
<title>Algorithm Description</title>
<simpara>Step Counting Hill Climbing also evaluates only a few moves per step.
For a number of steps, it keeps the step score as a threshold.
A move is accepted if it does not decrease the score, or if it leads to a score that is at least the threshold score.</simpara>
<simpara>Scientific paper: <link xlink:href="https://www.cs.nott.ac.uk/~yxb/SCHC/SCHC_mista2013_79.pdf">An initial study of a novel Step Counting Hill Climbing heuristic applied to timetabling problems by Yuri Bykov, Sanja Petrovic (2013)</link></simpara>
</section>
<section xml:id="stepCountingHillClimbingConfiguration">
<title>Configuration</title>
<simpara>Step Counting Hill Climbing accepts any move that has a score which is higher than a threshold score.
Every number of steps (specified by <literal>stepCountingHillClimbingSize</literal>), the threshold score is set to the step score.</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;stepCountingHillClimbingSize&gt;400&lt;/stepCountingHillClimbingSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1&lt;/acceptedCountLimit&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>Step Counting Hill Climbing should use a low <literal>acceptedCountLimit</literal>.</simpara>
<simpara>Step Counting Hill Climbing can be combined with a tabu acceptor at the same time, similar as shown in <link linkend="lateAcceptance">the Late Acceptance section</link>.</simpara>
</section>
</section>
<section xml:id="strategicOscillation">
<title>Strategic Oscillation</title>
<section xml:id="strategicOscillationAlgorithm">
<title>Algorithm Description</title>
<simpara>Strategic Oscillation is an add-on, which works especially well with <link linkend="tabuSearch">Tabu Search</link>.
Instead of picking the accepted move with the highest score, it employs a different mechanism: If there’s an improving move, it picks it.
If there’s no improving move however, it prefers moves which improve a softer score level, over moves which break a harder score level less.</simpara>
</section>
<section xml:id="strategicOscillationConfiguration">
<title>Configuration</title>
<simpara>Configure a <literal>finalistPodiumType</literal>, for example in a Tabu Search configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;localSearch&gt;
    ...
    &lt;acceptor&gt;
      &lt;entityTabuSize&gt;7&lt;/entityTabuSize&gt;
    &lt;/acceptor&gt;
    &lt;forager&gt;
      &lt;acceptedCountLimit&gt;1000&lt;/acceptedCountLimit&gt;
      &lt;finalistPodiumType&gt;STRATEGIC_OSCILLATION&lt;/finalistPodiumType&gt;
    &lt;/forager&gt;
  &lt;/localSearch&gt;</programlisting>
<simpara>The following <literal>finalistPodiumType</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>HIGHEST_SCORE</literal> (default): Pick the accepted move with the highest score.</simpara>
</listitem>
<listitem>
<simpara><literal>STRATEGIC_OSCILLATION</literal>: Alias for the default strategic oscillation variant.</simpara>
</listitem>
<listitem>
<simpara><literal>STRATEGIC_OSCILLATION_BY_LEVEL</literal>: If there is an accepted improving move, pick it. If no such move exists, prefer an accepted move which improves a softer score level over one that doesn’t (even if it has a better harder score level). A move is improving if it’s better than the last completed step score.</simpara>
</listitem>
<listitem>
<simpara><literal>STRATEGIC_OSCILLATION_BY_LEVEL_ON_BEST_SCORE</literal>: Like <literal>STRATEGIC_OSCILLATION_BY_LEVEL</literal>, but define improving as better than the best score (instead of the last completed step score).</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="customTerminationSelectorOrAcceptor">
<title>Using a Custom Termination, MoveSelector, EntitySelector, ValueSelector or Acceptor</title>
<simpara>You can plug in a custom <literal>Termination</literal>, <literal>MoveSelector</literal>, <literal>EntitySelector</literal>, <literal>ValueSelector</literal> or <literal>Acceptor</literal> by extending the abstract class and also the related <literal>\*Config</literal> class.</simpara>
<simpara>For example, to use a custom <literal>MoveSelector</literal>, extend the <literal>AbstractMoveSelector</literal> class, extend the <literal>MoveSelectorConfig</literal> class and configure it in the solver configuration.</simpara>
<note>
<simpara>It’s not possible to inject a <literal>Termination</literal>, …​ instance directly (to avoid extending a <literal>Config</literal> class too) because:</simpara>
<itemizedlist>
<listitem>
<simpara>A <literal>SolverFactory</literal> can build multiple <literal>Solver</literal> instances, which each require a distinct <literal>Termination</literal>, …​ instance.</simpara>
</listitem>
<listitem>
<simpara>A solver configuration needs to be serializable to and from XML. This makes benchmarking with <literal>PlannerBenchmark</literal> particularly easy because you can configure different <literal>Solver</literal> variants in XML.</simpara>
</listitem>
<listitem>
<simpara>A <literal>Config</literal> class is often easier and clearer to configure. For example: <literal>TerminationConfig</literal> translates <literal>minutesSpentLimit</literal> and <literal>secondsSpentLimit</literal> into <literal>timeMillisSpentLimit</literal>.</simpara>
</listitem>
</itemizedlist>
</note>
<simpara>If you build a better implementation that’s not domain specific, consider contributing it back as a pull request on github: we’ll optimize it and take it along in future refactorings.</simpara>
</section>
</chapter>
<chapter xml:id="evolutionaryAlgorithms">
<title>Evolutionary Algorithms</title>
<section xml:id="evolutionaryAlgorithmsOverview">
<title>Overview</title>
<simpara>Evolutionary Algorithms work on a population of solutions and evolve that population.</simpara>
</section>
<section xml:id="evolutionaryStrategies">
<title>Evolutionary Strategies</title>
<simpara>This algorithm has not been implemented yet.</simpara>
</section>
<section xml:id="geneticAlgorithms">
<title>Genetic Algorithms</title>
<simpara>This algorithm has not been implemented yet.</simpara>
<note>
<simpara>A good Genetic Algorithms prototype in Planner was written some time ago, but it wasn’t practical to merge and support it at the time.
The results of Genetic Algorithms were consistently and seriously inferior to all the <link linkend="localSearch">Local Search</link> variants (except Hill Climbing) on all use cases tried.
Nevertheless, a future version of Planner will add support for Genetic Algorithms, so you can easily benchmark Genetic Algorithms on your use case too.</simpara>
</note>
</section>
</chapter>
<chapter xml:id="hyperheuristics">
<title>Hyperheuristics</title>
<section xml:id="hyperheuristicsOverview">
<title>Overview</title>
<simpara>A hyperheuristic automates the decision which heuristic(s) to use on a specific data set.</simpara>
<simpara>A future version of Planner will have native support for hyperheuristics.
Meanwhile, it’s pretty easy to implement it yourself: Based on the size or difficulty of a data set (which is a criterion), use a different <literal>Solver</literal> configuration (or adjust the default configuration using the Solver configuration API). The <link linkend="benchmarker">Benchmarker</link> can help to identify such criteria.</simpara>
</section>
</chapter>
<chapter xml:id="partitionedSearch">
<title>Partitioned Search</title>
<section xml:id="partitionedSearchAlgorithm">
<title>Algorithm Description</title>
<simpara>It is often more efficient to partition large data sets (usually above 5000 planning entities)
into smaller pieces and solve them separately.
Partition Search is <link linkend="multiThreadedSolving">multi-threaded</link>, so it provides a performance boost on multi-core machines
due to higher CPU utilization.
Additionally, even when only using one CPU, it finds an initial solution faster,
because the search space sum of a partitioned Construction Heuristic is far less than its non-partitioned variant.</simpara>
<simpara>However, <emphasis role="strong">partitioning does lead to suboptimal results</emphasis>, even if the pieces are solved optimally, as shown below:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PartitionedSearch/mapReduceIsTerribleForTsp.png" align="center"/>
</imageobject>
<textobject><phrase>mapReduceIsTerribleForTsp</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>It effectively trades a short term gain in solution quality for long term loss.
One way to compensate for this loss,
is to run a non-partitioned Local Search after the Partitioned Search phase.</simpara>
<note>
<simpara>Not all use cases can be partitioned.
It only works on use cases for which the planning entities and value ranges can be split into n partition,
such that none of the constraints cross the boundaries between partitions.
Partitioning only works for use cases where the planning entities and value ranges can be split into n partitions,
without any of the constraints crossing boundaries between partitions.</simpara>
</note>
</section>
<section xml:id="partitionedSearchConfiguration">
<title>Configuration</title>
<simpara>Simplest configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;partitionedSearch&gt;
    &lt;solutionPartitionerClass&gt;org.optaplanner.examples.cloudbalancing.optional.partitioner.CloudBalancePartitioner&lt;/solutionPartitionerClass&gt;
  &lt;/partitionedSearch&gt;</programlisting>
<simpara>There are several ways to <link linkend="partitioningASolution">partition a solution</link>.</simpara>
<simpara>Advanced configuration:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;partitionedSearch&gt;
    ...
    &lt;solutionPartitionerClass&gt;org.optaplanner.examples.cloudbalancing.optional.partitioner.CloudBalancePartitioner&lt;/solutionPartitionerClass&gt;
    &lt;threadFactoryClass&gt;...MyAppServerThreadFactory&lt;/threadFactoryClass&gt;
    &lt;runnablePartThreadLimit&gt;4&lt;/runnablePartThreadLimit&gt;

    &lt;constructionHeuristic&gt;...&lt;/constructionHeuristic&gt;
    &lt;localSearch&gt;...&lt;/localSearch&gt;
  &lt;/partitionedSearch&gt;</programlisting>
<simpara>The <literal>threadFactoryClass</literal> allows to plug in a custom <literal>ThreadFactory</literal> for environments
where arbitrary thread creation should be avoided, such as most application servers, Android, or Google App Engine.</simpara>
<simpara>The <literal>runnablePartThreadLimit</literal> allows limiting CPU usage to avoid hanging your machine, see below.</simpara>
<important>
<simpara>A <link linkend="logging">logging level</link> of <literal>debug</literal> or <literal>trace</literal> causes congestion in multi-threaded Partitioned Search
and slows down the <link linkend="scoreCalculationSpeed">score calculation speed</link>.</simpara>
</important>
<simpara>Just like a <literal>&lt;solver&gt;</literal> element, the <literal>&lt;partitionedSearch&gt;</literal> element can contain one or more <link linkend="solverPhase">phases</link>.
Each of those phases will be run on each partition.</simpara>
<simpara>A common configuration is to first run a Partitioned Search phase
(which includes a Construction Heuristic and a Local Search)
followed by a non-partitioned Local Search phase:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;partitionedSearch&gt;
    &lt;solutionPartitionerClass&gt;...CloudBalancePartitioner&lt;/solutionPartitionerClass&gt;

    &lt;constructionHeuristic/&gt;
    &lt;localSearch&gt;
      &lt;secondsSpentLimit&gt;60&lt;/secondsSpentLimit&gt;
    &lt;/localSearch&gt;
  &lt;/partitionedSearch&gt;
  &lt;localSearch/&gt;</programlisting>
</section>
<section xml:id="partitioningASolution">
<title>Partitioning a Solution</title>
<section xml:id="customSolutionPartitioner">
<title>Custom SolutionPartitioner</title>
<simpara>To use a custom <literal>SolutionPartitioner</literal>, configure one on the Partitioned Search phase:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;partitionedSearch&gt;
    &lt;solutionPartitionerClass&gt;org.optaplanner.examples.cloudbalancing.optional.partitioner.CloudBalancePartitioner&lt;/solutionPartitionerClass&gt;
  &lt;/partitionedSearch&gt;</programlisting>
<simpara>Implement the <literal>SolutionPartitioner</literal> interface:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SolutionPartitioner&lt;Solution_&gt; {

    List&lt;Solution_&gt; splitWorkingSolution(ScoreDirector&lt;Solution_&gt; scoreDirector, Integer runnablePartThreadLimit);

}</programlisting>
<simpara>The <literal>size()</literal> of the returned <literal>List</literal> is the <literal>partCount</literal> (the number of partitions).
This can be decided dynamically, for example, based on the size of the non-partitioned solution.
The <literal>partCount</literal> is unrelated to the <literal>runnablePartThreadLimit</literal>.</simpara>
<simpara>For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CloudBalancePartitioner implements SolutionPartitioner&lt;CloudBalance&gt; {

    private int partCount = 4;
    private int minimumProcessListSize = 75;

    @Override
    public List&lt;CloudBalance&gt; splitWorkingSolution(ScoreDirector&lt;CloudBalance&gt; scoreDirector, Integer runnablePartThreadLimit) {
        CloudBalance originalSolution = scoreDirector.getWorkingSolution();
        List&lt;CloudComputer&gt; originalComputerList = originalSolution.getComputerList();
        List&lt;CloudProcess&gt; originalProcessList = originalSolution.getProcessList();
        int partCount = this.partCount;
        if (originalProcessList.size() / partCount &lt; minimumProcessListSize) {
            partCount = originalProcessList.size() / minimumProcessListSize;
        }
        List&lt;CloudBalance&gt; partList = new ArrayList&lt;&gt;(partCount);
        for (int i = 0; i &lt; partCount; i++) {
            CloudBalance partSolution = new CloudBalance(originalSolution.getId(),
                    new ArrayList&lt;&gt;(originalComputerList.size() / partCount + 1),
                    new ArrayList&lt;&gt;(originalProcessList.size() / partCount + 1));
            partList.add(partSolution);
        }

        int partIndex = 0;
        Map&lt;Long, Pair&lt;Integer, CloudComputer&gt;&gt; idToPartIndexAndComputerMap = new HashMap&lt;&gt;(originalComputerList.size());
        for (CloudComputer originalComputer : originalComputerList) {
            CloudBalance part = partList.get(partIndex);
            CloudComputer computer = new CloudComputer(
                    originalComputer.getId(),
                    originalComputer.getCpuPower(), originalComputer.getMemory(),
                    originalComputer.getNetworkBandwidth(), originalComputer.getCost());
            part.getComputerList().add(computer);
            idToPartIndexAndComputerMap.put(computer.getId(), Pair.of(partIndex, computer));
            partIndex = (partIndex + 1) % partList.size();
        }

        partIndex = 0;
        for (CloudProcess originalProcess : originalProcessList) {
            CloudBalance part = partList.get(partIndex);
            CloudProcess process = new CloudProcess(
                    originalProcess.getId(),
                    originalProcess.getRequiredCpuPower(), originalProcess.getRequiredMemory(),
                    originalProcess.getRequiredNetworkBandwidth());
            part.getProcessList().add(process);
            if (originalProcess.getComputer() != null) {
                Pair&lt;Integer, CloudComputer&gt; partIndexAndComputer = idToPartIndexAndComputerMap.get(
                        originalProcess.getComputer().getId());
                if (partIndexAndComputer == null) {
                    throw new IllegalStateException("The initialized process (" + originalProcess
                            + ") has a computer (" + originalProcess.getComputer()
                            + ") which doesn't exist in the originalSolution (" + originalSolution + ").");
                }
                if (partIndex != partIndexAndComputer.getLeft().intValue()) {
                    throw new IllegalStateException("The initialized process (" + originalProcess
                            + ") with partIndex (" + partIndex
                            + ") has a computer (" + originalProcess.getComputer()
                            + ") which belongs to another partIndex (" + partIndexAndComputer.getLeft() + ").");
                }
                process.setComputer(partIndexAndComputer.getRight());
            }
            partIndex = (partIndex + 1) % partList.size();
        }
        return partList;
    }

}</programlisting>
<simpara>To configure values of a <literal>SolutionPartitioner</literal> dynamically in the solver configuration
(so the <link linkend="benchmarker">Benchmarker</link> can tweak those parameters), use the <literal>solutionPartitionerCustomProperties</literal> element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;partitionedSearch&gt;
    &lt;solutionPartitionerClass&gt;...CloudBalancePartitioner&lt;/solutionPartitionerClass&gt;
    &lt;solutionPartitionerCustomProperties&gt;
      &lt;partCount&gt;8&lt;/partCount&gt;
      &lt;minimumProcessListSize&gt;100&lt;/minimumProcessListSize&gt;
    &lt;/solutionPartitionerCustomProperties&gt;
  &lt;/partitionedSearch&gt;</programlisting>
<simpara>Then add a public setter for each custom property, which is called when a <literal>Solver</literal> is build.
Most value types are supported (including boolean, integers, doubles and strings).</simpara>
<programlisting language="java" linenumbering="unnumbered">public class CloudBalancePartitioner implements SolutionPartitioner&lt;CloudBalance&gt; {

    private int partCount = 4;
    private int minimumProcessListSize = 25;

    @SuppressWarnings("unused")
    public void setPartCount(int partCount) {
        this.partCount = partCount;
    }

    @SuppressWarnings("unused")
    public void setMinimumProcessListSize(int minimumProcessListSize) {
        this.minimumProcessListSize = minimumProcessListSize;
    }

    ...
}</programlisting>
</section>
</section>
<section xml:id="runnablePartThreadLimit">
<title>Runnable Part Thread Limit</title>
<simpara>When running a multi-threaded solver, such as Partitioned Search, CPU power can quickly become a scarce resource,
which can cause other processes or threads to hang or freeze.
However, Planner has a system to prevent CPU starving of
other processes (such as an SSH connection in production or your IDE in development)
or other threads (such as the servlet threads that handle REST requests).</simpara>
<simpara>As explained in <link linkend="sizingHardwareAndSoftware">sizing hardware and software</link>,
each solver (including each child solver) does no IO during <literal>solve()</literal> and therefore saturates one CPU core completely.
In Partitioned Search, every partition always has its own thread, called a part thread.
It is impossible for two partitions to share a thread,
because of <link linkend="asynchronousTermination">asynchronous termination</link>: the second thread would never run.
Every part thread will try to consume one CPU core entirely, so if there are more partitions than CPU cores,
this will probably hang the system.
<literal>Thread.setPriority()</literal> is often too weak to solve this hogging problem, so another approach is used.</simpara>
<simpara>The <literal>runnablePartThreadLimit</literal> parameter specifies how many part threads are runnable at the same time.
The other part threads will temporarily block and therefore will not consume any CPU power.
<emphasis role="strong">This parameter basically specifies how many CPU cores are donated to Planner.</emphasis>
All part threads share the CPU cores in a round-robin manner
to consume (more or less) the same number of CPU cycles:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/PartitionedSearch/partitionedSearchThreading.png" align="center"/>
</imageobject>
<textobject><phrase>partitionedSearchThreading</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The following <literal>runnablePartThreadLimit</literal> options are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>UNLIMITED</literal>: Allow Planner to occupy all CPU cores, do not avoid hogging.
Useful if a no hogging CPU policy is configured on the OS level.</simpara>
</listitem>
<listitem>
<simpara><literal>AUTO</literal> (default): Let Planner decide how many CPU cores to occupy. This formula is based on experience.
It does not hog all CPU cores on a multi-core machine.</simpara>
</listitem>
<listitem>
<simpara>Static number: The number of CPU cores to consume. For example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;runnablePartThreadLimit&gt;2&lt;/runnablePartThreadLimit&gt;</programlisting>
</listitem>
<listitem>
<simpara>JavaScript formula: Formula for the number of CPU cores to occupy.
It can use the variable <literal>availableProcessorCount</literal>. For example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;runnablePartThreadLimit&gt;availableProcessorCount - 2&lt;/runnablePartThreadLimit&gt;</programlisting>
</listitem>
</itemizedlist>
<warning>
<simpara>If the <literal>runnablePartThreadLimit</literal> is equal to or higher than the number of available processors,
the host is likely to hang or freeze,
unless there is an OS specific policy in place to avoid Planner from hogging all the CPU processors.</simpara>
</warning>
</section>
</chapter>
<chapter xml:id="benchmarker">
<title>Benchmarking And Tweaking</title>
<section xml:id="findTheBestSolverConfiguration">
<title>Find The Best <literal>Solver</literal> Configuration</title>
<simpara>Planner supports several optimization algorithms, so you’re probably wondering which is the best one?
Although some optimization algorithms generally perform better than others, it really depends on your problem domain.
Most solver phases have parameters which can be tweaked.
Those parameters can influence the results a lot, even though most solver phases work pretty well out-of-the-box.</simpara>
<simpara>Luckily, Planner includes a benchmarker, which allows you to play out different solver phases with different settings
against each other in development, so you can use the best configuration for your planning problem in production.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/benchmarkOverview.png" align="center"/>
</imageobject>
<textobject><phrase>benchmarkOverview</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="benchmarkConfiguration">
<title>Benchmark Configuration</title>
<section xml:id="addADependencyOnBenchmarkJar">
<title>Add a Dependency on <literal>optaplanner-benchmark</literal></title>
<simpara>The benchmarker is in a separate artifact called <literal>optaplanner-benchmark</literal>.</simpara>
<simpara>If you use Maven, add a dependency in your <literal>pom.xml</literal> file:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;dependency&gt;
      &lt;groupId&gt;org.optaplanner&lt;/groupId&gt;
      &lt;artifactId&gt;optaplanner-benchmark&lt;/artifactId&gt;
    &lt;/dependency&gt;</programlisting>
<simpara>This is similar for Gradle, Ivy and Buildr.
The version must be exactly the same as the <literal>optaplanner-core</literal> version used (which is automatically the case if you import <literal>optaplanner-bom</literal>).</simpara>
<simpara>If you use ANT, you’ve probably already copied the required jars from the download zip’s <emphasis><phrase role="path">binaries</phrase></emphasis>
 directory.</simpara>
</section>
<section xml:id="runASimpleBenchmark">
<title>Run a Simple Benchmark</title>
<simpara>To quickly setup a benchmark, create a <literal>PlannerBenchmarkFactory</literal> from your <literal>SolverFactory</literal>,
load a few datasets and benchmark them. For example, with 3 datasets:</simpara>
<programlisting language="java" linenumbering="unnumbered">        SolverFactory&lt;CloudBalance&gt; solverFactory = SolverFactory.createFromXmlResource(...);
        PlannerBenchmarkFactory benchmarkFactory = PlannerBenchmarkFactory.createFromSolverFactory(solverFactory);

        CloudBalance dataset1 = ...;
        CloudBalance dataset2 = ...;
        CloudBalance dataset3 = ...;
        PlannerBenchmark plannerBenchmark = benchmarkFactory.buildPlannerBenchmark(dataset1, dataset2, dataset3);
        plannerBenchmark.benchmark();</programlisting>
<simpara>This will generate a benchmark report in <literal>local/benchmarkReport</literal>. Take a look.
To configure a different benchmark directory, pass a <literal>File</literal> parameter to <literal>createFromSolverFactory()</literal>.</simpara>
<simpara>The generated benchmark report already contains interesting information,
but it doesn’t allow comparing solver configurations to find the best algorithm.
To do that, set up an benchmark configuration:</simpara>
</section>
<section xml:id="buildAndRunAPlannerBenchmark">
<title>Configure and Run an Advanced Benchmark</title>
<simpara>Build a <literal>PlannerBenchmark</literal> instance with a <literal>PlannerBenchmarkFactory</literal>.
Configure it with a benchmark configuration XML file, provided as a classpath resource:</simpara>
<programlisting language="java" linenumbering="unnumbered">        PlannerBenchmarkFactory plannerBenchmarkFactory = PlannerBenchmarkFactory.createFromXmlResource(
                "org/optaplanner/examples/nqueens/benchmark/nqueensBenchmarkConfig.xml");
        PlannerBenchmark plannerBenchmark = plannerBenchmarkFactory.buildPlannerBenchmark();
        plannerBenchmark.benchmark();</programlisting>
<simpara>A benchmark configuration file looks like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plannerBenchmark&gt;
  &lt;benchmarkDirectory&gt;local/data/nqueens&lt;/benchmarkDirectory&gt;

  &lt;inheritedSolverBenchmark&gt;
    &lt;problemBenchmarks&gt;
      ...
      &lt;inputSolutionFile&gt;data/cloudbalancing/unsolved/100computers-300processes.xml&lt;/inputSolutionFile&gt;
      &lt;inputSolutionFile&gt;data/cloudbalancing/unsolved/200computers-600processes.xml&lt;/inputSolutionFile&gt;
    &lt;/problemBenchmarks&gt;
    &lt;solver&gt;
      ...&lt;!-- Common solver configuration --&gt;
    &lt;/solver&gt;
  &lt;/inheritedSolverBenchmark&gt;

  &lt;solverBenchmark&gt;
    &lt;name&gt;Tabu Search&lt;/name&gt;
    &lt;solver&gt;
      ...&lt;!-- Tabu Search specific solver configuration --&gt;
    &lt;/solver&gt;
  &lt;/solverBenchmark&gt;
  &lt;solverBenchmark&gt;
    &lt;name&gt;Simulated Annealing&lt;/name&gt;
    &lt;solver&gt;
      ...&lt;!-- Simulated Annealing specific solver configuration --&gt;
    &lt;/solver&gt;
  &lt;/solverBenchmark&gt;
  &lt;solverBenchmark&gt;
    &lt;name&gt;Late Acceptance&lt;/name&gt;
    &lt;solver&gt;
      ...&lt;!-- Late Acceptance specific solver configuration --&gt;
    &lt;/solver&gt;
  &lt;/solverBenchmark&gt;
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>This <literal>PlannerBenchmark</literal> will try three configurations (Tabu Search, Simulated Annealing and Late Acceptance)
on two data sets (<literal>100computers-300processes</literal> and <literal>200computers-600processes</literal>), so it will run six solvers.</simpara>
<simpara>Every <literal>&lt;solverBenchmark&gt;</literal> element contains a solver configuration and one or more <literal>&lt;inputSolutionFile&gt;</literal> elements.
It will run the solver configuration on each of those unsolved solution files.
The element <literal>name</literal> is optional, because it is generated if absent.
The <literal>inputSolutionFile</literal> is read by a <link linkend="solutionFileIO">SolutionFileIO</link> (relative to the working directory).</simpara>
<note>
<simpara>Use a forward slash (<literal>/</literal>) as the file separator (for example in the element <literal>&lt;inputSolutionFile&gt;</literal>). That will work on any platform (including Windows).</simpara>
<simpara>Do not use backslash (<literal>\</literal>) as the file separator: that breaks portability because it does not work on Linux and Mac.</simpara>
</note>
<simpara>The benchmark report will be written in the directory specified the <literal>&lt;benchmarkDirectory&gt;</literal> element (relative to the working directory).</simpara>
<note>
<simpara>It’s recommended that the <literal>benchmarkDirectory</literal> is a directory ignored for source control and not cleaned by your build system.
This way the generated files are not bloating your source control and they aren’t lost when doing a build.
For example in git, it should be added to <literal>.gitignore</literal>. Usually that directory is called <literal>local</literal>.</simpara>
</note>
<simpara>If an <literal>Exception</literal> or <literal>Error</literal> occurs in a single benchmark, the entire Benchmarker will not fail-fast (unlike everything else in Planner).
Instead, the Benchmarker will continue to run all other benchmarks, write the benchmark report and then fail (if there is at least one failing single benchmark).
The failing benchmarks will be clearly marked as such in the benchmark report.</simpara>
<section xml:id="inheritedSolverBenchmark">
<title>Inherited solver benchmark</title>
<simpara>To lower verbosity, the common parts of multiple <literal>&lt;solverBenchmark&gt;</literal> elements are extracted to the <literal>&lt;inheritedSolverBenchmark&gt;</literal> element.
Every property can still be overwritten per <literal>&lt;solverBenchmark&gt;</literal> element.
Note that inherited solver phases such as <literal>&lt;constructionHeuristic&gt;</literal> or <literal>&lt;localSearch&gt;</literal> are not overwritten
but instead are added to the tail of the solver phases list.</simpara>
</section>
</section>
<section xml:id="solutionFileIO">
<title>SolutionFileIO: Input And Output Of Solution Files</title>
<section xml:id="solutionFileIOInterface">
<title><literal>SolutionFileIO</literal> Interface</title>
<simpara>The benchmarker needs to be able to read the input files to load a <literal>Solution</literal>.
Also, it optionally writes the best <literal>Solution</literal> of each benchmark to an output file.
It does that through the <literal>SolutionFileIO</literal> interface which has a read and write method:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface SolutionFileIO&lt;Solution_&gt; {
    ...

    Solution_ read(File inputSolutionFile);
    void write(Solution_ solution, File outputSolutionFile);

}</programlisting>
<simpara>The <literal>SolutionFileIO</literal> interface is in the <literal>optaplanner-persistence-common</literal> jar (which is a dependency of the <literal>optaplanner-benchmark</literal> jar).
There are several ways to serialize a solution:</simpara>
</section>
<section xml:id="xStreamSolutionFileIO">
<title><literal>XStreamSolutionFileIO</literal>: Serialize To And From An XML Format</title>
<simpara>To use the <literal>XStreamSolutionFileIO</literal> instance to read and write solutions, just configure your <literal>Solution</literal> class as an <literal>xStreamAnnotatedClass</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      &lt;xStreamAnnotatedClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/xStreamAnnotatedClass&gt;
      &lt;inputSolutionFile&gt;data/nqueens/unsolved/32queens.xml&lt;/inputSolutionFile&gt;
      ...
    &lt;/problemBenchmarks&gt;</programlisting>
<simpara>Those input files need to have been written with a <literal>XStreamSolutionFileIO</literal> instance, not just any <literal>XStream</literal> instance,
because the <literal>XStreamSolutionFileIO</literal> uses a customized <literal>XStream</literal> instance.
Add XStream annotations (such as <literal>@XStreamAlias</literal>) on your domain classes to use a less verbose XML format.</simpara>
<warning>
<simpara>XML is a very verbose format.
Reading or writing large datasets in this format can cause an <literal>OutOfMemoryError</literal>, <literal>StackOverflowError</literal> or large performance degradation.</simpara>
</warning>
</section>
<section xml:id="customSolutionFileIO">
<title>Custom <literal>SolutionFileIO</literal>: Serialize To And From A Custom Format</title>
<simpara>Implement your own <literal>SolutionFileIO</literal> implementation and configure it with the <literal>solutionFileIOClass</literal> element to write to a custom format (such as a txt or a binary format):</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      &lt;solutionFileIOClass&gt;org.optaplanner.examples.machinereassignment.persistence.MachineReassignmentFileIO&lt;/solutionFileIOClass&gt;
      &lt;inputSolutionFile&gt;data/machinereassignment/import/model_a1_1.txt&lt;/inputSolutionFile&gt;
      ...
    &lt;/problemBenchmarks&gt;</programlisting>
<simpara>It’s recommended that output files can be read as input files,
which implies that <literal>getInputFileExtension()</literal> and <literal>getOutputFileExtension()</literal> return the same value.</simpara>
<warning>
<simpara>A <literal>SolutionFileIO</literal> implementation must be thread-safe.</simpara>
</warning>
</section>
<section xml:id="readingAnInputSolutionFromADatabase">
<title>Reading An Input Solution From A Database (Or Other Storage)</title>
<simpara>There are two options if your dataset is in a relational database or another type of repository:</simpara>
<itemizedlist>
<listitem>
<simpara>Extract the datasets from the database and serialize them to a local file (for example as XML with <literal>XStreamSolutionFileIO</literal> if XML isn’t too verbose).
Then use those files an <literal>&lt;inputSolutionFile&gt;</literal> elements.</simpara>
<itemizedlist>
<listitem>
<simpara>The benchmarks is now more reliable because they run offline.</simpara>
</listitem>
<listitem>
<simpara>Each dataset is only loaded just in time.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Load all the datasets in advance and pass them to the <literal>buildPlannerBenchmark()</literal> method:</simpara>
<programlisting language="java" linenumbering="unnumbered">        PlannerBenchmark plannerBenchmark = benchmarkFactory.buildPlannerBenchmark(dataset1, dataset2, dataset3);</programlisting>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="warmingUpTheHotSpotCompiler">
<title>Warming Up The HotSpot Compiler</title>
<simpara>Without a warm up, the results of the first (or first few) benchmarks are not reliable,
because they will lose CPU time on HotSpot JIT compilation (and possibly DRL compilation too).</simpara>
<simpara>To avoid that distortion, the benchmarker runs some of the benchmarks for 30 seconds,
before running the real benchmarks.
That default warm up of 30 seconds usually suffices. Change it, for example to give it 60 seconds:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;warmUpSecondsSpentLimit&gt;60&lt;/warmUpSecondsSpentLimit&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>Turn off the warm up phase altogether by setting it to zero:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;warmUpSecondsSpentLimit&gt;0&lt;/warmUpSecondsSpentLimit&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<note>
<simpara>The warm up time budget does not include the time it takes to load the datasets.
With large datasets, this can cause the warm up to run considerably longer than specified in the configuration.</simpara>
</note>
</section>
<section xml:id="benchmarkBlueprint">
<title>Benchmark Blueprint: A Predefined Configuration</title>
<simpara>To quickly configure and run a benchmark for typical solver configs, use a <literal>solverBenchmarkBluePrint</literal> instead of <literal>solverBenchmark</literal>s:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plannerBenchmark&gt;
  &lt;benchmarkDirectory&gt;local/data/nqueens&lt;/benchmarkDirectory&gt;

  &lt;inheritedSolverBenchmark&gt;
    &lt;problemBenchmarks&gt;
      &lt;xStreamAnnotatedClass&gt;org.optaplanner.examples.nqueens.domain.NQueens&lt;/xStreamAnnotatedClass&gt;
      &lt;inputSolutionFile&gt;data/nqueens/unsolved/32queens.xml&lt;/inputSolutionFile&gt;
      &lt;inputSolutionFile&gt;data/nqueens/unsolved/64queens.xml&lt;/inputSolutionFile&gt;
    &lt;/problemBenchmarks&gt;
    &lt;solver&gt;
      &lt;scanAnnotatedClasses/&gt;
      &lt;scoreDirectorFactory&gt;
        &lt;scoreDrl&gt;org/optaplanner/examples/nqueens/solver/nQueensScoreRules.drl&lt;/scoreDrl&gt;
        &lt;initializingScoreTrend&gt;ONLY_DOWN&lt;/initializingScoreTrend&gt;
      &lt;/scoreDirectorFactory&gt;
      &lt;termination&gt;
        &lt;minutesSpentLimit&gt;1&lt;/minutesSpentLimit&gt;
      &lt;/termination&gt;
    &lt;/solver&gt;
  &lt;/inheritedSolverBenchmark&gt;

  &lt;solverBenchmarkBluePrint&gt;
    &lt;solverBenchmarkBluePrintType&gt;EVERY_CONSTRUCTION_HEURISTIC_TYPE_WITH_EVERY_LOCAL_SEARCH_TYPE&lt;/solverBenchmarkBluePrintType&gt;
  &lt;/solverBenchmarkBluePrint&gt;
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>The following <literal>SolverBenchmarkBluePrintType</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>EVERY_CONSTRUCTION_HEURISTIC_TYPE</literal>: Run every Construction Heuristic type (First Fit, First Fit Decreasing, Cheapest Insertion, …​).</simpara>
</listitem>
<listitem>
<simpara><literal>EVERY_LOCAL_SEARCH_TYPE</literal>: Run every Local Search type (Tabu Search, Late Acceptance, …​) with the default Construction Heuristic.</simpara>
</listitem>
<listitem>
<simpara><literal>EVERY_CONSTRUCTION_HEURISTIC_TYPE_WITH_EVERY_LOCAL_SEARCH_TYPE</literal>: Run every Construction Heuristic type with every Local Search type.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="writeTheOutputSolutionOfBenchmarkRuns">
<title>Write The Output Solution Of Benchmark Runs</title>
<simpara>The best solution of each benchmark run can be written in the <literal>benchmarkDirectory</literal>.
By default, this is disabled, because the files are rarely used and considered bloat.
Also, on large datasets, writing the best solution of each single benchmark can take quite some time and memory (causing an <literal>OutOfMemoryError</literal>), especially in a verbose format like XStream XML.</simpara>
<simpara>To write those solutions in the <literal>benchmarkDirectory</literal>, enable <literal>writeOutputSolutionEnabled</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;writeOutputSolutionEnabled&gt;true&lt;/writeOutputSolutionEnabled&gt;
      ...
    &lt;/problemBenchmarks&gt;</programlisting>
</section>
<section xml:id="benchmarkLogging">
<title>Benchmark Logging</title>
<simpara>Benchmark logging is configured like <link linkend="logging">solver logging</link>.</simpara>
<simpara>To separate the log messages of each single benchmark run into a separate file, use the <link xlink:href="http://logback.qos.ch/manual/mdc.html">MDC</link> with key <literal>singleBenchmark.name</literal> in a sifting appender.
For example with Logback in <literal>logback.xml</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;appender name="fileAppender" class="ch.qos.logback.classic.sift.SiftingAppender"&gt;
    &lt;discriminator&gt;
      &lt;key&gt;singleBenchmark.name&lt;/key&gt;
      &lt;defaultValue&gt;app&lt;/defaultValue&gt;
    &lt;/discriminator&gt;
    &lt;sift&gt;
      &lt;appender name="fileAppender.${singleBenchmark.name}" class="...FileAppender"&gt;
        &lt;file&gt;local/log/optaplannerBenchmark-${singleBenchmark.name}.log&lt;/file&gt;
        ...
      &lt;/appender&gt;
    &lt;/sift&gt;
  &lt;/appender&gt;</programlisting>
</section>
</section>
<section xml:id="benchmarkReport">
<title>Benchmark Report</title>
<section xml:id="benchmarkHtmlReport">
<title>HTML Report</title>
<simpara>After running a benchmark, an HTML report will be written in the <literal>benchmarkDirectory</literal> with the <literal>index.html</literal> filename.
Open it in your browser.
It has a nice overview of your benchmark including:</simpara>
<itemizedlist>
<listitem>
<simpara>Summary statistics: graphs and tables</simpara>
</listitem>
<listitem>
<simpara>Problem statistics per <literal>inputSolutionFile</literal>: graphs and CSV</simpara>
</listitem>
<listitem>
<simpara>Each solver configuration (ranked): Handy to copy and paste</simpara>
</listitem>
<listitem>
<simpara>Benchmark information: settings, hardware, …​</simpara>
</listitem>
</itemizedlist>
<note>
<simpara>Graphs are generated by the excellent <link xlink:href="http://www.jfree.org/jfreechart/">JFreeChart</link> library.</simpara>
</note>
<simpara>The HTML report will use your default locale to format numbers.
If you share the benchmark report with people from another country, consider overwriting the <literal>locale</literal> accordingly:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;benchmarkReport&gt;
    &lt;locale&gt;en_US&lt;/locale&gt;
  &lt;/benchmarkReport&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
</section>
<section xml:id="rankingTheSolvers">
<title>Ranking The <literal>Solver</literal>s</title>
<simpara>The benchmark report automatically ranks the solvers.
The <literal>Solver</literal> with rank <literal>0</literal> is called the favorite <literal>Solver</literal>: it performs best overall, but it might not be the best on every problem.
It’s recommended to use that favorite <literal>Solver</literal> in production.</simpara>
<simpara>However, there are different ways of ranking the solvers.
Configure it like this:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;benchmarkReport&gt;
    &lt;solverRankingType&gt;TOTAL_SCORE&lt;/solverRankingType&gt;
  &lt;/benchmarkReport&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>The following <literal>solverRankingType</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>TOTAL_SCORE</literal> (default): Maximize the overall score, so minimize the overall cost if all solutions would be executed.</simpara>
</listitem>
<listitem>
<simpara><literal>WORST_SCORE</literal>: Minimize the worst case scenario.</simpara>
</listitem>
<listitem>
<simpara><literal>TOTAL_RANKING</literal>: Maximize the overall ranking. Use this if your datasets differ greatly in size or difficulty, producing a difference in <literal>Score</literal> magnitude.</simpara>
</listitem>
</itemizedlist>
<simpara><literal>Solver</literal>s with at least one failed single benchmark do not get a ranking.
<literal>Solver</literal>s with not fully initialized solutions are ranked worse.</simpara>
<simpara>To use a custom ranking, implement a <literal>Comparator</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;benchmarkReport&gt;
    &lt;solverRankingComparatorClass&gt;...TotalScoreSolverRankingComparator&lt;/solverRankingComparatorClass&gt;
  &lt;/benchmarkReport&gt;</programlisting>
<simpara>Or by implementing a weight factory:</simpara>
<programlisting language="xml" linenumbering="unnumbered">  &lt;benchmarkReport&gt;
    &lt;solverRankingWeightFactoryClass&gt;...TotalRankSolverRankingWeightFactory&lt;/solverRankingWeightFactoryClass&gt;
  &lt;/benchmarkReport&gt;</programlisting>
</section>
</section>
<section xml:id="benchmarkReportSummaryStatistics">
<title>Summary Statistics</title>
<section xml:id="benchmarkReportBestScoreSummary">
<title>Best Score Summary (Graph And Table)</title>
<simpara>Shows the best score per <literal>inputSolutionFile</literal> for each solver configuration.</simpara>
<simpara>Useful for visualizing the best solver configuration.</simpara>
<figure>
<title>Best Score Summary Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/bestScoreSummary.png" align="center"/>
</imageobject>
<textobject><phrase>bestScoreSummary</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="benchmarkReportBestScoreScalabilitySummary">
<title>Best Score Scalability Summary (Graph)</title>
<simpara>Shows the best score per problem scale for each solver configuration.</simpara>
<simpara>Useful for visualizing the scalability of each solver configuration.</simpara>
<note>
<simpara>The problem scale will report <literal>0</literal> if any <literal>@ValueRangeProvider</literal> method signature returns ValueRange (instead of <literal>CountableValueRange</literal> or <literal>Collection</literal>).</simpara>
</note>
</section>
<section xml:id="benchmarkReportBestScoreDistributionSummary">
<title>Best Score Distribution Summary (Graph)</title>
<simpara>Shows the best score distribution per <literal>inputSolutionFile</literal> for each solver configuration.</simpara>
<simpara>Useful for visualizing the reliability of each solver configuration.</simpara>
<figure>
<title>Best Score Distribution Summary Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/bestScoreDistributionSummary.png" align="center"/>
</imageobject>
<textobject><phrase>bestScoreDistributionSummary</phrase></textobject>
</mediaobject>
</figure>
<simpara>Enable <link linkend="statisticalBenchmarking">statistical benchmarking</link> to use this summary.</simpara>
</section>
<section xml:id="benchmarkReportWinningScoreDifferenceSummary">
<title>Winning Score Difference Summary (Graph And Table)</title>
<simpara>Shows the winning score difference per <literal>inputSolutionFile</literal> for each solver configuration.
The winning score difference is the score difference with the score of the winning solver configuration for that particular <literal>inputSolutionFile</literal>.</simpara>
<simpara>Useful for zooming in on the results of the best score summary.</simpara>
</section>
<section xml:id="benchmarkReportWorstScoreDifferencePercentageSummary">
<title>Worst Score Difference Percentage (ROI) Summary (Graph and Table)</title>
<simpara>Shows the return on investment (ROI) per <literal>inputSolutionFile</literal> for each solver configuration if you’d upgrade from the worst solver configuration for that particular <literal>inputSolutionFile</literal>.</simpara>
<simpara>Useful for visualizing the return on investment (ROI) to decision makers.</simpara>
</section>
<section xml:id="benchmarkReportScoreCalculationSpeedSummary">
<title>Score Calculation Speed Summary (Graph and Table)</title>
<simpara>Shows the score calculation speed: a count per second per problem scale for each solver configuration.</simpara>
<simpara>Useful for comparing different score calculators and/or score rule implementations (presuming that the solver configurations do not differ otherwise). Also useful to measure the scalability cost of an extra constraint.</simpara>
</section>
<section xml:id="benchmarkReportTimeSpentSummary">
<title>Time Spent Summary (Graph And Table)</title>
<simpara>Shows the time spent per <literal>inputSolutionFile</literal> for each solver configuration.
This is pointless if it’s benchmarking against a fixed time limit.</simpara>
<simpara>Useful for visualizing the performance of construction heuristics (presuming that no other solver phases are configured).</simpara>
</section>
<section xml:id="benchmarkReportTimeSpentScalabilitySummary">
<title>Time Spent Scalability Summary (Graph)</title>
<simpara>Shows the time spent per problem scale for each solver configuration.
This is pointless if it’s benchmarking against a fixed time limit.</simpara>
<simpara>Useful for extrapolating the scalability of construction heuristics (presuming that no other solver phases are configured).</simpara>
</section>
<section xml:id="benchmarkReportBestScorePerTimeSpentSummary">
<title>Best Score Per Time Spent Summary (Graph)</title>
<simpara>Shows the best score per time spent for each solver configuration.
This is pointless if it’s benchmarking against a fixed time limit.</simpara>
<simpara>Useful for visualizing trade-off between the best score versus the time spent for construction heuristics (presuming that no other solver phases are configured).</simpara>
</section>
</section>
<section xml:id="benchmarkReportStatisticPerDataset">
<title>Statistic Per Dataset (Graph And CSV)</title>
<section xml:id="enableAProblemStatistic">
<title>Enable A Problem Statistic</title>
<simpara>The benchmarker supports outputting problem statistics as graphs and CSV (comma separated values) files to the <literal>benchmarkDirectory</literal>.
To configure one or more, add a <literal>problemStatisticType</literal> line for each one:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  &lt;benchmarkDirectory&gt;local/data/nqueens/solved&lt;/benchmarkDirectory&gt;
  &lt;inheritedSolverBenchmark&gt;
    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;BEST_SCORE&lt;/problemStatisticType&gt;
      &lt;problemStatisticType&gt;SCORE_CALCULATION_SPEED&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;
    ...
  &lt;/inheritedSolverBenchmark&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<note>
<simpara>These problem statistics can slow down the solvers noticeably, which affects the benchmark results.
That’s why they are optional and only <literal>BEST_SCORE</literal> is enabled by default.
To disable that one too, use <literal>problemStatisticEnabled</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticEnabled&gt;false&lt;/problemStatisticEnabled&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<simpara>The summary statistics do not slow down the solver and are always generated.</simpara>
</note>
<simpara>The following types are supported:</simpara>
</section>
<section xml:id="benchmarkReportBestScoreOverTimeStatistic">
<title>Best Score Over Time Statistic (Graph And CSV)</title>
<simpara>Shows how the best score evolves over time. It is run by default.
To run it when other statistics are configured, also add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;BEST_SCORE&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Best Score Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/bestScoreStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>bestScoreStatistic</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>A time gradient based algorithm (such as Simulated Annealing) will have a different statistic if it’s run with a different time limit configuration.
That’s because this Simulated Annealing implementation automatically determines its velocity based on the amount of time that can be spent.
On the other hand, for the Tabu Search and Late Annealing, what you see is what you’d get.</simpara>
</note>
<simpara><emphasis role="strong">The best score over time statistic is very useful to detect abnormalities, such as a
potential <link linkend="scoreTrap">score trap</link> which gets the solver temporarily stuck in a local optima.</emphasis></simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/letTheBestScoreStatisticGuideYou.png" align="center"/>
</imageobject>
<textobject><phrase>letTheBestScoreStatisticGuideYou</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="benchmarkReportStepScoreOverTimeStatistic">
<title>Step Score Over Time Statistic (Graph And CSV)</title>
<simpara>To see how the step score evolves over time, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;STEP_SCORE&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Step Score Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/stepScoreStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>stepScoreStatistic</phrase></textobject>
</mediaobject>
</figure>
<simpara>Compare the step score statistic with the best score statistic (especially on parts for which the best score flatlines). If it hits a local optima, the solver should take deteriorating steps to escape it.
But it shouldn’t deteriorate too much either.</simpara>
<warning>
<simpara>The step score statistic has been seen to slow down the solver noticeably due to GC stress,
especially for fast stepping algorithms
(such as <link linkend="simulatedAnnealing">Simulated Annealing</link> and <link linkend="lateAcceptance">Late Acceptance</link>).</simpara>
</warning>
</section>
<section xml:id="benchmarkReportScoreCalculationSpeedtatistic">
<title>Score Calculation Speed Statistic (Graph And CSV)</title>
<simpara>To see how fast the scores are calculated, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;SCORE_CALCULATION_SPEED&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Score Calculation Speed Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/scoreCalculationSpeedStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>scoreCalculationSpeedStatistic</phrase></textobject>
</mediaobject>
</figure>
<note>
<simpara>The initial high calculation speed is typical during solution initialization: it’s far easier to calculate the score of a solution if only a handful planning entities have been initialized, than when all the planning entities are initialized.</simpara>
<simpara>After those few seconds of initialization, the calculation speed is relatively stable, apart from an occasional stop-the-world garbage collector disruption.</simpara>
</note>
</section>
<section xml:id="benchmarkReportBestSolutionMutationOverTimeStatistic">
<title>Best Solution Mutation Over Time Statistic (Graph And CSV)</title>
<simpara>To see how much each new best solution differs from the <emphasis>previous best solution</emphasis>, by counting the number of planning variables which have a different value (not including the variables that have changed multiple times but still end up with the same value), add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;BEST_SOLUTION_MUTATION&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Best Solution Mutation Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/bestSolutionMutationStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>bestSolutionMutationStatistic</phrase></textobject>
</mediaobject>
</figure>
<simpara>Use Tabu Search - an algorithm that behaves like a human - to get an estimation on how difficult it would be for a human to improve the previous best solution to that new best solution.</simpara>
</section>
<section xml:id="benchmarkReportMoveCountPerStepStatistic">
<title>Move Count Per Step Statistic (Graph And CSV)</title>
<simpara>To see how the selected and accepted move count per step evolves over time, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;MOVE_COUNT_PER_STEP&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Move Count Per Step Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/moveCountPerStepStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>moveCountPerStepStatistic</phrase></textobject>
</mediaobject>
</figure>
<warning>
<simpara>This statistic has been seen to slow down the solver noticeably due to GC stress, especially for fast stepping algorithms (such as Simulated Annealing and Late Acceptance).</simpara>
</warning>
</section>
<section xml:id="benchmarkReportMemoryUseStatistic">
<title>Memory Use Statistic (Graph And CSV)</title>
<simpara>To see how much memory is used, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;MEMORY_USE&lt;/problemStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Memory Use Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/memoryUseStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>memoryUseStatistic</phrase></textobject>
</mediaobject>
</figure>
<warning>
<simpara>The memory use statistic has been seen to affect the solver noticeably.</simpara>
</warning>
</section>
</section>
<section xml:id="benchmarkReportStatisticPerSingleBenchmark">
<title>Statistic Per Single Benchmark (Graph And CSV)</title>
<section xml:id="enableASingleStatistic">
<title>Enable A Single Statistic</title>
<simpara>A single statistic is a statics for one dataset for one solver configuration.
Unlike a problem statistic, it does not aggregate over solver configurations.</simpara>
<simpara>The benchmarker supports outputting single statistics as graphs and CSV (comma separated values) files to the <literal>benchmarkDirectory</literal>.
To configure one, add a <literal>singleStatisticType</literal> line:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  &lt;benchmarkDirectory&gt;local/data/nqueens/solved&lt;/benchmarkDirectory&gt;
  &lt;inheritedSolverBenchmark&gt;
    &lt;problemBenchmarks&gt;
      ...
      &lt;problemStatisticType&gt;...&lt;/problemStatisticType&gt;
      &lt;singleStatisticType&gt;PICKED_MOVE_TYPE_BEST_SCORE_DIFF&lt;/singleStatisticType&gt;
    &lt;/problemBenchmarks&gt;
    ...
  &lt;/inheritedSolverBenchmark&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>Multiple <literal>singleStatisticType</literal> elements are allowed.</simpara>
<note>
<simpara>These statistic per single benchmark can slow down the solver noticeably, which affects the benchmark results.
That’s why they are optional and not enabled by default.</simpara>
</note>
<simpara>The following types are supported:</simpara>
</section>
<section xml:id="benchmarkReportConstraintMatchTotalBestScoreOverTimeStatistic">
<title>Constraint Match Total Best Score Over Time Statistic (Graph And CSV)</title>
<simpara>To see which constraints are matched in the best score (and how much) over time, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;singleStatisticType&gt;CONSTRAINT_MATCH_TOTAL_BEST_SCORE&lt;/singleStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Constraint Match Total Best Score Diff Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/constraintMatchTotalBestScoreStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>constraintMatchTotalBestScoreStatistic</phrase></textobject>
</mediaobject>
</figure>
<simpara>Requires the score calculation to support <link linkend="explainingTheScore">constraint matches</link>.
<link linkend="droolsScoreCalculation">Drools score calculation</link> supports constraint matches automatically,
but <link linkend="incrementalJavaScoreCalculation">incremental Java score calculation</link> requires more work.</simpara>
<warning>
<simpara>The constraint match total statistics affect the solver noticeably.</simpara>
</warning>
</section>
<section xml:id="benchmarkReportConstraintMatchTotalStepScoreOverTimeStatistic">
<title>Constraint Match Total Step Score Over Time Statistic (Graph And CSV)</title>
<simpara>To see which constraints are matched in the step score (and how much) over time, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;singleStatisticType&gt;CONSTRAINT_MATCH_TOTAL_STEP_SCORE&lt;/singleStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Constraint Match Total Step Score Diff Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/constraintMatchTotalStepScoreStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>constraintMatchTotalStepScoreStatistic</phrase></textobject>
</mediaobject>
</figure>
<simpara>Also requires the score calculation to support <link linkend="explainingTheScore">constraint matches</link>.</simpara>
<warning>
<simpara>The constraint match total statistics affect the solver noticeably.</simpara>
</warning>
</section>
<section xml:id="benchmarkReportPickedMoveTypeBestScoreDiffOverTimeStatistic">
<title>Picked Move Type Best Score Diff Over Time Statistic (Graph And CSV)</title>
<simpara>To see which move types improve the best score (and how much) over time, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;singleStatisticType&gt;PICKED_MOVE_TYPE_BEST_SCORE_DIFF&lt;/singleStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Picked Move Type Best Score Diff Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/pickedMoveTypeBestScoreDiffStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>pickedMoveTypeBestScoreDiffStatistic</phrase></textobject>
</mediaobject>
</figure>
</section>
<section xml:id="benchmarkReportPickedMoveTypeStepScoreDiffOverTimeStatistic">
<title>Picked Move Type Step Score Diff Over Time Statistic (Graph And CSV)</title>
<simpara>To see how much each winning step affects the step score over time, add:</simpara>
<programlisting language="xml" linenumbering="unnumbered">    &lt;problemBenchmarks&gt;
      ...
      &lt;singleStatisticType&gt;PICKED_MOVE_TYPE_STEP_SCORE_DIFF&lt;/singleStatisticType&gt;
    &lt;/problemBenchmarks&gt;</programlisting>
<figure>
<title>Picked Move Type Step Score Diff Over Time Statistic</title>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/pickedMoveTypeStepScoreDiffStatistic.png" align="center"/>
</imageobject>
<textobject><phrase>pickedMoveTypeStepScoreDiffStatistic</phrase></textobject>
</mediaobject>
</figure>
</section>
</section>
<section xml:id="advancedBenchmarking">
<title>Advanced Benchmarking</title>
<section xml:id="benchmarkingPerformanceTricks">
<title>Benchmarking Performance Tricks</title>
<section xml:id="parallelBenchmarkingOnMultipleThreads">
<title>Parallel Benchmarking On Multiple Threads</title>
<simpara>If you have multiple processors available on your computer, you can run multiple benchmarks in parallel on multiple threads to get your benchmarks results faster:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;parallelBenchmarkCount&gt;AUTO&lt;/parallelBenchmarkCount&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<warning>
<simpara>Running too many benchmarks in parallel will affect the results of benchmarks negatively.
Leave some processors unused for garbage collection and other processes.</simpara>
</warning>
<simpara>The following <literal>parallelBenchmarkCount</literal>s are supported:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>1</literal> (default): Run all benchmarks sequentially.</simpara>
</listitem>
<listitem>
<simpara><literal>AUTO</literal>: Let Planner decide how many benchmarks to run in parallel. This formula is based on experience. It’s recommended to prefer this over the other parallel enabling options.</simpara>
</listitem>
<listitem>
<simpara>Static number: The number of benchmarks to run in parallel.</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;parallelBenchmarkCount&gt;2&lt;/parallelBenchmarkCount&gt;</programlisting>
</listitem>
<listitem>
<simpara>JavaScript formula: Formula for the number of benchmarks to run in parallel. It can use the variable <literal>availableProcessorCount</literal>. For example:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;parallelBenchmarkCount&gt;(availableProcessorCount / 2) + 1&lt;/parallelBenchmarkCount&gt;</programlisting>
</listitem>
</itemizedlist>
<note>
<simpara>The <literal>parallelBenchmarkCount</literal> is always limited to the number of available processors.
If it’s higher, it will be automatically decreased.</simpara>
</note>
<note>
<simpara>If you have a computer with slow or unreliable cooling, increasing the <literal>parallelBenchmarkCount</literal> above one (even on <literal>AUTO</literal>) may overheat your CPU.</simpara>
<simpara>The <literal>sensors</literal> command can help you detect if this is the case.
It is available in the package <literal>lm_sensors</literal> or <literal>lm-sensors</literal> in most Linux distributions.
There are several freeware tools available for Windows too.</simpara>
</note>
<simpara>The benchmarker uses a thread pool internally, but you can optionally plug in a custom <literal>ThreadFactory</literal>,
for example when running benchmarks on an application server or a cloud platform:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;threadFactoryClass&gt;...MyCustomThreadFactory&lt;/threadFactoryClass&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<note>
<simpara>In the future, we will also support multi-JVM benchmarking.
This feature is independent of <link xlink:href="https://issues.jboss.org/browse/PLANNER-76">multi-threaded solving</link> or multi-JVM solving.</simpara>
</note>
</section>
</section>
<section xml:id="statisticalBenchmarking">
<title>Statistical Benchmarking</title>
<simpara>To minimize the influence of your environment and the Random Number Generator on the benchmark results, configure the number of times each single benchmark run is repeated.
The results of those runs are statistically aggregated.
Each individual result is also visible in the report, as well as plotted in <link linkend="benchmarkReportBestScoreDistributionSummary">the best score distribution summary</link>.</simpara>
<simpara>Just add a <literal>&lt;subSingleCount&gt;</literal> element to an <link linkend="inheritedSolverBenchmark"><literal>&lt;inheritedSolverBenchmark&gt;</literal></link> element or in a <literal>&lt;solverBenchmark&gt;</literal> element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;plannerBenchmark&gt;
  ...
  &lt;inheritedSolverBenchmark&gt;
    ...
    &lt;solver&gt;
      ...
    &lt;/solver&gt;
    &lt;subSingleCount&gt;10&lt;subSingleCount&gt;
  &lt;/inheritedSolverBenchmark&gt;
  ...
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>The <literal>subSingleCount</literal> defaults to <literal>1</literal> (so no statistical benchmarking).</simpara>
<note>
<simpara>If <literal>subSingleCount</literal> is higher than <literal>1</literal>, the benchmarker will automatically use a <emphasis>different</emphasis><link linkend="randomNumberGenerator"><literal>Random</literal> seed</link> for every sub single run, without losing reproducibility (for each sub single index) in <link linkend="environmentMode">EnvironmentMode</link><literal>REPRODUCIBLE</literal> and lower.</simpara>
</note>
</section>
<section xml:id="templateBasedBenchmarking">
<title>Template Based Benchmarking And Matrix Benchmarking</title>
<simpara>Matrix benchmarking is benchmarking a combination of value sets.
For example: benchmark four <literal>entityTabuSize</literal> values (<literal>5</literal>, <literal>7</literal>, <literal>11</literal> and <literal>13</literal>) combined with three <literal>acceptedCountLimit</literal> values (<literal>500</literal>, <literal>1000</literal> and <literal>2000</literal>), resulting in 12 solver configurations.</simpara>
<simpara>To reduce the verbosity of such a benchmark configuration, you can use a <link xlink:href="http://freemarker.org//">Freemarker</link> template for the benchmark configuration instead:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;inheritedSolverBenchmark&gt;
    ...
  &lt;/inheritedSolverBenchmark&gt;

&lt;#list [5, 7, 11, 13] as entityTabuSize&gt;
&lt;#list [500, 1000, 2000] as acceptedCountLimit&gt;
  &lt;solverBenchmark&gt;
    &lt;name&gt;Tabu Search entityTabuSize ${entityTabuSize} acceptedCountLimit ${acceptedCountLimit}&lt;/name&gt;
    &lt;solver&gt;
      &lt;localSearch&gt;
        &lt;unionMoveSelector&gt;
          &lt;changeMoveSelector/&gt;
          &lt;swapMoveSelector/&gt;
        &lt;/unionMoveSelector&gt;
        &lt;acceptor&gt;
          &lt;entityTabuSize&gt;${entityTabuSize}&lt;/entityTabuSize&gt;
        &lt;/acceptor&gt;
        &lt;forager&gt;
          &lt;acceptedCountLimit&gt;${acceptedCountLimit}&lt;/acceptedCountLimit&gt;
        &lt;/forager&gt;
      &lt;/localSearch&gt;
    &lt;/solver&gt;
  &lt;/solverBenchmark&gt;
&lt;/#list&gt;
&lt;/#list&gt;
&lt;/plannerBenchmark&gt;</programlisting>
<simpara>To configure Matrix Benchmarking for Simulated Annealing (or any other configuration that involves a <literal>Score</literal> template variable), use the <literal>replace()</literal> method in the solver benchmark name element:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;plannerBenchmark&gt;
  ...
  &lt;inheritedSolverBenchmark&gt;
    ...
  &lt;/inheritedSolverBenchmark&gt;

&lt;#list ["1hard/10soft", "1hard/20soft", "1hard/50soft", "1hard/70soft"] as startingTemperature&gt;
  &lt;solverBenchmark&gt;
    &lt;name&gt;Simulated Annealing startingTemperature ${startingTemperature?replace("/", "_")}&lt;/name&gt;
    &lt;solver&gt;
      &lt;localSearch&gt;
        &lt;acceptor&gt;
          &lt;simulatedAnnealingStartingTemperature&gt;${startingTemperature}&lt;/simulatedAnnealingStartingTemperature&gt;
        &lt;/acceptor&gt;
      &lt;/localSearch&gt;
    &lt;/solver&gt;
  &lt;/solverBenchmark&gt;
&lt;/#list&gt;
&lt;/plannerBenchmark&gt;</programlisting>
<note>
<simpara>A solver benchmark name doesn’t allow some characters (such a <literal>/</literal>) because the name is also used a file name.</simpara>
</note>
<simpara>And build it with the class <literal>PlannerBenchmarkFactory</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">        PlannerBenchmarkFactory plannerBenchmarkFactory = PlannerBenchmarkFactory.createFromFreemarkerXmlResource(
                "org/optaplanner/examples/cloudbalancing/optional/benchmark/cloudBalancingBenchmarkConfigTemplate.xml.ftl");
        PlannerBenchmark plannerBenchmark = plannerBenchmarkFactory.buildPlannerBenchmark();</programlisting>
</section>
<section xml:id="benchmarkReportAggregation">
<title>Benchmark Report Aggregation</title>
<simpara>The <literal>BenchmarkAggregator</literal> takes one or more existing benchmarks and merges them into new benchmark report, without actually running the benchmarks again.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/BenchmarkingAndTweaking/benchmarkAggregator.png" align="center"/>
</imageobject>
<textobject><phrase>benchmarkAggregator</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>This is useful to:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Report on the impact of code changes</emphasis>: Run the same benchmark configuration before and after the code changes, then aggregate a report.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Report on the impact of dependency upgrades</emphasis>: Run the same benchmark configuration before and after upgrading the dependency, then aggregate a report.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Condense a too verbose report</emphasis>: Select only the interesting solver benchmarks from the existing report. This especially useful on template reports to make the graphs readable.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Partially rerun a benchmark</emphasis>: Rerun part of an existing report (for example only the failed or invalid solvers), then recreate the original intended report with the new values.</simpara>
</listitem>
</itemizedlist>
<simpara>To use it, provide a <literal>PlannerBenchmarkFactory</literal> to the <literal>BenchmarkAggregatorFrame</literal> to display the GUI:</simpara>
<programlisting language="java" linenumbering="unnumbered">    public static void main(String[] args) {
        PlannerBenchmarkFactory plannerBenchmarkFactory = PlannerBenchmarkFactory.createFromXmlResource(
                "org/optaplanner/examples/nqueens/benchmark/nqueensBenchmarkConfig.xml");
        BenchmarkAggregatorFrame.createAndDisplay(plannerBenchmarkFactory);
    }</programlisting>
<warning>
<simpara>Despite that it uses a benchmark configuration as input, it ignores all elements of that configuration, except for the elements <literal>&lt;benchmarkDirectory&gt;</literal> and <literal>&lt;benchmarkReport&gt;</literal>.</simpara>
</warning>
<simpara>In the GUI, select the interesting benchmarks and click the button to generate the report.</simpara>
<note>
<simpara>All the input reports which are being merged should have been generated with the same Planner version (excluding hotfix differences) as the <literal>BenchmarkAggregator</literal>.
Using reports from different Planner major or minor versions are not guaranteed to succeed and deliver correct information, because the benchmark report data structure often changes.</simpara>
</note>
</section>
</section>
</chapter>
<chapter xml:id="repeatedPlanning">
<title>Repeated Planning</title>
<section xml:id="introductionToRepeatedPlanning">
<title>Introduction to Repeated Planning</title>
<simpara>The problem facts used to create a solution may change before or during the execution of that solution. Delaying planning in order to lower the risk of problem facts changing is not ideal, as an incomplete plan is preferable to no plan.</simpara>
<simpara>The following examples demonstrate situations where planning solutions need to be altered due to unpredictable changes:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>Unforeseen fact changes</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>An employee assigned to a shift calls in sick.</simpara>
</listitem>
<listitem>
<simpara>An airplane scheduled to take off has a technical delay.</simpara>
</listitem>
<listitem>
<simpara>One of the machines or vehicles break down.</simpara>
<simpara>Unforeseen fact changes benefit from using <emphasis>backup planning</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis>Cannot assign all entities immediately</emphasis></simpara>
<simpara>Leave some unassigned. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>There are 10 shifts at the same time to assign but only nine employees to handle shifts.</simpara>
<simpara>For this type of planning, use <link linkend="overconstrainedPlanning"><emphasis>overconstrained planning</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis>Unknown long term future facts</emphasis></simpara>
<simpara>For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Hospital admissions for the next two weeks are reliable, but those for week three and four are less reliable, and for week five and beyond are not worth planning yet.</simpara>
<simpara>This problem benefits from <link linkend="continuousPlanning"><emphasis>continuous planning</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis>Constantly changing problem facts</emphasis></simpara>
<simpara>Use <link linkend="realTimePlanning"><emphasis>real-time planning</emphasis></link>.</simpara>
</listitem>
</itemizedlist>
<simpara>More CPU time results in a better planning solution.</simpara>
<simpara>Planner allows you to start planning earlier, despite unforeseen changes, as the optimization algorithms support planning a solution that has already been partially planned. This is known as repeated planning.</simpara>
</section>
<section xml:id="backupPlanning">
<title>Backup Planning</title>
<simpara>Backup planning adds extra score constraints to create space in the planning for when things go wrong. That creates a backup plan within the plan itself.</simpara>
<simpara>An example of backup planning is as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Create an extra score constraint. For example:</simpara>
<itemizedlist>
<listitem>
<simpara>Assign an employee as the spare employee (one for every 10 shifts at the same time).</simpara>
</listitem>
<listitem>
<simpara>Keep one hospital bed open in each department.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Change the planning problem when an unforeseen event occurs.</simpara>
<simpara>For example, if an employee calls in sick:</simpara>
<itemizedlist>
<listitem>
<simpara>Delete the sick employee and leave their shifts unassigned.</simpara>
</listitem>
<listitem>
<simpara>Restart the planning, starting from that solution, which now has a different score.</simpara>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>The construction heuristics fills in the newly created gaps (probably with the spare employee) and the metaheuristics will improve it even further.</simpara>
</section>
<section xml:id="overconstrainedPlanning">
<title>Overconstrained Planning</title>
<simpara>When there is no feasible solution to assign all planning entities, it is preferable to assign as many entities as possible without breaking hard constraints.
This is called overconstrained planning.</simpara>
<simpara>By default, Planner assigns all planning entities, overloads the planning values, and therefore breaks hard constraints.
There are two ways to avoid this:</simpara>
<itemizedlist>
<listitem>
<simpara>Use <link linkend="nullablePlanningVariable">nullable</link> planning variables, so that some entities are unassigned.</simpara>
</listitem>
<listitem>
<simpara>Add virtual values to catch the unassigned entities.</simpara>
</listitem>
</itemizedlist>
<section xml:id="overconstrainedPlanningWithNullableVariables">
<title>Overconstrained Planning with Nullable Variables</title>
<simpara>If we handle overconstrained planning with nullable variables, the overload entities will be left unassigned:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/RepeatedPlanning/overconstrainedPlanning.png" align="center"/>
</imageobject>
<textobject><phrase>overconstrainedPlanning</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>To implement this:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add an additional score level (usually a medium level between the hard and soft level) by switching <link linkend="scoreType"><literal>Score</literal> type</link>.</simpara>
</listitem>
<listitem>
<simpara>Make the planning variable <link linkend="nullablePlanningVariable">nullable</link>.</simpara>
</listitem>
<listitem>
<simpara>Add a score constraint on the new level (usually a medium constraint) to penalize the number of unassigned entities (or a weighted sum of them).</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="overconstrainedPlanningWithVirutalValues">
<title>Overconstrained Planning with Virtual Values</title>
<simpara>In overconstrained planning it is often useful to know which resources are lacking.
In overconstrained planning with virtual values, the solution indicates which resources to buy.</simpara>
<simpara>To implement this:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add an additional score level (usually a medium level between the hard and soft level) by switching <link linkend="scoreType"><literal>Score</literal> type</link>.</simpara>
</listitem>
<listitem>
<simpara>Add a number of virtual values. It can be difficult to determine a good formula to calculate that number:</simpara>
<itemizedlist>
<listitem>
<simpara>Do not add too many, as that will decrease solver efficiency.</simpara>
</listitem>
<listitem>
<simpara>Importantly, do not add too few as that will lead to an infeasible solution.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Add a score constraint on the new level (usually a medium constraint) to penalize the number of virtual assigned entities (or a weighted sum of them).</simpara>
</listitem>
<listitem>
<simpara>Optionally, change all soft constraints to ignore virtual assigned entities.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="continuousPlanning">
<title>Continuous Planning (Windowed Planning)</title>
<simpara>Continuous planning is the technique of planning one or more upcoming planning periods at the same time and repeating that process monthly, weekly, daily, hourly, or even more frequently.
However, as time is infinite, planning all future time periods is impossible.</simpara>
<simpara>A planning window allows you to have a fixed number of upcoming planning time periods.</simpara>
<simpara>The planning window can be split up in several parts:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis>History</emphasis></simpara>
<simpara>Immutable past time periods. It contains only immovable entities.</simpara>
<itemizedlist>
<listitem>
<simpara>Historic entities can also affect score constraints that apply to movable entities. For example, in nurse rostering, a nurse that has worked the last five historic days in a row should not be assigned on the first tentative day of the planning window, they will have worked too many consecutive days.</simpara>
</listitem>
<listitem>
<simpara>Do not load all historic entities in memory: even though immovable entities do not affect solving performance, they can cause out of memory problems when the data grows to years. Only load those that might still affect the current constraints with a good safety margin, for example load the past year.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis>Tentative</emphasis></simpara>
<simpara>The first few time periods that are being planned freely for the last time. After this planning, their planning entities become <link linkend="immovablePlanningEntities">immovable</link> or <link linkend="nonvolatileReplanning">semi-immovable</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>The result of the tentative planning is usually shared with the business. For example, in nurse rostering, the nurses will use this schedule to plan their personal lives. Changing that schedule later becomes disruptive, however, were exceptions force us to do so, disruption can be minimized (see <link linkend="nonvolatileReplanning">Nonvolatile Replanning</link>).</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis>Draft</emphasis></simpara>
<simpara>The latter time periods that are being planned freely, but not for the last time. They are likely to change again in the next planning effort.</simpara>
<itemizedlist>
<listitem>
<simpara>The draft part is needed to assure that the tentatively planned entities will allow room of a good, feasible planning afterwards.</simpara>
</listitem>
<listitem>
<simpara>That draft part is usually not shared with the business yet, because it is too volatile. However, it is stored in the database and used a starting point for the next plan.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis>Future</emphasis> (out of scope)</simpara>
<simpara>Planning entities that are not in the current planning window.</simpara>
<itemizedlist>
<listitem>
<simpara>If <link linkend="assigningTimeToPlanningEntities">time is a planning variable</link>, there is no future part. Instead, if the planning window is too small to plan all entities, see  <link linkend="overconstrainedPlanning">overconstrained planning</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/RepeatedPlanning/continuousPlanningEmployeeRostering.png" align="center"/>
</imageobject>
<textobject><phrase>continuousPlanningEmployeeRostering</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the employee rostering example above, we re-plan every four days.
Each time, we actually plan a window of 12 days, but we only share the tentative roster of the next four days with the employees.</simpara>
<note>
<simpara>The start of the planning window (so the first tentative time period) does <emphasis>not</emphasis> need to be now.
That too can be a week in advance.</simpara>
</note>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/RepeatedPlanning/continuousPlanningPatientAdmissionSchedule.png" align="center"/>
</imageobject>
<textobject><phrase>continuousPlanningPatientAdmissionSchedule</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the hospital bed planning example above, notice the difference between the original planning of November 1st and the new planning of November 5th: some problem facts (F, H, I, J, K) changed in the meantime, which results in unrelated planning entities (G) changing too.</simpara>
<section xml:id="immovablePlanningEntities">
<title>Immovable Planning Entities</title>
<simpara>To make some planning entities immovable, add an entity <literal>SelectionFilter</literal> that returns <literal>true</literal> if an entity is movable, and <literal>false</literal> if it is immovable.</simpara>
<simpara>The following procedure demonstrates how to do this using the nurse rostering example.</simpara>
<bridgehead xml:id="configuring_immovable_planning_entities" renderas="sect5" remap="_configuring_immovable_planning_entities">Configuring Immovable Planning Entities</bridgehead>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add the <literal>SelectionFilter</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">public class MovableShiftAssignmentSelectionFilter implements SelectionFilter&lt;NurseRoster, ShiftAssignment&gt; {

    @Override
    public boolean accept(ScoreDirector&lt;NurseRoster&gt; scoreDirector, ShiftAssignment shiftAssignment) {
        NurseRoster nurseRoster = scoreDirector.getWorkingSolution();
        ShiftDate shiftDate = shiftAssignment.getShift().getShiftDate();
        return nurseRoster.getNurseRosterInfo().isInPlanningWindow(shiftDate);
    }

}</programlisting>
</listitem>
<listitem>
<simpara>Configure the <literal>SelectionFilter</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity(movableEntitySelectionFilter = MovableShiftAssignmentSelectionFilter.class)
public class ShiftAssignment {
    ...
}</programlisting>
</listitem>
</orderedlist>
<warning>
<simpara>Custom <literal>MoveListFactory</literal> and <literal>MoveIteratorFactory</literal> implementations must ensure that they do not move immovable entities.</simpara>
</warning>
</section>
<section xml:id="nonvolatileReplanning">
<title>Nonvolatile Replanning to Minimize Disruption (Semi-movable Planning Entities)</title>
<simpara>Replanning an existing plan can be very disruptive. If the plan affects humans (such as employees, drivers, …​), very disruptive changes are often undesirable. In such cases, nonvolatile replanning helps by restricting planning freedom: the gain of changing a plan must be higher than the disruption it causes. This is usually implemented by taxing all planning entities that change.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/nonDisruptiveReplanning.png" align="center"/>
</imageobject>
<textobject><phrase>nonDisruptiveReplanning</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the machine reassignment example, the entity has both the planning variable <literal>machine</literal> and its original value <literal>originalMachine</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity(...)
public class ProcessAssignment {

    private MrProcess process;
    private Machine originalMachine;
    private Machine machine;

    public Machine getOriginalMachine() {...}

    @PlanningVariable(...)
    public Machine getMachine() {...}

    public boolean isMoved() {
        return originalMachine != null &amp;&amp; originalMachine != machine;
    }

    ...
}</programlisting>
<simpara>During planning, the planning variable <literal>machine</literal> changes.
By comparing it with the originalMachine, a change in plan can be penalized:</simpara>
<screen>rule "processMoved"
    when
        ProcessAssignment(moved == true)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -1000);
end</screen>
<simpara>The soft penalty of <literal>-1000</literal> means that a better solution is only accepted if it improves the soft score for at least <literal>1000</literal> points per variable changed (or if it improves the hard score).</simpara>
</section>
</section>
<section xml:id="realTimePlanning">
<title>Real-time Planning</title>
<simpara>To do real-time planning, combine the following planning techniques:</simpara>
<itemizedlist>
<listitem>
<simpara><link linkend="backupPlanning">Backup planning</link> - adding extra score constraints to allow for unforeseen changes).</simpara>
</listitem>
<listitem>
<simpara><link linkend="continuousPlanning">Continuous planning</link> - planning for one or more future planning periods.</simpara>
</listitem>
<listitem>
<simpara>Short planning windows.</simpara>
<simpara>This lowers the burden of real-time planning.</simpara>
</listitem>
</itemizedlist>
<simpara>As time passes, the problem itself changes. Consider the vehicle routing use case:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/RepeatedPlanning/realTimePlanningVehicleRouting.png" align="center"/>
</imageobject>
<textobject><phrase>realTimePlanningVehicleRouting</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the example above, three customers are added at different times (<literal>07:56</literal>, <literal>08:02</literal> and <literal>08:45</literal>), after the original customer set finished solving at <literal>07:55</literal>, and in some cases, after the vehicles already left.</simpara>
<simpara>Planner can handle such scenarios with <literal>ProblemFactChange</literal> (in combination with <link linkend="immovablePlanningEntities">immovable planning entities</link>).</simpara>
<section xml:id="problemFactChange">
<title>ProblemFactChange</title>
<simpara>While the <literal>Solver</literal> is solving, one of the problem facts may be changed by an outside event. For example, an airplane is delayed and needs the runway at a later time.</simpara>
<important>
<simpara>Do not change the problem fact instances used by the <literal>Solver</literal> while it is solving (from another thread or even in the same thread), as that will corrupt it.</simpara>
</important>
<simpara>Add a <literal>ProblemFactChange</literal> to the <literal>Solver</literal>, which it executes in the solver thread as soon as possible. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">public interface Solver&lt;Solution_&gt; {

    ...

    boolean addProblemFactChange(ProblemFactChange&lt;Solution_&gt; problemFactChange);

    boolean isEveryProblemFactChangeProcessed();

    ...

}</programlisting>
<programlisting language="java" linenumbering="unnumbered">public interface ProblemFactChange&lt;Solution_&gt; {

    void doChange(ScoreDirector&lt;Solution_&gt; scoreDirector);

}</programlisting>
<warning>
<simpara>The <literal>ScoreDirector</literal> must be updated with any change on the problem facts of planning entities in a <literal>ProblemFactChange</literal>.</simpara>
</warning>
<simpara>To write a <literal>ProblemFactChange</literal> correctly, it is important to understand the behavior of <link linkend="cloningASolution">a planning clone</link>.</simpara>
<simpara>A planning clone of a solution must fulfil these requirements:</simpara>
<itemizedlist>
<listitem>
<simpara>The clone must represent the same planning problem. Usually it reuses the same instances of the problem facts and problem fact collections as the original.</simpara>
</listitem>
<listitem>
<simpara>The clone must use different, cloned instances of the entities and entity collections. Changes to an original Solution entity’s variables must not affect its clone.</simpara>
</listitem>
</itemizedlist>
<section xml:id="problemFactChangeExample">
<title>Cloud Balancing ProblemFactChange Example</title>
<simpara>Consider the following example of a <literal>ProblemFactChange</literal> implementation in the cloud balancing use case:</simpara>
<programlisting language="java" linenumbering="unnumbered">    public void deleteComputer(final CloudComputer computer) {
        solver.addProblemFactChange(scoreDirector -&gt; {
            CloudBalance cloudBalance = scoreDirector.getWorkingSolution();
            CloudComputer workingComputer = scoreDirector.lookUpWorkingObject(computer);
            // First remove the problem fact from all planning entities that use it
            for (CloudProcess process : cloudBalance.getProcessList()) {
                if (process.getComputer() == workingComputer) {
                    scoreDirector.beforeVariableChanged(process, "computer");
                    process.setComputer(null);
                    scoreDirector.afterVariableChanged(process, "computer");
                }
            }
            // A SolutionCloner does not clone problem fact lists (such as computerList)
            // Shallow clone the computerList so only workingSolution is affected, not bestSolution or guiSolution
            ArrayList&lt;CloudComputer&gt; computerList = new ArrayList&lt;&gt;(cloudBalance.getComputerList());
            cloudBalance.setComputerList(computerList);
            // Remove the problem fact itself
            scoreDirector.beforeProblemFactRemoved(workingComputer);
            computerList.remove(workingComputer);
            scoreDirector.afterProblemFactRemoved(workingComputer);
            scoreDirector.triggerVariableListeners();
        });
    }</programlisting>
<orderedlist numeration="arabic">
<listitem>
<simpara>Any change in a <literal>ProblemFactChange</literal> must be done on the <literal>Solution</literal> instance of <literal>scoreDirector.getWorkingSolution()</literal>.</simpara>
</listitem>
<listitem>
<simpara>The <literal>workingSolution</literal> is <link linkend="cloningASolution">a planning clone</link> of the <literal>BestSolutionChangedEvent</literal>'s <literal>bestSolution</literal>.</simpara>
<itemizedlist>
<listitem>
<simpara>The <literal>workingSolution</literal> in the <literal>Solver</literal> is never the same instance as the <literal>Solution</literal> in the rest of your application: it is a planning clone.</simpara>
</listitem>
<listitem>
<simpara>A planning clone also clones the planning entities and planning entity collections.</simpara>
<simpara>So any change on the planning entities must happen on the instances held by <literal>scoreDirector.getWorkingSolution()</literal>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Use the method <literal>ScoreDirector.lookUpWorkingObject()</literal> to translate and retrieve the working solution’s instance of an object.</simpara>
</listitem>
<listitem>
<simpara>A planning clone does not clone the problem facts, nor the problem fact collections.
<emphasis>Therefore the <literal><emphasis>workingSolution</emphasis></literal> and the <literal><emphasis>bestSolution</emphasis></literal> share the same problem fact instances and the same problem fact list instances.</emphasis></simpara>
<simpara>Any problem fact or problem fact list changed by a <literal>ProblemFactChange</literal> must be problem cloned first (which can imply rerouting references in other problem facts and planning entities). Otherwise, if the <literal>workingSolution</literal> and <literal>bestSolution</literal> are used in different threads (for example a solver thread and a GUI event thread), a race condition can occur.</simpara>
</listitem>
</orderedlist>
</section>
<section xml:id="cloningSolutionsToAvoidRaceConditions">
<title>Cloning Solutions to Avoid Race Conditions in Real-time Planning</title>
<simpara>Many types of changes can leave a planning entity uninitialized, resulting in a partially initialized solution. This is acceptable, provided the first solver phase can handle it.</simpara>
<simpara>All construction heuristics solver phases can handle a partially initialized solution, so it is recommended to configure such a solver phase as the first phase.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/RepeatedPlanning/realTimePlanningConcurrencySequenceDiagram.png" align="center"/>
</imageobject>
<textobject><phrase>realTimePlanningConcurrencySequenceDiagram</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>The process occurs as follows:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>The <literal>Solver</literal> stops.</simpara>
</listitem>
<listitem>
<simpara>Runs the <literal>ProblemFactChange</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">restarts</emphasis>.</simpara>
<simpara>This is a <emphasis>warm start</emphasis> because its initial solution is the adjusted best solution of the previous run.</simpara>
</listitem>
<listitem>
<simpara>Each solver phase runs again.</simpara>
<simpara>This implies the construction heuristic runs again, but because little or no planning variables are uninitialized (unless you have a <link linkend="nullablePlanningVariable">nullable planning variable</link>), it finishes much quicker than in a cold start.</simpara>
</listitem>
<listitem>
<simpara>Each configured <literal>Termination</literal> resets (both in solver and phase configuration), but a previous call to <literal>terminateEarly()</literal> is not undone.</simpara>
<simpara><literal>Termination</literal> is not usually configured (except in daemon mode); instead, <literal>Solver.terminateEarly()</literal> is called when the results are needed. Alternatively, configure a <literal>Termination</literal> and use the daemon mode in combination with <literal><link linkend="SolverEventListener">BestSolutionChangedEvent</link></literal> as described in the following section.</simpara>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="daemon">
<title>Daemon: <literal>solve()</literal> Does Not Return</title>
<simpara>In real-time planning, it is often useful to have a solver thread wait when it runs out of work, and immediately resume solving a problem once new problem fact changes are added.
Putting the <literal>Solver</literal> in daemon mode has the following effects:</simpara>
<itemizedlist>
<listitem>
<simpara>If the <literal>Solver</literal>'s <literal>Termination</literal> terminates, it does not return from <literal>solve()</literal>, but blocks its thread instead (which frees up CPU power).</simpara>
<itemizedlist>
<listitem>
<simpara>Except for <literal>terminateEarly()</literal>, which does make it return from <literal>solve()</literal>, freeing up system resources and allowing an application to shutdown gracefully.</simpara>
</listitem>
<listitem>
<simpara>If a <literal>Solver</literal> starts with an empty planning entity collection, it waits in the blocked state immediately.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If a <literal>ProblemFactChange</literal> is added, it goes into the running state, applies the <literal>ProblemFactChange</literal> and runs the <literal>Solver</literal> again.</simpara>
</listitem>
</itemizedlist>
<simpara>To use the <literal>Solver</literal> in daemon mode:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Enable <literal>daemon</literal> mode on the <literal>Solver</literal>:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;solver&gt;
  &lt;daemon&gt;true&lt;/daemon&gt;
  ...
&lt;/solver&gt;</programlisting>
<warning>
<simpara>Do not forget to call <literal>Solver.terminateEarly()</literal> when your application needs to shutdown to avoid killing the solver thread unnaturally.</simpara>
</warning>
</listitem>
<listitem>
<simpara>Subscribe to the <literal><link linkend="SolverEventListener">BestSolutionChangedEvent</link></literal> to process new best solutions found by the solver thread.</simpara>
<simpara>A <literal>BestSolutionChangedEvent</literal> does not guarantee that every <literal>ProblemFactChange</literal> has been processed already, nor that the solution is initialized and feasible.</simpara>
</listitem>
<listitem>
<simpara>To ignore <literal>BestSolutionChangedEvent</literal>s with such invalid solutions, do the following:</simpara>
<programlisting language="java" linenumbering="unnumbered">    public void bestSolutionChanged(BestSolutionChangedEvent&lt;CloudBalance&gt; event) {
        if (event.isEveryProblemFactChangeProcessed()
                // Ignore infeasible (including uninitialized) solutions
                &amp;&amp; event.getNewBestSolution().getScore().isFeasible()) {
            ...
        }
    }</programlisting>
</listitem>
<listitem>
<simpara>Use <literal>Score.isSolutionInitialized()</literal> instead of <literal>Score.isFeasible()</literal> to only ignore uninitialized solutions, but do accept infeasible solutions too.</simpara>
</listitem>
</orderedlist>
</section>
</section>
</chapter>
<chapter xml:id="integration">
<title>Integration</title>
<section xml:id="integrationOverview">
<title>Overview</title>
<simpara>Planner’s input and output data (the planning problem and the best solution) are plain old JavaBeans (POJO’s), so integration with other Java technologies is straightforward.
For example:</simpara>
<itemizedlist>
<listitem>
<simpara>To read a planning problem from the database (and store the best solution in it), annotate the domain POJO’s with JPA annotations.</simpara>
</listitem>
<listitem>
<simpara>To read a planning problem from an XML file (and store the best solution in it), annotate the domain POJO’s with XStream or JAXB annotations.</simpara>
</listitem>
<listitem>
<simpara>To expose the Solver as a REST Service that reads the planning problem and responds with the best solution, annotate the domain POJO’s with XStream, JAXB or Jackson annotations and hook the <literal>Solver</literal> in Camel or RESTEasy.</simpara>
</listitem>
</itemizedlist>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/Integration/integrationOverview.png" align="center"/>
</imageobject>
<textobject><phrase>integrationOverview</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="integrationWithPersistentStorage">
<title>Persistent Storage</title>
<section xml:id="integrationWithJpaAndHibernate">
<title>Database: JPA and Hibernate</title>
<simpara>Enrich the domain POJO’s (solution, entities and problem facts) with JPA annotations
to store them in a database by calling <literal>EntityManager.persist()</literal>.</simpara>
<note>
<simpara>Do not confuse JPA’s <literal>@Entity</literal> annotation with Planner’s <literal>@PlanningEntity</literal> annotation.
They can appear both on the same class:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningEntity // OptaPlanner annotation
@Entity // JPA annotation
public class Talk {...}</programlisting>
</note>
<simpara>Add a dependency to the <literal>optaplanner-persistence-jpa</literal> jar to take advantage of these extra integration features:</simpara>
<section xml:id="jpaAndHibernatePersistingAScore">
<title>JPA and Hibernate: Persisting a <literal>Score</literal></title>
<simpara>When a <literal>Score</literal> is persisted into a relational database, JPA and Hibernate will default to Java serializing it to a <literal>BLOB</literal> column.
This has several disadvantages:</simpara>
<itemizedlist>
<listitem>
<simpara>The Java serialization format of <literal>Score</literal> classes is currently not backwards compatible. Upgrading to a newer Planner version can break reading an existing database.</simpara>
</listitem>
<listitem>
<simpara>The score is not easily readable for a query executed in the database console. This is annoying during development.</simpara>
</listitem>
<listitem>
<simpara>The score cannot be used in a SQL or JPA-QL query to efficiently filter the results: for example to query all infeasible schedules.</simpara>
</listitem>
</itemizedlist>
<simpara>To avoid these issues, configure it to instead use INTEGER (or other) columns, by using the appropriate <literal>*ScoreHibernateType</literal> for your <literal>Score</literal> type, for example for a <literal>HardSoftScore</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@Entity
@TypeDef(defaultForType = HardSoftScore.class, typeClass = HardSoftScoreHibernateType.class)
public class CloudBalance {

    @PlanningScore
    @Columns(columns = {@Column(name = "initScore"), @Column(name = "hardScore"), @Column(name = "softScore")})
    protected HardSoftScore score;

    ...
}</programlisting>
<note>
<simpara>Configure the same number of <literal>@Column</literal> annotations as the number of score levels in the score plus one (for the <literal>initScore</literal>), otherwise Hibernate will fail fast because a property mapping has the wrong number of columns.</simpara>
</note>
<simpara>In this case, the DDL will look like this:</simpara>
<programlisting language="sql" linenumbering="unnumbered">CREATE TABLE CloudBalance(
    ...
    initScore INTEGER,
    hardScore INTEGER,
    softScore INTEGER
);</programlisting>
<simpara>When using a <literal>BigDecimal</literal> based <literal>Score</literal>, specify the precision and scale of the columns to avoid silent rounding:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@Entity
@TypeDef(defaultForType = HardSoftBigDecimalScore.class, typeClass = HardSoftBigDecimalScoreHibernateType.class)
public class CloudBalance{

    @PlanningScore
    @Columns(columns = {
            @Column(name = "initScore")
            @Column(name = "hardScore", precision = 10, scale = 5),
            @Column(name = "softScore", precision = 10, scale = 5)})
    protected HardSoftBigDecimalScore score;

    ...
}</programlisting>
<simpara>In this case, the DDL will look like this:</simpara>
<programlisting language="sql" linenumbering="unnumbered">CREATE TABLE CloudBalance(
    ...
    initScore INTEGER,
    hardScore DECIMAL(10, 5),
    softScore DECIMAL(10, 5)
);</programlisting>
<simpara>When using any type of bendable <literal>Score</literal>, specify the hard and soft level sizes as parameters:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@Entity
@TypeDef(defaultForType = BendableScore.class, typeClass = BendableScoreHibernateType.class, parameters = {
        @Parameter(name = "hardLevelsSize", value = "3"),
        @Parameter(name = "softLevelsSize", value = "2")})
public class Schedule {

    @PlanningScore
    @Columns(columns = {
            @Column(name = "initScore")
            @Column(name = "hard0Score"),
            @Column(name = "hard1Score"),
            @Column(name = "hard2Score"),
            @Column(name = "soft0Score"),
            @Column(name = "soft1Score")})
    protected BendableScore score;

    ...
}</programlisting>
<simpara>All this support is Hibernate specific because currently JPA 2.1’s converters do not support converting to multiple columns.</simpara>
</section>
<section xml:id="jpaAndHibernatePlanningCloning">
<title>JPA and Hibernate: Planning Cloning</title>
<simpara>In JPA and Hibernate, there is usually a <literal>@ManyToOne</literal> relationship from most problem fact classes to the planning solution class.
Therefore, the problem fact classes reference the planning solution class, which implies that when the solution is <link linkend="cloningASolution">planning cloned</link>, they need to be cloned too.
Use an <literal>@DeepPlanningClone</literal> on each such problem fact class to enforce that:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution // OptaPlanner annotation
@Entity // JPA annotation
public class Conference {

    @OneToMany(mappedBy="conference")
    private List&lt;Room&gt; roomList;

    ...
}</programlisting>
<programlisting language="java" linenumbering="unnumbered">@DeepPlanningClone // OptaPlanner annotation: Force the default planning cloner to planning clone this class too
@Entity // JPA annotation
public class Room {

    @ManyToOne
    private Conference conference; // Because of this reference, this problem fact needs to be planning cloned too

}</programlisting>
<simpara>Neglecting to do this can lead to persisting duplicate solutions, JPA exceptions or other side effects.</simpara>
</section>
</section>
<section xml:id="integrationWithXStream">
<title>XML or JSON: XStream</title>
<simpara>Enrich the domain POJO’s (solution, entities and problem facts) with XStream annotations to serialize them to/from XML or JSON.</simpara>
<simpara>Add a dependency to the <literal>optaplanner-persistence-xstream</literal> jar to take advantage of these extra integration features:</simpara>
<section xml:id="xStreamMarshallingAScore">
<title>XStream: Marshalling a <literal>Score</literal></title>
<simpara>When a <literal>Score</literal> is marshalled to XML or JSON by the default XStream configuration, it’s verbose and ugly.
To fix that, configure the appropriate <literal>ScoreXStreamConverter</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@XStreamAlias("CloudBalance")
public class CloudBalance {

    @PlanningScore
    @XStreamConverter(HardSoftScoreXStreamConverter.class)
    private HardSoftScore score;

    ...
}</programlisting>
<simpara>For example, this will generate pretty XML:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;CloudBalance&gt;
   ...
   &lt;score&gt;0hard/-200soft&lt;/score&gt;
&lt;/CloudBalance&gt;</programlisting>
<simpara>The same applies for a bendable score:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@XStreamAlias("Schedule")
public class Schedule {

    @PlanningScore
    @XStreamConverter(BendableScoreXStreamConverter.class)
    private BendableScore score;

    ...
}</programlisting>
<simpara>For example, this will generate:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;Schedule&gt;
   ...
   &lt;score&gt;[0/0]hard/[-100/-20/-3]soft&lt;/score&gt;
&lt;/Schedule&gt;</programlisting>
<simpara>The <literal>hardLevelsSize</literal> and <literal>softLevelsSize</literal> implied, when reading a bendable score from an XML element, must always be in sync with those in the solver.</simpara>
</section>
</section>
<section xml:id="integrationWithJaxb">
<title>XML or JSON: JAXB</title>
<simpara>Enrich the domain POJO’s (solution, entities and problem facts) with JAXB annotations to serialize them to/from XML or JSON.</simpara>
<simpara>Add a dependency to the <literal>optaplanner-persistence-jaxb</literal> jar to take advantage of these extra integration features:</simpara>
<section xml:id="jaxbMarshallingAScore">
<title>JAXB: Marshalling a <literal>Score</literal></title>
<simpara>When a <literal>Score</literal> is marshalled to XML or JSON by the default JAXB configuration, it’s corrupted.
To fix that, configure the appropriate <literal>ScoreJaxbXmlAdapter</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@XmlRootElement @XmlAccessorType(XmlAccessType.FIELD)
public class CloudBalance {

    @PlanningScore
    @XmlJavaTypeAdapter(HardSoftScoreJaxbXmlAdapter.class)
    private HardSoftScore score;

    ...
}</programlisting>
<simpara>For example, this will generate pretty XML:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;cloudBalance&gt;
   ...
   &lt;score&gt;0hard/-200soft&lt;/score&gt;
&lt;/cloudBalance&gt;</programlisting>
<simpara>The same applies for a bendable score:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
@XmlRootElement @XmlAccessorType(XmlAccessType.FIELD)
public class Schedule {

    @PlanningScore
    @XmlJavaTypeAdapter(BendableScoreJaxbXmlAdapter.class)
    private BendableScore score;

    ...
}</programlisting>
<simpara>For example, with a <literal>hardLevelsSize</literal> of <literal>2</literal> and a <literal>softLevelsSize</literal> of <literal>3</literal>, that will generate:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;schedule&gt;
   ...
   &lt;score&gt;[0/0]hard/[-100/-20/-3]soft&lt;/score&gt;
&lt;/schedule&gt;</programlisting>
<simpara>The <literal>hardLevelsSize</literal> and <literal>softLevelsSize</literal> implied, when reading a bendable score from an XML element, must always be in sync with those in the solver.</simpara>
</section>
</section>
<section xml:id="integrationWithJackson">
<title>JSON: Jackson</title>
<simpara>Enrich the domain POJO’s (solution, entities and problem facts) with Jackson annotations to serialize them to/from JSON.</simpara>
<simpara>Add a dependency to the <literal>optaplanner-persistence-jackson</literal> jar to take advantage of these extra integration features:</simpara>
<section xml:id="jacksonMarshallingAScore">
<title>JAXB: Marshalling a <literal>Score</literal></title>
<simpara>When a <literal>Score</literal> is marshalled to JSON by the default Jackson configuration, it fails.
To fix that, configure a <literal>ScoreJacksonJsonSerializer</literal> and the appropriate <literal>ScoreJacksonJsonDeserializer</literal>:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class CloudBalance {

    @PlanningScore
    @JsonSerialize(using = ScoreJacksonJsonSerializer.class)
    @JsonDeserialize(using = HardSoftScoreJacksonJsonDeserializer.class)
    private HardSoftScore score;

    ...
}</programlisting>
<simpara>For example, this will generate pretty JSON:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
   ...
   "score":"0hard/-200soft"
}</programlisting>
<simpara>The same applies for a bendable score:</simpara>
<programlisting language="java" linenumbering="unnumbered">@PlanningSolution
public class Schedule {

    @PlanningScore
    @JsonSerialize(using = ScoreJacksonJsonSerializer.class)
    @JsonDeserialize(using = BendableScoreJacksonXmlAdapter.class)
    private BendableScore score;

    ...
}</programlisting>
<simpara>For example, with a <literal>hardLevelsSize</literal> of <literal>2</literal> and a <literal>softLevelsSize</literal> of <literal>3</literal>, that will generate:</simpara>
<programlisting language="json" linenumbering="unnumbered">{
   ...
   "score":"[0/0]hard/[-100/-20/-3]soft"
}</programlisting>
<simpara>The <literal>hardLevelsSize</literal> and <literal>softLevelsSize</literal> implied, when reading a bendable score from a JSON element, must always be in sync with those in the solver.</simpara>
</section>
</section>
</section>
<section xml:id="integrationWithSoaAndEsb">
<title>SOA and ESB</title>
<section xml:id="integrationWithCamel">
<title>Camel and Karaf</title>
<simpara><link xlink:href="http://camel.apache.org/">Camel</link> is an enterprise integration framework which includes support for Planner (starting from Camel 2.13). It can expose a use case as a REST service, a SOAP service, a JMS service, …​</simpara>
<simpara><link xlink:href="http://camel.apache.org/optaplanner.html">Read the documentation for the camel-optaplanner component.</link>
That component works in Karaf too.</simpara>
</section>
</section>
<section xml:id="integrationWithOtherEnvironments">
<title>Other Environments</title>
<section xml:id="integrationWithJBossModules">
<title>JBoss Modules, WildFly and JBoss EAP</title>
<simpara>Because of JBoss Modules' <literal>ClassLoader</literal> magic, provide the <literal>ClassLoader</literal> of your classes <link linkend="solverConfigurationByXML">during the SolverFactory creation</link>,
so it can find the classpath resources (such as the solver config, score DRL’s and domain classes) in your jars.</simpara>
<section xml:id="loggingOnWildFlyAndJBossEAP">
<title>Logging on WildFly and JBoss EAP</title>
<simpara>To get decent <link linkend="logging">logging of the solver(s)</link>, create a file <literal>src/main/resources/jboss-log4j.xml</literal>
(so it ends up in the <literal>war</literal> as <literal>WEB-INF/classes/jboss-log4j.xml</literal>) with this content:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/" debug="false"&gt;

  &lt;appender name="consoleAppender" class="org.apache.log4j.ConsoleAppender"&gt;
    &lt;layout class="org.apache.log4j.PatternLayout"&gt;
      &lt;param name="ConversionPattern" value="%d{HH:mm:ss.SSS} %-5p [%t] %m%n"/&gt;
    &lt;/layout&gt;
  &lt;/appender&gt;

  &lt;logger name="org.optaplanner"&gt;
    &lt;level value="debug"/&gt;
  &lt;/logger&gt;

  &lt;root&gt;
    &lt;level value="warn" /&gt;
    &lt;appender-ref ref="consoleAppender"/&gt;
  &lt;/root&gt;

&lt;/log4j:configuration&gt;</programlisting>
</section>
<section xml:id="skinnyWarOnWildFlyAndJBossEAP">
<title>Skinny war on WildFly and JBoss EAP</title>
<simpara>To deploy an Planner web application on WildFly, simply include the optaplanner dependency jars in the <literal>war</literal> file’s <literal>WEB-INF/lib</literal> directory
(just like any other dependency) as shown in the <literal>optaplanner-webexamples-*.war</literal>.
However, in this approach the war file can easily grow to several MB in size, which is fine for a one-time deployment,
but too heavyweight for frequent redeployments (especially over a slow network connection).</simpara>
<simpara>The remedy is to use deliver the optaplanner jars in a JBoss module to WildFly and create a skinny war.
Let’s create an module called <emphasis>org.optaplanner</emphasis>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Navigate to the directory <literal>${WILDFLY_HOME}/modules/system/layers/base/</literal>. This directory contains the JBoss modules of WildFly. Create directory structure <literal>org/optaplanner/main</literal> for our new module.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Copy <literal>optaplanner-core-${version}.jar</literal> and all its direct and transitive dependency jars into that new directory. Use "mvn dependency:tree" on each optaplanner artifact to discover all dependencies.</simpara>
</listitem>
<listitem>
<simpara>Create the file <literal>module.xml</literal> in that new directory. Give it this content:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;module xmlns="urn:jboss:module:1.3" name="org.optaplanner"&gt;
  &lt;resources&gt;
    ...
    &lt;resource-root path="kie-api-${version}.jar"/&gt;
    ...
    &lt;resource-root path="optaplanner-core-${version}.jar"/&gt;
    ...
    &lt;resource-root path="."/&gt;
  &lt;/resources&gt;
  &lt;dependencies&gt;
    &lt;module name="javaee.api"/&gt;
  &lt;/dependencies&gt;
&lt;/module&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Navigate to the deployed <literal>war</literal> file.</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>Remove <literal>optaplanner-core-${version}.jar</literal> and all its direct and transitive dependency jars from the <literal>WEB-INF/lib</literal> directory in the <literal>war</literal> file.</simpara>
</listitem>
<listitem>
<simpara>Create the file <literal>jboss-deployment-structure.xml</literal> in the <literal>WEB-INF/lib</literal> directory. Give it this content:</simpara>
<programlisting language="xml" linenumbering="unnumbered">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;jboss-deployment-structure&gt;
   &lt;deployment&gt;
      &lt;dependencies&gt;
         &lt;module name="org.optaplanner" export="true"/&gt;
      &lt;/dependencies&gt;
   &lt;/deployment&gt;
&lt;/jboss-deployment-structure&gt;</programlisting>
</listitem>
</orderedlist>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="integrationWithSpringBoot">
<title>Spring Boot</title>
<simpara>Normally Planner just works on Spring Boot, simply add the <literal>optaplanner-core</literal> dependency.
If it has trouble finding classpath resources (such as the solver config, score DRL’s and domain classes),
provide the <literal>ClassLoader</literal> of your classes <link linkend="solverConfigurationByXML">during the SolverFactory creation</link>.</simpara>
</section>
<section xml:id="integrationWithOSGi">
<title>OSGi</title>
<simpara>The <literal>optaplanner-core</literal> jar includes OSGi metadata in its <literal>MANIFEST.MF</literal> file to function properly in an OSGi environment too.
Furthermore, the maven artifact <literal>kie-karaf-features</literal> contains a <literal>features.xml</literal> file that supports the OSGi-feature <literal>optaplanner-engine</literal>.</simpara>
<simpara>Because of the OSGi’s <literal>ClassLoader</literal> magic, provide the <literal>ClassLoader</literal> of your classes <link linkend="solverConfigurationByXML">during the SolverFactory creation</link>,
so it can find the classpath resources (such as the solver config, score DRL’s and domain classes) in your jars.</simpara>
<note>
<simpara>Planner does <emphasis>not</emphasis> require OSGi.
It works perfectly fine in a normal Java environment too.</simpara>
</note>
</section>
<section xml:id="integrationWithAndroid">
<title>Android</title>
<simpara>Android is not a complete JVM (because some JDK libraries are missing), but Planner works on Android with <link linkend="easyJavaScoreCalculation">easy Java</link> or <link linkend="incrementalJavaScoreCalculation">incremental Java</link> score calculation.
The Drools rule engine does not work on Android yet, so Drools score calculation doesn’t work on Android and its dependencies need to be excluded.</simpara>
<simpara><emphasis role="strong">Workaround to use Planner on Android:</emphasis></simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>Add a dependency to the <literal>build.gradle</literal> file in your Android project to exclude <literal>org.drools</literal> and <literal>xmlpull</literal> dependencies:</simpara>
<programlisting language="gradle" linenumbering="unnumbered">dependencies {
    ...
    compile('org.optaplanner:optaplanner-core:...') {
        exclude group: 'xmlpull'
        exclude group: 'org.drools'
    }
    ...
}</programlisting>
</listitem>
</orderedlist>
</section>
</section>
<section xml:id="integrationWithHumanPlanners">
<title>Integration with Human Planners (Politics)</title>
<simpara>A good Planner implementation beats any good human planner for non-trivial datasets.
Many human planners fail to accept this, often because they feel threatened by an automated system.</simpara>
<simpara>But despite that, both can benefit if the human planner becomes the supervisor of Planner:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">The human planner defines and validates the score function.</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>Some examples expose a <literal>\*Parametrization</literal> object, which defines the weight for each score constraint. The human planner can then tweak those weights at runtime.</simpara>
</listitem>
<listitem>
<simpara>When the business changes, the score function often needs to change too. The human planner can notify the developers to add, change or remove score constraints.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">The human planner is always in control of Planner.</emphasis></simpara>
<itemizedlist>
<listitem>
<simpara>As shown in the course scheduling example, the human planner can lock one or more planning variables to a specific planning value and make those immovable. Because they are <link linkend="immovablePlanningEntities">immovable</link>, Planner does not change them: it optimizes the planning around the enforcements made by the human. If the human planner locks all planning variables, he/she sidelines Planner completely.</simpara>
</listitem>
<listitem>
<simpara>In a prototype implementation, the human planner might use this occasionally. But as the implementation matures, it must become obsolete. But do keep the feature alive: as a reassurance for the humans. Or in case that one day the business changes dramatically before the score constraints can be adjusted.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Therefore, it’s often a good idea to involve the human planner in your project.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/Integration/parameterizeTheScoreWeights.png" align="center"/>
</imageobject>
<textobject><phrase>parameterizeTheScoreWeights</phrase></textobject>
</mediaobject>
</informalfigure>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/Integration/keepTheUserInControl.png" align="center"/>
</imageobject>
<textobject><phrase>keepTheUserInControl</phrase></textobject>
</mediaobject>
</informalfigure>
</section>
<section xml:id="sizingHardwareAndSoftware">
<title>Sizing Hardware and Software</title>
<simpara>Before sizing a Planner service, first understand the typical behaviour of a <literal>Solver.solve()</literal> call:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/Integration/sizingHardware.png" align="center"/>
</imageobject>
<textobject><phrase>sizingHardware</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>Understand these guidelines to decide the hardware for a Planner service:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">RAM memory</emphasis>: Provision plenty, but no need to provide more.</simpara>
<itemizedlist>
<listitem>
<simpara>The problem dataset, loaded before Planner is called, often consumes the most memory. It depends on the problem scale.</simpara>
<itemizedlist>
<listitem>
<simpara>For example, in the Machine Reassignment example some datasets use over 1GB in memory. But in most examples, they use just a few MB.</simpara>
</listitem>
<listitem>
<simpara>If this is a problem, review the domain class structure: remove classes or fields that Planner doesn’t need during solving.</simpara>
</listitem>
<listitem>
<simpara>Planner usually has up to three solution instances: the internal working solution, the best solution and the old best solution (when it’s being replaced). However, these are all a <link linkend="cloningASolution">planning clone</link> of each other, so many problem fact instances are shared between those solution instances.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>During solving, the memory is very volatile, because solving creates many short-lived objects. The Garbage Collector deletes these in bulk and therefore needs some heap space as a buffer.</simpara>
</listitem>
<listitem>
<simpara>The maximum size of the JVM heap space can be in three states:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Insufficient</emphasis>: An <literal>OutOfMemoryException</literal> is thrown (often because the Garbage Collector is using more than 98% of the CPU time).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Narrow</emphasis>: The heap buffer for those short-lived instances is too small, therefore the Garbage Collector needs to run more than it would like to, which causes a performance loss.</simpara>
<itemizedlist>
<listitem>
<simpara>Profiling shows that in the heap chart, the used heap space frequently touches the max heap space during solving. It also shows that the Garbage Collector has a significant CPU usage impact.</simpara>
</listitem>
<listitem>
<simpara>Adding more heap space increases the <link linkend="scoreCalculationSpeed">score calculation speed</link>.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Plenty</emphasis>: There is enough heap space. The Garbage Collector is active, but its CPU usage is low.</simpara>
<itemizedlist>
<listitem>
<simpara>Adding more heap space does <emphasis>not</emphasis> increase performance.</simpara>
</listitem>
<listitem>
<simpara>Usually, this is around 300 to 500MB above the dataset size, <emphasis>regardless of the problem scale</emphasis> (except with <link linkend="nearbySelection">nearby selection</link> and caching move selector, neither are used by default).</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">CPU power</emphasis>: More is better.</simpara>
<itemizedlist>
<listitem>
<simpara>Improving CPU speed directly increases the <link linkend="scoreCalculationSpeed">score calculation speed</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>If the CPU power is twice as fast, it takes half the time to find the same result. However, this does not guarantee that it finds a better result in the same time, nor that it finds a similar result for a problem twice as a big in the same time.</simpara>
</listitem>
<listitem>
<simpara>Increasing CPU power usually does not resolve scaling issues, because planning problems scale exponentially. Power tweaking the solver configuration has far better results for scaling issues than throwing hardware at it.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>During the <literal>solve()</literal> method, the CPU power will max out until it returns (except in <link linkend="daemon">daemon mode</link> or if your <link linkend="SolverEventListener">SolverEventListener</link> writes the best solution to disk or the network).</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Number of CPU cores</emphasis>: one CPU core per active Solver, plus at least one one for the operating system.</simpara>
<itemizedlist>
<listitem>
<simpara>So in a multitenant application, which has one Solver per tenant, this means one CPU core per tenant, unless the number of solver threads is limited, as that limits the number of tenants being solved in parallel.</simpara>
</listitem>
<listitem>
<simpara>With Partitioned Search, presume one CPU core per partition (per active tenant), unless the number of partition threads is limited.</simpara>
<itemizedlist>
<listitem>
<simpara>To reduce the number of used cores, it can be better to reduce the partition threads (so solve some partitions sequentially) than to reduce the number of partitions.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In use cases with many tenants (such as scheduling Software as a Service) or many partitions, it might not be affordable to provision that many CPU’s.</simpara>
<itemizedlist>
<listitem>
<simpara>Reduce the number of active Solvers at a time. For example: give each tenant only one minute of machine time and use a <literal>ExecutorService</literal> with a fixed thread pool to queue requests.</simpara>
</listitem>
<listitem>
<simpara>Distribute the Solver runs across the day (or night). This is especially an opportunity in SaaS that’s used across the globe, due to timezones: UK and India can use the same CPU core when scheduling at night.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The SolverManager will take care of the orchestration, especially in those underfunded environments in which solvers (and partitions) are forced to share CPU cores or wait in line.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">I/O (network, disk, …​)</emphasis>: Not used during solving.</simpara>
<itemizedlist>
<listitem>
<simpara>Planner is not a web server: a solver thread does not block (unlike a servlet thread), each one fully drains a CPU.</simpara>
<itemizedlist>
<listitem>
<simpara>A web server can handle 24 active servlets threads with eight cores without performance loss, because most servlets threads are blocking on I/O.</simpara>
</listitem>
<listitem>
<simpara>However, 24 active solver threads with eight cores will cause each solver’s <link linkend="scoreCalculationSpeed">score calculation speed</link> to be three times slower, causing a big performance loss.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Note that calling any I/O during solving, for example a remote service in your score calculation, causes a huge performance loss because it’s called thousands of times per second, so it should complete in microseconds. So no good implementation does that.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Keep these guidelines in mind when selecting and configuring the software.
See <link xlink:href="https://www.optaplanner.org/blog/archive.html">our blog archive</link> for the details of our experiments, which use our diverse set of examples.
Your mileage may vary.</simpara>
<itemizedlist>
<listitem>
<simpara>Operating System</simpara>
<itemizedlist>
<listitem>
<simpara>No experimentally proven advice yet (but prefer Linux anyway).</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>JDK</simpara>
<itemizedlist>
<listitem>
<simpara>Version: Java 7 can be between 10% and 25% faster than Java 6. But Java 8 however is usually not significantly faster than Java 7.</simpara>
</listitem>
<listitem>
<simpara>Garbage Collector: ParallelGC (the default in Java 8) can be potentially between 5% and 35% faster than G1GC (the default in Java 9). Unlike web servers, Planner needs a GC focused on throughput, not latency. Use <literal>-XX:+UseParallelGC</literal> to turn on ParallelGC.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Logging can have a severe impact on performance.</simpara>
<itemizedlist>
<listitem>
<simpara>Debug logging <literal>org.drools</literal> can reduce performance by a factor of 7.</simpara>
</listitem>
<listitem>
<simpara>Debug logging <literal>org.optaplanner</literal> can be between 0% and 15% slower than info logging. Trace logging can be between 5% and 70% slower than info logging.</simpara>
</listitem>
<listitem>
<simpara>Synchronous logging to a file has an additional significant impact for debug and trace logging (but not for info logging).</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Avoid a cloud environment in which you share your CPU core(s) with other virtual machines or containers. Performance (and therefore solution quality) can be unreliable when the available CPU power varies greatly.</simpara>
</listitem>
</itemizedlist>
<simpara>Keep in mind that the perfect hardware/software environment will probably <emphasis>not</emphasis> solve scaling issues (even Moore’s law is too slow).
There is no need to follow these guidelines to the letter.</simpara>
</section>
</chapter>
<chapter xml:id="designPatterns">
<title>Design Patterns</title>
<section xml:id="designPatternsIntroduction">
<title>Design Patterns Introduction</title>
<simpara>These design patterns list and solve common design challenges.</simpara>
<section xml:id="domainModelingGuide">
<title>Domain Modeling Guide</title>
<simpara>A good model can greatly improve the success of your planning implementation.
These guidelines help to design a good model:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara><emphasis role="strong">Draw a class diagram</emphasis> of your domain model. <emphasis>Normalize</emphasis> it get rid of duplicate data.</simpara>
<itemizedlist>
<listitem>
<simpara>Write down some sample instances for each class.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in employee rostering, the samples for the <literal>Employee</literal> class are <emphasis>Ann</emphasis>, <emphasis>Bert</emphasis> and <emphasis>Carl</emphasis>.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Determine which relationships (or fields) change during planning</emphasis>. Color them orange.
Often there is only one such relationship (or field).
One side of these relationships will become a planning variable later on.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in employee rostering, the <literal>Shift</literal> to <literal>Employee</literal> relationship changes during planning,
so it is orange.
Other relationships, such as from <literal>Employee</literal> to <literal>Skill</literal>, are immutable during planning
because Planner can’t decide to give an employee an extra skill.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If there are multiple relationships (or fields): <emphasis role="strong">check for <link linkend="shadowVariable">shadow variables</link></emphasis>.
A shadow variables does change during planning,
but its value can be calculated based on one or more genuine planning variables, without dispute.
Color those shadow relationships (or fields) purple.</simpara>
<itemizedlist>
<listitem>
<simpara>Only one side of a bi-directional relationship can be a genuine planning variable,
the other side will become an <link linkend="bidirectionalVariable">inverse relation shadow variable</link> later on.
Keep those relationships in orange.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><emphasis role="strong">Check for <link linkend="chainedPlanningVariable">chained planning variables</link></emphasis>.
In a chained variable design, the focus lies on deciding the order of a set planning entity instances,
instead of assigning them to a date/time (although there can be an assigned date/time as a shadow variable).
A typical use case is <link linkend="vehicleRouting">vehicle routing</link>.</simpara>
</listitem>
<listitem>
<simpara>If there is an orange <emphasis>many to many</emphasis> relationship, <emphasis role="strong">replace that <emphasis>many to many</emphasis> relationship</emphasis>
with a <emphasis>one to many</emphasis> and a <emphasis>many to one</emphasis> relationship to a new intermediate class.</simpara>
<itemizedlist>
<listitem>
<simpara>Planner currently doesn’t support a <literal>@PlanningVariable</literal> on a collection.
Although a future version will support it for flexibility reasons,
it probably has an inherit performance and complexity cost, so it might be better to avoid it anyway.</simpara>
</listitem>
<listitem>
<simpara>For example in employee rostering the <literal>ShiftAssignment</literal> class is
the <emphasis>many to many</emphasis> relationship between the <literal>Shift</literal> and <literal>Employee</literal>.
It’s effectively every spot that needs to be filled with an employee.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/DesignPatterns/employeeShiftRosteringModelingGuideA.png" align="center"/>
</imageobject>
<textobject><phrase>employeeShiftRosteringModelingGuideA</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>In a <emphasis>many to one</emphasis> relationship, <emphasis role="strong">usually the <emphasis>many</emphasis> side is the planning entity class with the planning variable</emphasis>.
Annotate it with a <literal>@PlanningEntity</literal> annotation.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in employee rostering, the <literal>ShiftAssignment</literal> class has an <literal>@PlanningEntity</literal> annotation.</simpara>
</listitem>
<listitem>
<simpara>If it’s a bi-directional relationship, both sides are a planning entity class,
but usually the <emphasis>many</emphasis> side has the planning variable and the <emphasis>one</emphasis> side the shadow variable.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The planning entity class should have <emphasis role="strong">at least one problem property</emphasis>.
So a planning entity class cannot consist out of only planning variables
(or even an id and only planning variables).
Remove a surplus <literal>@PlanningVariable</literal> so it becomes a problem property.
This heavily decreases <link linkend="searchSpaceSize">the search space size</link> and heavily increases solving efficiency.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in employee rostering, the <literal>ShiftAssignment</literal> class should not annotate
both the shift and employee relationship with <literal>@PlanningVariable</literal>.</simpara>
</listitem>
<listitem>
<simpara>When all planning variables are <literal>null</literal> (which occurs when the planning solution is still uninitialized),
a planning entity instance should still be describable to the business people.</simpara>
<itemizedlist>
<listitem>
<simpara>So a surrogate ID does not suffice as the required minimum of one problem property.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>This way, there is no need to add a hard constraint to assure that two planning entities are different:
they are already different due to their problem properties.</simpara>
</listitem>
<listitem>
<simpara>In some cases, multiple planning entity instances have the same set of problem properties.
In such cases, it can be useful to create an extra problem property to distinguish them.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in employee rostering, the <literal>ShiftAssignment</literal> class has besides the problem property <literal>Shift</literal>
also the problem property <literal>indexInShift</literal> (which is an <literal>int</literal>).</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Choose the model in which <emphasis role="strong">the number of planning entities is fixed during planning</emphasis>.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in employee rostering, it’s impossible to know in advance how many shifts each employee will have
before Planner solves it (and it can even differ per best solution found).
On the other hand, the number of employees per shift is known in advance,
so it’s better to make the <literal>Shift</literal> relationship a problem property
and the <literal>Employee</literal> relationship a planning variable.</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/DesignPatterns/employeeShiftRosteringModelingGuideB.png" align="center"/>
</imageobject>
<textobject><phrase>employeeShiftRosteringModelingGuideB</phrase></textobject>
</mediaobject>
</informalfigure>
</listitem>
</itemizedlist>
</listitem>
</orderedlist>
<simpara>For inspiration, take a look at how the examples modeled their domain:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/DesignPatterns/entityVariableAndValueExamples.png" align="center"/>
</imageobject>
<textobject><phrase>entityVariableAndValueExamples</phrase></textobject>
</mediaobject>
</informalfigure>
<note>
<simpara>Vehicle routing is special, because it uses a <link linkend="chainedPlanningVariable">chained planning variable</link>.</simpara>
</note>
</section>
</section>
<section xml:id="assigningTimeToPlanningEntities">
<title>Assigning Time to Planning Entities</title>
<simpara>Dealing with time and dates in planning problems may be problematic because it is dependent on the needs of your use case.</simpara>
<simpara>There are several representations of timestamps, dates, durations and periods in Java.
Choose the right representation type for your use case:</simpara>
<itemizedlist>
<listitem>
<simpara><literal>java.util.Date</literal> (deprecated): a slow, error-prone way to represent timestamps. Do not use.</simpara>
</listitem>
<listitem>
<simpara><literal>java.time.LocalDateTime</literal>, <literal>LocalDate</literal>, <literal>DayOfWeek</literal>, <literal>Duration</literal>, <literal>Period</literal>, …​: an accurate way to represent and calculate with timestamps, dates, …​</simpara>
<itemizedlist>
<listitem>
<simpara>Supports timezones and DST (Daylight Saving Time).</simpara>
</listitem>
<listitem>
<simpara>Requires Java 8 or higher.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara><literal>int</literal> or <literal>long</literal>: Caches a timestamp as a simplified number of coarse-grained time units (such as minutes) from the start of the global planning time window or the epoch.</simpara>
<itemizedlist>
<listitem>
<simpara>For example: a <literal>LocalDateTime</literal> of <literal>1-JAN 08:00:00</literal> becomes an <literal>int</literal> of <literal>400</literal> minutes. Similarly <literal>1-JAN 09:00:00</literal> becomes <literal>460</literal> minutes.</simpara>
</listitem>
<listitem>
<simpara>It often represents an extra field in a class, alongside the <literal>LocalDateTime</literal> field from which it was calculated. The <literal>LocalDateTime</literal> is used for user visualization, but the <literal>int</literal> is used in the score constraints.</simpara>
</listitem>
<listitem>
<simpara>It is faster in calculations, which is especially useful in the TimeGrain pattern.</simpara>
</listitem>
<listitem>
<simpara>Do not use if timezones or DST affect the score constraints.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>There are also several designs for assigning a planning entity to a starting time (or date):</simpara>
<itemizedlist>
<listitem>
<simpara>The starting time is fixed beforehand. It is not a planning variable (in such solver).</simpara>
<itemizedlist>
<listitem>
<simpara>For example, in the <link linkend="bedAllocation">hospital bed planning</link> example, the arrival day of each patient is fixed beforehand.</simpara>
</listitem>
<listitem>
<simpara>This is common in <link linkend="multiStagePlanning">multi stage planning</link>, when the starting time has been decided already in an earlier planning stage.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>The starting time is not fixed, it is a planning variable (genuine or shadow).</simpara>
<itemizedlist>
<listitem>
<simpara>If all planning entities have the same duration, use the <link linkend="timeslotPattern">Timeslot pattern</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in course scheduling, all lectures take one hour. Therefore, each timeslot is one hour.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If the duration differs and time is rounded to a specifc time granularity (for example 5 minutes) use the <link linkend="timeGrainPattern">TimeGrain pattern</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in meeting scheduling, all meetings start at 15 minute intervals. All meetings take 15, 30, 45, 60, 90 or 120 minutes.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>If the duration differs and one task starts immediately after the previous task (assigned to the same executor) finishes, use the <link linkend="chainedThroughTimePattern">Chained Through Time pattern</link>.</simpara>
<itemizedlist>
<listitem>
<simpara>For example in time windowed vehicle routing, each vehicle departs immediately to the next customer when the delivery for the previous customer finishes.</simpara>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>
<simpara>Choose the right pattern depending on the use case:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/DesignPatterns/assigningTimeToPlanningEntities.png" align="center"/>
</imageobject>
<textobject><phrase>assigningTimeToPlanningEntities</phrase></textobject>
</mediaobject>
</informalfigure>
<section xml:id="timeslotPattern">
<title>Timeslot Pattern: Assign to a Fixed-Length Timeslot</title>
<simpara>If all planning entities have <emphasis role="strong">the same duration</emphasis> (or can be inflated to the same duration), the Timeslot pattern is useful.
The planning entities are assigned to a timeslot rather than time.
For example in <link linkend="curriculumCourse">course timetabling</link>, all lectures take one hour.</simpara>
<simpara>The timeslots can start at any time.
For example, the timeslots start at 8:00, 9:00, 10:15 (after a 15-minute break), 11:15, …​ They can even overlap, but that is unusual.</simpara>
<simpara>It is also usable if all planning entities can be inflated to the same duration.
For example in <link linkend="examination">exam timetabling</link>, some exams take 90 minutes and others 120 minutes, but all timeslots are 120 minutes.
When an exam of 90 minutes is assigned to a timeslot, for the remaining 30 minutes, its seats are occupied too and cannot be used by another exam.</simpara>
<simpara>Usually there is a second planning variable, for example the room.
In course timetabling, two lectures are in conflict if they share the same room at the same timeslot.
However, in exam timetabling, that is allowed, if there is enough seating capacity in the room (although mixed exam durations in the same room do inflict a soft score penalty).</simpara>
</section>
<section xml:id="timeGrainPattern">
<title>TimeGrain Pattern: Assign to a Starting TimeGrain</title>
<simpara>Assigning humans to start a meeting at four seconds after 9 o’clock is pointless because most human activities have a time granularity of five minutes or 15 minutes.
Therefore it is not necessary to allow a planning entity to be assigned subsecond, second or even one minute accuracy.
The five minute or 15 minutes accuracy suffices.
The TimeGrain pattern models such <emphasis role="strong">time accuracy</emphasis> by partitioning time as time grains.
For example in <link linkend="meetingScheduling">meeting scheduling</link>, all meetings start/end in hour, half hour, or 15-minute intervals before or after each hour, therefore the optimal settings for time grains is 15 minutes.</simpara>
<simpara>Each planning entity is assigned to a start time grain.
The end time grain is calculated by adding the duration in grains to the starting time grain.
Overlap of two entities is determined by comparing their start and end time grains.</simpara>
<simpara>This pattern also works well with a coarser time granularity (such as days, half days, hours, …​).
With a finer time granularity (such as seconds, milliseconds, …​) and a long time window, the value range (and therefore <link linkend="searchSpaceSize">the search space</link>) can become too high, which reduces efficiency and scalability.
However, such solution is not impossible, as shown in <link linkend="cheapTimeScheduling">cheap time scheduling</link>.</simpara>
</section>
<section xml:id="chainedThroughTimePattern">
<title>Chained Through Time Pattern: Assign in a Chain that Determines Starting Time</title>
<simpara>If a person or a machine continuously works on <emphasis role="strong">one task at a time in sequence</emphasis>,
which means starting a task when the previous is finished (or with a deterministic delay), the Chained Through Time pattern is useful.
For example, in the vehicle routing with time windows example, a vehicle drives from customer to customer (thus it handles one customer at a time).</simpara>
<simpara>In this pattern, the planning entities are <link linkend="chainedPlanningVariable">chained</link>.
The anchor determines the starting time of its first planning entity.
The second entity’s starting time is calculated based on the starting time and duration of the first entity.
For example, in task assignment, Beth (the anchor) starts working at 8:00, thus her first task starts at 8:00.
It lasts 52 mins, therefore her second task starts at 8:52.
The starting time of an entity is usually <link linkend="shadowVariable">a shadow variable</link>.</simpara>
<simpara>An anchor has only one chain.
Although it is possible to split up the anchor into two separate anchors, for example split up Beth into Beth’s left hand and Beth’s right hand (because she can do two tasks at the same time), this model makes pooling resources difficult.
Consequently, using this model in the exam scheduling example to allow two or more exams to use the same room at the same time is problematic.</simpara>
<simpara>Between planning entities, there are three ways to create gaps:</simpara>
<itemizedlist>
<listitem>
<simpara>No gaps: This is common when the anchor is a machine. For example, a build server always starts the next job when the previous finishes, without a break.</simpara>
</listitem>
<listitem>
<simpara>Only deterministic gaps: This is common for humans. For example, any task that crosses the 10:00 barrier gets an extra 15 minutes duration so the human can take a break.</simpara>
<itemizedlist>
<listitem>
<simpara>A deterministic gap can be subjected to complex business logic. For example in vehicle routing, a cross-continent truck driver needs to rest 15 minutes after two hours of driving (which may also occur during loading or unloading time at a customer location) and also needs to rest 10 hours after 14 hours of work.</simpara>
</listitem>
</itemizedlist>
</listitem>
<listitem>
<simpara>Planning variable gaps: This is uncommon, because an extra planning variable (which impacts the <link linkend="searchSpaceSize">search space</link>) reduces efficiency and scalability.</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section xml:id="multiStagePlanning">
<title>Multi-stage planning</title>
<simpara>For practical or organizational reasons (such as Conway’s law), complex planning problems are often broken down in multiple stages.
A typical example is train scheduling, where one department decides where and when a train will arrive or depart, and another departments assigns the operators to the actual train cars/locomotives.</simpara>
<simpara>Each stage has its own solver configuration (and therefore its own <literal>SolverFactory</literal>). Do not confuse it with <link linkend="solverPhase">multi-phase solving</link> which uses a one-solver configuration.</simpara>
<simpara>Similarly to <link linkend="partitionedSearch">Partitioned Search</link>, multi-stage planning leads to suboptimal results.
Nevertheless, it may be beneficial in order to simplify the maintenance, ownership, and help to start a project.</simpara>
</section>
</chapter>
<chapter xml:id="development">
<title>Development</title>
<section xml:id="methodologyOverview">
<title>Methodology Overview</title>
<simpara>The diagram below explains the overall structure of the OptaPlanner source code:</simpara>
<informalfigure>
<mediaobject>
<imageobject>
<imagedata fileref="images/topics/product-shared-docs/images/Development/methodologyOverview.png" align="center"/>
</imageobject>
<textobject><phrase>methodologyOverview</phrase></textobject>
</mediaobject>
</informalfigure>
<simpara>In the diagram above, it’s important to understand the clear separation between the configuration and runtime classes.</simpara>
<simpara>The development philosophy includes:</simpara>
<itemizedlist>
<listitem>
<simpara><emphasis role="strong">Reuse</emphasis>: The examples are reused as integration tests, stress tests and demo’s. The documentation images are reused as slides.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Consistent terminology</emphasis>: Each example has a class <literal>App</literal> (executable class), <literal>Dao</literal> (Data Access Object) and <literal>Panel</literal> (swing UI).</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Consistent structure</emphasis>: Each example has the same packages: <literal>domain</literal>, <literal>persistence</literal>, <literal>app</literal>, <literal>solver</literal> and <literal>swingui</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Real world usefulness</emphasis>: Every feature is used in an example. Most examples are real world use cases with real world constraints, often with real world data.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Automated testing</emphasis>: There are unit tests, integration tests, performance regressions tests and stress tests. The test coverage is high.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fail fast with an understandable error message</emphasis>: Invalid states are checked as early as possible.</simpara>
</listitem>
</itemizedlist>
</section>
<section xml:id="developmentGuidelines">
<title>Development guidelines</title>
<orderedlist numeration="arabic">
<listitem>
<simpara>Fail fast. There are several levels of fail fast, from better to worse:</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara><emphasis role="strong">Fail Fast at compile time</emphasis>. For example: Don’t accept an <literal>Object</literal> as parameter if it needs to be a <literal>String</literal> or an <literal>Integer</literal>.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fail Fast at startup time</emphasis>. For example: if the configuration parameter needs to be a positive <literal>int</literal> and it’s negative, fail fast</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fail Fast at runtime</emphasis>. For example: if the request needs to contain a double between <literal>0.0</literal> and <literal>1.0</literal> and it’s bigger than <literal>1.0</literal>, fail fast.</simpara>
</listitem>
<listitem>
<simpara><emphasis role="strong">Fail Fast at runtime in assertion mode</emphasis> if the detection performance cost is high. For example: If, after every low level iteration, the variable A needs to be equal to the square root of B, check it if and only if an assert flag is set to true (usually controlled by the <link linkend="environmentMode">EnvironmentMode</link>).</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara><literal>Exception</literal> messages</simpara>
<orderedlist numeration="loweralpha">
<listitem>
<simpara>The <literal>Exception</literal> message must include the name and state of each relevant variable. For example:</simpara>
<programlisting language="java" linenumbering="unnumbered">if (fooSize &lt; 0) {
    throw new IllegalArgumentException("The fooSize (" + fooSize + ") of bar (" + this + ") must be positive.");
}</programlisting>
<simpara>Notice that the output clearly explains what’s wrong:</simpara>
<programlisting language="java" linenumbering="unnumbered">Exception in thread "main" java.lang.IllegalArgumentException: The fooSize (-5) of bar (myBar) must be positive.
    at ...</programlisting>
</listitem>
<listitem>
<simpara>Whenever possible, the <literal>Exception</literal> message must include context.</simpara>
</listitem>
<listitem>
<simpara>Whenever the fix is not obvious, the <literal>Exception</literal> message should include advice. Advice normally starts with the word <emphasis>maybe</emphasis> on a new line:</simpara>
<programlisting language="java" linenumbering="unnumbered">Exception in thread "main" java.lang.IllegalStateException: The valueRangeDescriptor (fooRange) is nullable, but not countable (false).
Maybe the member (getFooRange) should return CountableValueRange.
    at ...</programlisting>
<simpara>The word <emphasis>maybe</emphasis> is to indicate that the advice is not guaranteed to be right in all cases.</simpara>
</listitem>
</orderedlist>
</listitem>
<listitem>
<simpara>Generics. The <literal>Solution</literal> class is often passed as a generic type parameter to subsystems. The <literal>PlanningEntity</literal> class(es) are rarely passed as a generic type parameter.</simpara>
</listitem>
</orderedlist>
</section>
</chapter>
</book>