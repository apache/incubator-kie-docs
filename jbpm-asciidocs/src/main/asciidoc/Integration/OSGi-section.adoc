
= OSGi

All core jBPM JARs (and core dependencies) are OSGi-enabled.
That means that they contain MANIFEST.MF files (in the META-INF directory) that describe their dependencies etc.
These manifest files are automatically generated by the build.
You can plug these JARs directly into an OSGi environment.

OSGi is a dynamic module system for declarative services.
So what does that mean? Each JAR in OSGi is called a bundle and has its own Classloader.
Each bundle specifies the packages it exports (makes publicly available) and which packages it imports (external dependencies). OSGi will use this information to wire the classloaders of different bundles together; the key distinction is you don't specify what bundle you depend on, or have a single monolithic classpath, instead you specify your package import and version and OSGi attempts to satisfy this from available bundles.

It also supports side by side versioning, so you can have multiple versions of a bundle installed and it'll wire up the correct one.
Further to this Bundles can register services for other bundles to use.
These services need initialisation, which can cause ordering problems - how do you make sure you don't consume a service before its registered? OSGi has a number of features to help with service composition and ordering.
The two main ones are the programmatic ServiceTracker and the XML based Declarative Services.
There are also other projects that help with this; Spring DM, iPOJO, Gravity.

The following jBPM JARs are OSGi-enabled:

* jbpm-flow
* jbpm-flow-builder
* jbpm-bpmn2