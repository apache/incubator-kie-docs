= Technical Exceptions

== Introduction

Technical exceptions happen when a technical component of a business process acts in an unexpected way.
When using Java based systems, this often results in a literal Java Exception being thrown by the system.

Technical components used in a process can fail in a way that can not be described using  BPMN2.
In this case, it's important to handle these exceptions in expected ways.

The following types of code might throw exceptions:

* Any code that is present in the process definition itself
* Any code that is executed during a process and is not part of jBPM
* Any code that interacts with a technical component outside of the {PROCESS_ENGINE}

However, those are somewhat abstract definitions.
We can narrow down the places at which an exception might be thrown.
Technical exceptions can occur at the following points:

. Code present in `<scriptTask>` nodes or in the  jbpm-specific `<onEntry>` and `<onExit>` elements
. Code executed in `WorkItemHandlers` associated with  `<task>` and task-type nodes

It is _much easier_ to ensure correct exception handling for  `<task>` and other task-type nodes that use `WorkItemHandler`  implementations, than for code executed directly in a ``<scriptTask>``.

Exceptions thrown by `<scriptTask>` can cause the process to fail in an unrecoverable fashion.
While there are certain things that you can do to contain the damage, a process that has failed in this way can not be restarted or otherwise recovered.
This also applies to other nodes in a process definition that contain script code in the node  definition, such as the `<onEntry>` and `<onExit>`  elements.

When {PROCESS_ENGINE} does throw an exception generated by the code in a `<scriptTask>`  the exception thrown is a special Java exception called the `WorkflowRuntimeException` that contains information about the process.

[WARNING]
====
Again, exceptions generated by a `<scriptTask>` node (and other nodes containing script code) will leave the process __unrecoverable__.
In fact, often, the code that starts the process itself will end up throwing the exception generated by the business process, without returning  a reference to the process instance.

For this reason, it's important to limit the scope of the code in these nodes to operations  dealing with process variables.
Using a `<scriptTask>` to interact with a different technical component, such as a  database or web service has _significant risks_ because any exceptions thrown  will corrupt or abort the process.

`<task>` nodes, `<serviceTask>` nodes and the rest of  the ``task``-type nodes are explicitly meant for interacting with other systems -- not  `<scriptTask>` nodes!  Use ``<task>``-type nodes to interact with  other technical components.
====

== Handling exceptions in `WorkItemHandler` instances

`
WorkItemHandler` classes are used when your process interacts with other technical systems.
For an introduction to them and how to use them in processes, please see the
<<jBPMDomainSpecificProcesses,Domain-Specific Processes>> chapter.

While you can build exception handling into your own `WorkItemhandler` implementations, there are also two "`handler decorator`"
 classes that you can use to __wrap__ a `WorkItemhandler` implementation.

These two wrapper classes include logic that is executed when an exception is thrown during the execution (or abortion) of a work item.

.Exception Handling `WorkItemHandler` wrapper classes
[cols="1,2a", frame="all", options="header"]
|===
| Decorator classes in the org.jbpm.bpmn2.handler package
| Description

|``SignallingTaskHandlerDecorator``
|This class wraps an existing `WorkItemHandler` implementation. When the
`$$.$$executeWorkItem(...)` or `$$.$$abortWorkItem(...)` methods of the
original `WorkItemHandler` instance throw an exception, the
`SignallingTaskHandlerDecorator` will catch the exception and signal the process instance
using a configurable event type. The exception thrown will be passed as part of the event. This
functionality can be used to signal an _Event SubProcess_ defined in the process
definition.

|``LoggingTaskHandlerDecorator``
|This class reacts to all exceptions thrown by the `$$.$$executeWorkItem(...)`
or `$$.$$abortWorkItem(...)```WorkItemHandler`` methods by logging the errors. It
also saves any exceptions thrown so to an internal list so that they can be retrieved later for
inspection or further logging. Lastly, the content and format of the message logged upon an
exception are configurable.
|===


While the two classes described above should cover most cases involving exception handling, a Java developer with some experience with jBPM should be able to create a ``WorkItemHandler`` that executes custom code upon an exception.

If you do decide to write a custom `WorkItemHandler` that includes exception  handling logic, keep the following checklist in mind:

. Are you catching all possible exceptions that you want to (and no more, or  less)?
. Are you making sure to either complete or abort the work item after an exception has been caught? If not, are there mechanisms to retry the process later? Or are incomplete process instances acceptable?
. What other actions should be taken when an exception is caught? Do you want to simply log the exception, or is it also important to interact with other technical systems? Do you want to trigger a (BPMN2) subprocess that will handle the exception?


[IMPORTANT]
====
When you use the `WorkItemManager` to signal that the work item has been completed or aborted, make sure to do that _after you've sent any signals_ to the process instance.
Depending on how you've defined your process, calling `WorkItemManager.completeWorkItem(...)` or ``WorkItemManager.abortWorkItem(...)`` will trigger the completion of the process instance.
This is because these methods trigger the {PROCESS_ENGINE} to continue the process flow.
====


In the next section, we'll describe an example that uses the `SignallingTaskHandlerDecorator` to signal an _event subprocess_ when a work item handler throws an exception.

== Examples

=== Example: service task handlers


We'll go through one example in this section, and then look quickly at how you can change  it to get the behavior you want.
The example involves an `<error>` event that's caught by an __(Error) Event SubProcess__.

When an _Error Event_ is thrown, the containing process will be interrupted.
This means that after the process flow attached to the error event has executed, the following  will happen:

. process execution will stop, and no other parts of the process will execute
. the process instance will end up in an aborted state (instead of completed)

The example we'll go through contains an ``<error>``, but at the end of the section, we'll show how you can change the process to use a `<signal>` instead.

[TIP]
====
The code and BPMN2 process definition shown in the next section are available in the [path]_jbpm-examples_
 module.
See the ``org.jbpm.examples.exceptions.ExceptionHandlingErrorExample`` class for the Java code.
The BPMN2 process definition is available in the [path]_exceptions/ExceptionHandlingWithError.bpmn2_
 file in the [path]_src/main/resources_
 directory of the [path]_jbpm-examples_
 module.
====

==== BPMN2 configuration


Let's look at the BPMN2 process definition first.
Besides the definition of the process, the BPMN2 elements defined before the actual process definition are also important.
Here's an image of  the BPMN2 process that we'll be using in the example:


image::ExceptionManagement/exception-flow.png[]


The BPMN2 process fragment below is part of the process shown above, and contains some notes  on the different BPMN2 elements.

[NOTE]
====
If you're viewing this on a web browser, you may need to widen or narrow your browser window in order to see the "callout" or note numbers on the right hand side of the code.
====

[source,xml]
----
 <itemDefinition id="_stringItem" structureRef="java.lang.String" /> <!--1-->
  <message id="_message" itemRef="_stringItem"/>  # <!--2-->

  <interface id="_serviceInterface" name="org.jbpm.examples.exceptions.service.ExceptionService">
    <operation id="_serviceOperation" name="throwException">
      <inMessageRef>_message</inMessageRef> <!--2-->
    </operation>
  </interface>

  <error id="_exception" errorCode="code" structureRef="_exceptionItem"/> <!--3-->

  <itemDefinition id="_exceptionItem" structureRef="org.kie.api.runtime.process.WorkItem"/> <!--4-->
  <message id="_exceptionMessage" itemRef="_exceptionItem"/> <!--4-->

  <interface id="_handlingServiceInterface" name="org.jbpm.examples.exceptions.service.ExceptionService">
    <operation id="_handlingServiceOperation" name="handleException">
      <inMessageRef>_exceptionMessage</inMessageRef> <!--4-->
    </operation>
  </interface>

  <process id="ProcessWithExceptionHandlingError" name="Service Process" isExecutable="true" processType="Private">
    <!-- properties -->
    <property id="serviceInputItem" itemSubjectRef="_stringItem"/> <!--1-->
    <property id="exceptionInputItem" itemSubjectRef="_exceptionItem"/> <!--4-->

    <!-- main process -->
    <startEvent id="_1" name="Start" />
    <serviceTask id="_2" name="Throw Exception" implementation="Other" operationRef="_serviceOperation">

    <!-- rest of the serviceTask element and process definition... -->

    <subProcess id="_X" name="Exception Handler" triggeredByEvent="true" >
      <startEvent id="_X-1" name="subStart">
        <dataOutput id="_X-1_Output" name="event"/>
        <dataOutputAssociation>
          <sourceRef>_X-1_Output</sourceRef>
          <targetRef>exceptionInputItem</targetRef> <!--4-->
        </dataOutputAssociation>
        <errorEventDefinition id="_X-1_ED_1" errorRef="_exception" /> <!--3-->
      </startEvent>

      <!-- rest of the subprocess definition... -->

    </subProcess>

  </process>
----
<1> This `<itemDefinition>` element defines a data structure that we then use in the serviceInputItem property in the process.
<2> This `<message>` element (1rst reference) defines a message that has a String as its content (as defined by the `<itemDefinition>` element on line above). The `<interface>` element below it refers to it (2nd reference) in order to define what type of content the service (defined by the `<interface>`) expects.
<3> This `<error>` element (1rst reference) defines an error for use later in the process: an Event SubProcess is defined that is triggered by this error (2nd reference). The content of the error is defined by the `<itemDefinition>` element defined below the `<error>` element.
<4> This `<itemDefinition>` element (1rst reference) defines an item that contains a WorkItem instance. The `<message>` element (2nd reference) then defines a message that uses this item definition to define its content. The `<interface>` element below that refers to the `<message>` definition (3rd reference) in order to define the type of content that the service expects.
+
In the process itself, a `<property>` element (4th reference) is defined as having the content defined by the initial `<itemDefinition>`. This is helpful because it means that the Event SubProcess can then store the error it receives in that property (5th reference).

[CAUTION]
====
When you're using a `<serviceTask>` to call a Java class, make sure to double check the class name in your BPMN2 definition! A small typo there can cost you time later when you're trying to figure out what went wrong.
====

==== `SignallingTaskHandlerDecorator` and `WorkItemHandler` configuration


Now that BPMN2 process definition is (hopefully) a little clearer, we can look at how to set up jBPM to take advantage of the above BPMN2.

In the (BPMN2) process definition above, we define two different `<serviceTask>`  activities.
The `org.jbpm.bpmn2.handler.ServiceTaskHandler` class is the default task  handler class used for `<serviceTask>` tasks.
If you don't specify a  `WorkItemHandler` implementation for a ``<serviceTask>``, the  `ServiceTaskHandler` class will be used.

In the code below, you'll see that we actually wrap or decorate the  `ServiceTaskHandler` class with a `SignallingTaskHandlerDecorator` instance.
We do this in order to define what happens when the `ServiceTaskHandler` throws an  exception.

In this case, the `ServiceTaskHandler` will throw an exception because it's  configured to call the `ExceptionService.throwException` method, which throws an exception.
(See the `_handlingServiceInterface` ``<interface>`` element in the BPMN2.)

In the code below, we also configure which (error) event is sent to the process instance by  the `SignallingTaskHandlerDecorator` instance.
The `SignallingTaskHandlerDecorator` does this when an exception is thrown in a __task__.
In this case, since we've  defined an `<error>` with the __error code__ "`code`" in the BPMN2, we set the signal to ``Error-code``.

[IMPORTANT]
====
When signalling the {PROCESS_ENGINE} with an event of some sort, you should keep in mind the rules for signalling process events.

* Error events can be signalled by sending an "Error-" + <the `errorCode`  attribute value> value to the session.
* Signal events can be signalled by sending the name of the signal to the session.
====

[source,java]
----

import java.util.HashMap;
import java.util.Map;

import org.jbpm.bpmn2.handler.ServiceTaskHandler;
import org.jbpm.bpmn2.handler.SignallingTaskHandlerDecorator;
import org.jbpm.examples.exceptions.service.ExceptionService;
import org.kie.api.KieBase;
import org.kie.api.io.ResourceType;
import org.kie.api.runtime.KieSession;
import org.kie.api.runtime.process.ProcessInstance;
import org.kie.internal.builder.KnowledgeBuilder;
import org.kie.internal.builder.KnowledgeBuilderFactory;
import org.kie.internal.io.ResourceFactory;

public class ExceptionHandlingErrorExample {

    public static final void main(String[] args) {
        runExample();
    }

    public static ProcessInstance runExample() {
        KieSession ksession = createKieSession();

        String eventType = "Error-code"; // <1>

        SignallingTaskHandlerDecorator signallingTaskWrapper // <2>
            = new SignallingTaskHandlerDecorator(ServiceTaskHandler.class, eventType);
        signallingTaskWrapper.setWorkItemExceptionParameterName(ExceptionService.exceptionParameterName); // <3>
        ksession.getWorkItemManager().registerWorkItemHandler("Service Task", signallingTaskWrapper);

        Map<String, Object> params = new HashMap<String, Object>();
        params.put("serviceInputItem", "Input to Original Service");
        ProcessInstance processInstance = ksession.startProcess("ProcessWithExceptionHandlingError", params);

        return processInstance;
    }

    private static KieSession createKieSession() {
        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
        kbuilder.add(ResourceFactory.newClassPathResource("exceptions/ExceptionHandlingWithError.bpmn2"), ResourceType.BPMN2);
        KieBase kbase = kbuilder.newKnowledgeBase();
        return kbase.newKieSession();
    }
----
<1> Here we define the name of the event that will be sent to the process instance if the wrapped WorkItemHandler implementation throws an exception. The eventType string is used when instantiating the SignallingTaskHandlerDecorator class.
<2> Then we construct an instance of the SignallingTaskHandlerDecorator class. In this case, we simply give it the class name of the WorkItemHandler implementation class to instantiate, but another constructor is available that we can pass an instance of a WorkItemHandler implementation to (necessary if the WorkItemHandler implementation does not have a no-argument constructor).
<3> When an exception is thrown by the wrapped WorkItemHandler, the SignallingTaskHandlerDecorator saves it as a parameter in the WorkItem instance with a parameter name that we configure the SignallingTaskHandlerDecorator to give it (see the code below for the ExceptionService).

==== `ExceptionService` setup and configuration


In the BPMN2 process definition above, a service interface is defined that references the `ExceptionService` class:

[source,xml]
----
<interface id="_handlingServiceInterface" name="org.jbpm.examples.exceptions.service.ExceptionService">
    <operation id="_handlingServiceOperation" name="handleException">
----


In order to fill in the blanks a little bit, the code for the `ExceptionService`  class has been included below.
In general, you can specify any Java class with the default or an  other no-argument constructor and have it executed during a `<serviceTask>`

[source,java]
----

public class ExceptionService {

  public static String exceptionParameterName = "my.exception.parameter.name";

  public void handleException(WorkItem workItem) {
    System.out.println( "Handling exception caused by work item '" + workItem.getName() + "' (id: " + workItem.getId() + ")");

    Map<String, Object> params = workItem.getParameters();
    Throwable throwable = (Throwable) params.get(exceptionParameterName);
    throwable.printStackTrace();
  }

  public String throwException(String message) {
      throw new RuntimeException("Service failed with input: " + message );
  }

  public static void setExceptionParameterName(String exceptionParam) {
      exceptionParameterName = exceptionParam;
  }

}
----

==== Changing the example to use a `<signal>`


In the example above, the thrown Error Event interrupts the process: no other flows or activities are executed once the Error Event has been thrown.

However, when a _Signal Event_ is processed, the process will continue after the _Signal Event SubProcess_ (or whatever other activities that the Signal Event triggers) has been executed.
Furthermore, this implies that the process will  _not_ end up in an aborted state, unlike a process that throws an Error  Event.

In the process above, we use the `<error>` element in order to be able to use an Error Event:

[source,xml]
----
  <error id="_exception" errorCode="code" structureRef="_exceptionItem"/>
----


When we want to use a Signal Event instead, we remove that line and use a `<signal>` element:

[source,xml]
----
   <signal id="exception-signal" structureRef="_exceptionItem"/>
----

However, we must also change all references to the `_exception` ``<error>`` so that they now refer to the ``exception-signal``  ``<signal>``.

That means that the `<errorEventDefinition>` element in the ``<startEvent>``,

[source,xml]
----
   <errorEventDefinition id="_X-1_ED_1" errorRef="_exception" />
----


must be changed to a `<signalEventDefinition>` which would like like this:

[source,xml]
----
   <signalEventDefinition id="_X-1_ED_1" signalRef="exception-signal"/>
----


In short, we have to make the following changes to the `<startEvent>` in  the Event SubProcess:

. It will now contain a `<signalEventDefinition>` instead of a `<errorEventDefinition>`
. The `errorRef` attribute in the `<errorEventDefinition>` is  now a `signalRef` attribute in the ``<signalEventDefinition>``.
. The `id` attribute in the `signalRef` is of course now the id of  the `<signal>` element. Before it was id of `<error>` element.
. Lastly, when we signal the process in the Java code, we do not signal  "``Error-code``" but simply "``exception-signal``", the `id` of the `<signal>` element.


=== Example: logging exceptions thrown by bad `<scriptTask>` nodes


In this section, we'll briefly describe what's possible when dealing with `<scriptTask>` nodes that throw exceptions, and then quickly go through an example (also available in the [path]_jbpm-examples_
 module) that illustrates this.

==== Introduction


If you're reading this, then you probably already have a problem: you're either  expecting to run into this problem because there are scripts in your process definition that might  throw an exception, or you're already running a process instance with scripts that are causing a  problem.

Unfortunately, if you're running into this problem, then there is not much you can do.
The only thing that you _can_ do is retrieve more information about exactly what's causing  the problem.
Luckily, when a `<scriptTask>` node causes an exception,  the exception is then wrapped in a ``WorkflowRuntimeException``.

What type of information is available? The `WorkflowRuntimeException` instance will contain the information outlined in the following table.
All of the fields listed are  available via the normal `get*` methods.

.Information contained in `WorkflowRuntimeException` instances.
[cols="1,1,1", frame="all", options="header"]
|===
| Field name
| Type
| Description

|``processInstanceId``
|``long``
|The id of the `ProcessInstance` instance in which the exception occurred. This
``ProcessInstance`` may not exist anymore or be available in the database if using
persistence!

|``processId``
|``String``
|The id of the process definition that was used to start the process (i.e.
"``ExceptionScriptTask``" in ```ksession.startProcess("ExceptionScriptTask");``` )

|``nodeId``
|``long``
|The value of the (BPMN2) id attribute of the node that threw the exception.

|``nodeName``
|``String``
|The value of the (BPMN2) name attribute of the node that threw the exception.

|``variables``
|``Map<String, Object>``
|The map containing the variables in the process instance (__experimental__).

|``message``
|``String``
|The short message indicating what went wrong.

|``cause``
|``Throwable``
|The original exception that was thrown.
|===

==== Example: Exceptions thrown by a ``<scriptTask>``.


The following code illustrates how to extract extra information from a process instance that throws a `WorkflowRuntimeException` exception instance.

[source,java]
----
import org.jbpm.workflow.instance.WorkflowRuntimeException;
import org.kie.api.KieBase;
import org.kie.api.io.ResourceType;
import org.kie.api.runtime.KieSession;
import org.kie.api.runtime.process.ProcessInstance;
import org.kie.internal.builder.KnowledgeBuilder;
import org.kie.internal.builder.KnowledgeBuilderFactory;
import org.kie.internal.io.ResourceFactory;

public class ScriptTaskExceptionExample {

    public static final void main(String[] args) {
        runExample();
    }

    public static void runExample() {
        KieSession ksession = createKieSession();
        Map<String, Object> params = new HashMap<String, Object>();
        String varName = "var1";
        params.put( varName , "valueOne" );
        try {
            ProcessInstance processInstance = ksession.startProcess("ExceptionScriptTask", params);
        } catch( WorkflowRuntimeException wfre ) {
            String msg = "An exception happened in "
                    + "process instance [" + wfre.getProcessInstanceId()
                    + "] of process [" + wfre.getProcessId()
                    + "] in node [id: " + wfre.getNodeId()
                    + ", name: " + wfre.getNodeName()
                    + "] and variable " + varName + " had the value [" + wfre.getVariables().get(varName)
                    + "]";
            System.out.println(msg);
        }
    }

    private static KieSession createKieSession() {
        KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder();
        kbuilder.add(ResourceFactory.newClassPathResource("exceptions/ScriptTaskException.bpmn2"), ResourceType.BPMN2);
        KieBase kbase = kbuilder.newKnowledgeBase();
        return kbase.newKieSession();
    }

}
----
