[id='proc-kogito-creating-project-custom_{context}']
= Creating a custom {PRODUCT} project using code scaffolding

WARNING: This feature is experimental and might be substantially modified or removed in a future release. This feature also requires a special project setup. The generated code uses APIs that in {PRODUCT} are not final and will not function the same way in future releases.

The Quarkus extension and Maven plug-in within a standard {PRODUCT} project generate all the required code and boilerplate for your {PRODUCT} services so that you do not have to write the project setup code yourself. By default, a {PRODUCT} project generates a REST service from business assets automatically. The generated service usually exposes default REST endpoints using the information that is inferred from the business assets that you include in your project.

If you want to customize the code for your {PRODUCT} project, such as adding more REST endpoints, you can use _code scaffolding_ to generate the project code to a specified user directory and then modify the code as needed.

With code scaffolding, you generate your {PRODUCT} project with the {PRODUCT} Maven archetype as usual, but you disable the project ability to automatically regenerate the project code and explicitly instruct {PRODUCT} to generate the code in a custom target directory. The code is generated one time in the specified target directory and is not regenerated at build time unless you explicitly request it. You can customize the project code in the specified target directory as needed.

NOTE: On Quarkus, disabling code regeneration also disables hot reload of business assets in development mode. This limitation will be improved in a future release.

.Procedure
. In a command terminal, navigate to a local folder where you want to store the custom {PRODUCT} project and enter the following command to generate your {PRODUCT} project with the {PRODUCT} Maven archetype as usual:
+
--
.On Quarkus
[source]
----
$ mvn archetype:generate \
    -DarchetypeGroupId=org.kie.kogito \
    -DarchetypeArtifactId=kogito-quarkus-archetype \
    -DgroupId=org.acme -DartifactId=sample-kogito \
    -Dversion=1.0-SNAPSHOT
----
////
@comment: The following standard command for Quarkus isn't working currently but may be restored for Dev Preview

mvn io.quarkus:quarkus-maven-plugin:create -DprojectGroupId=com.company -DprojectArtifactId=sample-kogito -Dextensions="kogito"
////

.On Spring Boot
[source]
----
$ mvn archetype:generate \
    -DarchetypeGroupId=org.kie.kogito \
    -DarchetypeArtifactId=kogito-springboot-archetype \
    -DgroupId=org.acme -DartifactId=sample-kogito \
    -Dversion=1.0-SNAPSHOT
----

This command generates a `sample-kogito` Maven project and imports the {PRODUCT} extension for all required dependencies and configurations to prepare your application for business automation.
--
. In the project `pom.xml` file, modify the project dependencies and plug-ins to disable code regeneration:
+
--
* *On Quarkus*: Delete the `kogito-quarkus` dependency and add the `kogito-maven-plugin` plug-in, as shown in the following examples:
+
.Deleting the `kogito-quarkus` dependency
[source,xml]
----
<dependencies>
  ...
  <dependency>
    <groupId>org.kie.kogito</groupId>
    <artifactId>kogito-quarkus</artifactId>
  </dependency>
  ...
</dependencies>
----
+
.Adding the `kogito-maven-plugin` plug-in
[source,xml]
----
<build>
  ...
  <plugins>
    ...
    <plugin>
      <groupId>org.kie.kogito</groupId>
      <artifactId>kogito-maven-plugin</artifactId>
      <configuration>
        <onDemand>true</onDemand>
      </configuration>
    </plugin>
    ...
  </plugins>
  ...
</build>
----

* *On Spring Boot*: Modify the existing `kogito-maven-plugin` plug-in as shown in the following example:
+
.Modifying the `kogito-maven-plugin` plug-in
[source,xml]
----
<build>
  ...
  <plugins>
    ...
    <plugin>
      <groupId>org.kie.kogito</groupId>
      <artifactId>kogito-maven-plugin</artifactId>
      <configuration>
        <onDemand>true</onDemand>
      </configuration>
    </plugin>
    ...
  </plugins>
  ...
</build>
----
--
. In a command terminal, navigate to the root of your {PRODUCT} project and enter the following command to generate your modified project using code scaffolding:
+
--
.Generating the {PRODUCT} project using code scaffolding
[source]
----
 $ mvn compile kogito:scaffold
----

This command consists of the following components:

* `compile`: Compiles the assets in your project.
* `kogito:scaffold`: Generates the code in `src/main/java`. In the automatic {PRODUCT} project build, the default directory is `target/generated-sources/kogito`.

If you want to override the default location for code generation, you may use the extended form:

.Generating the {PRODUCT} project using code scaffolding to a custom directory 
[source]
----
 $ mvn compile kogito:scaffold -Dkogito.codegen.sources.directory=src/main/generated-java
----

This command consists of the following components:

* `compile`: Compiles the assets in your project.
* `kogito:scaffold`: Generates the code
* `kogito.codegen.sources.directory`: Defines the target directory where you want the code to be generated, such as `src/main/generated-java` in this example. 


WARNING: If you invoke this generation command again with the same target directory, the files are overwritten. This limitation will be fixed in a future release.

In this example, the `src/main/java` directory now contains the following resources:

* Your existing project files
* Generated data classes corresponding to process variables or Decision Model and Notation (DMN) definitions
* Generated REST endpoints

This example project contains a `persons` Business Process Model and Notation (BPMN) process model, so the generated REST endpoints are modified as shown in the following Java object:

.Modified REST endpoints for a `person` BPMN process model
[source,java]
----
package org.acme.travels;

// Imports

@Path("/persons")
@ApplicationScoped
public class PersonsResource {

    @Inject
    @Named("persons")
    Process<PersonsModel> process;

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public PersonsModelOutput createResource_persons(
            @Context HttpHeaders httpHeaders,
            @QueryParam("businessKey") String businessKey,
            @Valid @NotNull PersonsModelInput resource) {
        ...
    }

    // Other endpoints
}
----

The `PersonsModel`, `PersonModelInput`, and `PersonsModelOutput` elements are the generated data models. These models are inferred automatically from the process variables in the process. Input and output models are inferred by how you tagged your process variables.

Similar endpoints are generated for any available rule units. This example project contains a `PersonValidationService` class for a rule unit model, so the generated REST endpoints are modified as shown in the following Java object:

.Modified REST endpoints for a `PersonValidationService` rule unit class
[source,java]
----
package org.acme.travels;

// Imports

@Path("/persons-validation-service")
@ApplicationScoped
public class PersonsValidationServiceResource {

    @Inject
    RuleUnit<PersonValidationService> unit;

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    public QueryResult fireRules(PersonValidationService resource) {
        ...
    }

    // Other endpoints
}
----
--

.Additional resources
ifdef::KOGITO[]
* {URL_PROCESS_SERVICES}#con-bpmn-variables_kogito-developing-process-services[Variables in {PRODUCT} processes]
endif::[]
ifdef::KOGITO-COMM[]
* xref:con-bpmn-variables_kogito-developing-process-services[]
endif::[]
* xref:proc-kogito-designing-app-rule-units_kogito-creating-running[]
