[id='con-kogito-operator-deployment-options_{context}']
= OpenShift deployment options with the {PRODUCT} Operator and CLI

The {PRODUCT} Operator and command-line interface (CLI) support the following options for building and deploying {PRODUCT} services on {OPENSHIFT}:

* Git source build and deployment
* Binary build and deployment
* File build and deployment
ifdef::KOGITO-COMM[]
* Native build and deployment
endif::[]

{PRODUCT} provides the relevant Source-to-Image (S2I) build configuration depending the deployment option that you use.

NOTE: For all deployment options, you must be logged in to the relevant OpenShift cluster using the `oc login` command.

== Git source build and deployment

In most use cases, you can use the standard runtime build and deployment method to deploy {PRODUCT} services on OpenShift from a Git repository source, as shown in the following examples. These examples are based on the https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended[`kogito-travel-agency`] extended example application.

.Example {PRODUCT} service deployment from existing namespace
[source,subs="attributes+,+quotes"]
----
// Uses the provisioned namespace in your OpenShift cluster
$ {PRODUCT_INIT} use-project __PROJECT_NAME__

// Deploys a new {PRODUCT} service from a Git source
$ {PRODUCT_INIT} deploy-service travels https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended --context-dir travels
----

The {PRODUCT} Operator uses the default branch in the specified Git repository, usually `master`.

Alternatively, you can generate a new namespace in your cluster during deployment:

.Example {PRODUCT} service deployment from new namespace
[source,subs="attributes+,+quotes"]
----
// Creates a new namespace in your cluster
$ {PRODUCT_INIT} new-project __NEW_PROJECT_NAME__

// Deploys a new {PRODUCT} service from a Git source
$ {PRODUCT_INIT} deploy-service travels https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended --context-dir travels
----

NOTE: If you are developing or testing your {PRODUCT} service locally, you can use the binary build or file build option to build and deploy from a local source instead of from a Git repository.

== Binary build and deployment

OpenShift builds can require extensive amounts of time. As a faster alternative for building and deploying your {PRODUCT} services on OpenShift, you can use a binary build. In a binary build, you build the application locally and push the built application to an OpenShift `BuildConfig` configuration to be packaged into the runtime container image.

The following example creates a {PRODUCT} service from a local directory, builds the project binaries, and deploys the binary build to OpenShift. This example is based on the https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended[`kogito-travel-agency`] extended example application.

.Example {PRODUCT} service deployment from binary build
[source,subs="attributes+,+quotes"]
----
// Creates the {PRODUCT} service
$ cd ~/kogito-travel-agency/extended/travels
$ kogito deploy-service travels

// Builds the project and generates binary resources in `target` folder
$ mvn clean package

// Deploys to OpenShift using binary build
$ oc start-build travels-binary --from-dir=target/

Uploading directory "target/" as binary input for the build ...
....
Uploading finished
build.build.openshift.io/travels-1 started
----

In this example, the following resources were generated in the `target` folder in preparation for the binary build:

* `travels-1.0-SNAPSHOT.jar`: Standard JAR file with only the classes and resources of the project.
* `travels-1.0-SNAPSHOT-runner.jar`: Executable JAR file for the project. Note that this is not an uber-JAR file because the dependencies are copied into the `target/lib` directory.
* `lib`: Directory with project dependencies.

After the binary build is complete, the result is pushed to the `travels` Image Stream that was created by the {PRODUCT} Operator and triggers a new deployment.

== File build and deployment

You can build and deploy your {PRODUCT} services from a single file, such as a Decision Model and Notation (DMN), Business Process Model and Notation (BPMN or BPMN2), Drools Rule Language (DRL), or properties file, or from a directory with multiple files. You can specify a single file from your local file system path or from a Git repository URL, or specify a file directory from a local file system path only. When you upload the file or directory to an OpenShift cluster, a new Source-to-Image (S2I) build is automatically triggered.

NOTE: You cannot upload a file directory from a Git repository. The file directory must be in your local file system. However, you can upload single files from either a Git repository or your local file system.

The following examples upload a single BPMN file from a local directory or Git repository to an OpenShift cluster for an S2I build. These examples are based on the https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended[`kogito-travel-agency`] extended example application.

.Example {PRODUCT} service deployment from a local file
[source,subs="attributes+,+quotes"]
----
$ kogito deploy-service travels /tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/travels.bpmn2

File found: /tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/travels.bpmn2.
...
The requested file(s) was successfully uploaded to OpenShift, a build with this file(s) should now be running. To see the logs, run 'oc logs -f bc/kogito-travel-agency-builder -n kogito'
----

.Example {PRODUCT} service deployment from a Git repository file
[source,subs="attributes+,+quotes"]
----
$ kogito deploy-service travels https://github.com/kiegroup/kogito-examples/blob/stable/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/travels.bpmn2

Asset found: travels.bpmn2.
...
The requested file(s) was successfully uploaded to OpenShift, a build with this file(s) should now be running. To see the logs, run 'oc logs -f bc/kogito-travel-agency-builder -n kogito'
----

As instructed in the terminal output, you can run the following command to see the build logs:

.Example build log for BPMN file build
[source]
----
$ oc logs -f bc/kogito-travel-agency-builder -n kogito

Receiving source from STDIN as file travels.bpmn2
Using docker-registry.default.svc:5000/openshift/kogito-quarkus-ubi8-s2i@sha256:729e158710dedba50a49943ba188d8f31d09568634896de9b903838fc4e34e94 as the s2i builder image
----

The following examples upload multiple files within a local directory to an OpenShift cluster for an S2I build:

.Example {PRODUCT} service deployment from multiple files in a local directory
[source,subs="attributes+,+quotes"]
----
$ kogito deploy-service travels /tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels

The provided source is a dir, packing files.
File(s) found: [/tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/flightBooking.bpmn2 /tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/hotelBooking.bpmn2 /tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/travels.bpmn2].
...
The requested file(s) was successfully uploaded to OpenShift, a build with this file(s) should now be running. To see the logs, run 'oc logs -f bc/travels-builder -n kogito'
----

For every valid file type (DMN, BPMN, BPMN2, DRL) in the specified directory, the {PRODUCT} CLI compresses the files and uploads them to the OpenShift cluster. Any other unsupported file types are not uploaded. To ensure that other file types are uploaded, consider using a source build or a binary build.

If you need to update an uploaded file or directory after you create the build, you can use the `oc start-build` command to re-upload the file or directory, as shown in the following example. An S2I build cannot identify only changed files in a directory, so you must re-upload the entire directory of files to update the build.

.Example command to re-upload a single local file to update the S2I build
----
$ oc start-build kogito-travel-agency-builder --from-file tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels/travels.bpmn2
----

.Example command to re-upload multiple files from a local directory to update the S2I build
----
$ oc start-build kogito-travel-agency-builder --from-dir tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels
----

If a build fails, use the OpenShift environment variable https://docs.openshift.com/container-platform/4.3/builds/basic-build-operations.html#builds-basic-access-build-verbosity_basic-build-operations[`BUILD_LOGLEVEL`] with the desired level as part of your deployment command, as shown in the following example:

.Example command to troubleshoot failed build from directory
[source]
----
$ kogito --verbose deploy-service travels /tmp/kogito-examples/kogito-travel-agency/extended/travels/src/main/resources/org/acme/travels --build-env BUILD_LOGLEVEL=5
----

ifdef::KOGITO-COMM[]
== Native build and deployment

NOTE: Native build and deployment is for Quarkus only and requires GraalVM.

By default, the {PRODUCT} Operator and CLI build services with traditional `java` compilers to save time and resources. The final generated artifact is a JAR file for the relevant runtime (defaults to Quarkus) with dependencies in the image user's home directory, such as `/home/kogito/bin/lib`.

However, for {PRODUCT} services on Quarkus with GraalVM (required), the {PRODUCT} Operator and CLI can build the services in native mode for direct binary execution as native code. Building in native mode uses a very low footprint on the runtime, although many resources are consumed during build time.

For more information about native build performance, see the GraalVM https://www.graalvm.org/docs/examples/java-performance-examples/[Performance examples for Java].

For more information about ahead-of-time (AOT) compilation, see the https://www.graalvm.org/docs/reference-manual/aot-compilation/[GraalVM Native Image] documentation.

The following examples build a {PRODUCT} service on Quarkus in native mode using the `--native` parameter. These examples are based on the https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended[`kogito-travel-agency`] extended example application.

.Example {PRODUCT} service native build from a local source directory
[source,subs="attributes+,+quotes"]
----
$ cd ~/kogito-travel-agency/extended/travels
$ {PRODUCT_INIT} deploy-service travels --native
----

.Example {PRODUCT} service native build from a Git repository source directory
[source,subs="attributes+,+quotes"]
----
$ {PRODUCT_INIT} deploy-service travels https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended --context-dir travels --native
----

In {PRODUCT} Operator tests, native builds take approximately 10 minutes and the build pod can consume up to 10GB of RAM and 1.5 CPU cores.

By default, a {PRODUCT} project does not contain resource requests or limits. As a result, a native build might be terminated due to insufficient memory. To prevent this behavior, you can create a minimum memory request configuration for the {PRODUCT} application build, ensuring that the build pod is allocated on an OpenShift node with enough free memory. The side effect of this configuration is that OpenShift prioritizes the build pod.

For more information about OpenShift pod prioritization based on pod requests and limits, see https://docs.okd.io/3.11/dev_guide/compute_resources.html#quality-of-service-tiers[Quality of Service Tiers] in the OpenShift documentation.

The following example is a memory request configuration for the https://github.com/kiegroup/kogito-examples/tree/stable/kogito-travel-agency/extended[`kogito-travel-agency`] extended example application:

.Example memory request configuration for `kogito-travel-agency`
[source,yaml]
----
apiVersion: app.kiegroup.org/v1alpha1
kind: KogitoBuild
metadata:
  name: travels
  namespace: kogito
spec:
  type: RemoteSource
  gitSource:
    contextDir: kogito-travel-agency/extended/travels
    uri: "https://github.com/kiegroup/kogito-examples/"
  resources:
    requests:
        memory: "4Gi"
----

IMPORTANT: Ensure that you have these resources available on your OpenShift nodes when you run native builds. If the resources are not available, the S2I build fails. You can verify currently allocated and total resources of your nodes by using the command `oc describe nodes` invoked with `admin` permission.

You can limit the maximum heap space for the JVM used for a native build. You can apply the limitation by setting the `quarkus.native.native-image-xmx` property in the `application.properties` file of your {PRODUCT} project. In this case, the build pod requires roughly `-Xmx` plus 2 GB of memory. The `-Xmx` value depends on the complexity of the application. For example, for the https://github.com/kiegroup/kogito-examples/tree/stable/process-quarkus-example[`process-quarkus-example`] example application, the `-Xmx` value `2g` is sufficient, resulting in the builder pod consuming up to 4.2 GB of memory.

You can also set resource limits for a native build pod. In the https://github.com/kiegroup/kogito-examples/tree/stable/process-quarkus-example[`process-quarkus-example`] application, 80 percent of the memory limit is used for heap space in the JVM responsible for the native build. If the computed heap space limit for the JVM is less than 1024 MB, then all the memory from resource limits is used.

The following example is a memory limit configuration for the https://github.com/kiegroup/kogito-examples/tree/stable/process-quarkus-example[`process-quarkus-example`] example application:

.Example memory request configuration for `process-quarkus-example`
[source,yaml]
----
apiVersion: app.kiegroup.org/v1alpha1
kind: KogitoBuild
metadata:
  name: process-quarkus-example
  namespace: kogito
spec:
  type: RemoteSource
  gitSource:
    contextDir: process-quarkus-example
    uri: "https://github.com/kiegroup/kogito-examples/"
  resources:
    limits:
        memory: "4Gi"
----
endif::[]
