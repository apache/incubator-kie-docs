[id='proc-task-lifecycle-custom_{context}']
= Creating a custom task lifecycle and phase

You can extend the user task lifecycle and lifecycle phases in {PRODUCT} to implement a custom lifecycle and phases as needed.

.Procedure
. To add custom lifecycle phases, implement the `org.kie.kogito.process.workitem.LifeCyclePhase` resource in the Java class for your custom lifecycle phases.
+
--
This resource implements the following key methods:

* `id`: Assigns a unique ID that is used when transitioning through phases
* `canTransition`: Provides a checkpoint between phases, if this phase can be transitioned from a specified phase
* `status`: Defines a human-readable status for this phase
* `isTerminating`: Determines if this phase is a completion stage, and if so, completes the work item and moves on to the next activity in the process
* `apply`: Enables additional updates to the work item when transitioning through phases

You can implement as many phases as needed or extend existing phases.
--
. To add a custom lifecycle, implement the `org.kie.kogito.process.workitem.LifeCycle<Map<String, Object>>` resource in the Java class for your custom lifecycle.
+
--
NOTE: To support user tasks, the parameterized type `LifeCycle` must be `Map<String, Object>`.

This resource implements the following key methods:

* `phaseById`: Retrieves the lifecycle phase by ID to verify if the phase is supported by the lifecycle implementation
* `phases`: Returns all supported phases by a specified lifecycle implementation
* `transitionTo`: Provides the main logic to handle phase transition
* `data`: Returns the current state of data for the work item

The following is an example Java class that extends the `Complete` lifecycle phase from a custom lifecycle implementation:

.Example Java class to extend the `Complete` lifecycle phase
[source,java]
----
package org.acme.travels.usertasks;

import java.util.Arrays;
import java.util.List;

import org.jbpm.process.instance.impl.workitem.Complete;
import org.kie.kogito.process.workitem.LifeCyclePhase;

public class CompleteStartedOnly extends Complete {

    private List<String> allowedTransitions = Arrays.asList(Start.ID);

    @Override
    public boolean canTransition(LifeCyclePhase phase) {
        return allowedTransitions.contains(phase.id());
    }

}
----
--

. After you implement your custom lifecycle or lifecycle phases, create a Java configuration class to enable the {PROCESS_ENGINE} to use the new lifecycle or phase instead of the default lifecycle.
+
--
In this configuration, you use the `WorkItemHandlerConfig` class as you do for any other work item handler, as shown in the following example:

.Example configuration class for a custom lifecycle phase
[source,java]
----
@ApplicationScoped
public class CustomWorkItemHandlerConfig extends DefaultWorkItemHandlerConfig {
 {
  register("Human Task", new HumanTaskWorkItemHandler(new CustomHumanTaskLifeCycle()));
 }
}
----

The work item handler is the same as the default, but instead of the default lifecycle, you pass as a constructor argument the custom implementation of the `LifeCycle` interface.
--

For example {PRODUCT} services with custom task lifecycle configurations, see the following example applications in GitHub:

* https://github.com/kiegroup/kogito-examples/tree/stable/process-usertasks-custom-lifecycle-quarkus[`process-usertasks-custom-lifecycle-quarkus`]: Example on Quarkus
* https://github.com/kiegroup/kogito-examples/tree/stable/process-usertasks-custom-lifecycle-springboot[`process-usertasks-custom-lifecycle-springboot`]: Example on Spring Boot
