[id="chap-kogito-native"]
= Building a Native Image with {PRODUCT}
ifdef::context[:parent-context: {context}]
:context: kogito-native

// Purpose statement for the assembly
[role="_abstract"]
As a developer of business processes and decisions, you can build a properly-configured application into a native executable.

.Prerequisites
* JDK 11 or later is installed.
* Apache Maven 3.6.2 or later is installed.
* Optional: [Quarkus CLI](https://quarkus.io/guides/cli-tooling) is installed

== Native build using GraalVM or Mandrel

NOTE: Native build and deployment is for Quarkus only and requires GraalVM or Mandrel.

You may create a Kogito project by either using the Maven plug-in or the Quarkus CLI. 
The following commands will create an application named `sample-kogito` already preconfigured with all the configuration flags that are required to support building a native executable.


.Creating a project using the Quarkus Maven Plug-In
[source,subs="attributes+"]
----
mvn io.quarkus:quarkus-maven-plugin:create \
   -DprojectGroupId=com.company \
   -DprojectArtifactId=sample-kogito \
   -Dextensions="kogito"
----


.Creating a project using the Quarkus CLI (alternative to Maven Plug-In)
[source,subs="attributes+"]
----
quarkus create -x kogito sample-kogito
----

For further information on how to get started see {URL_CREATING_RUNNING}#chap-kogito-creating-running[_{CREATING_RUNNING}_].

You can now build a native image using Maven or the Quarkus CLI.

.Building a native image using the Maven plug-in
[source]
----
$ mvn verify -Dnative
# running
$ ./target/sample-kogito-1.0-SNAPSHOT-runner
----

.Building a native image using the Quarkus CLI
[source]
----
$ quarkus build --native
# running
$ ./target/sample-kogito-1.0-SNAPSHOT-runner
----

=== Building a native executable using a container image

It is also possible to use a container image. In this case you do not need to have installed GraalVM. A container with GraalVM will be automatically pulled. Please notice that in this case the resulting executable will be targeting a Linux kernel. In this case the command is

.Building a native image using a container image
[source]
----
$ mvn verify -Dnative -Dquarkus.native.container-build
# alternatively
$ quarkus build --native -Dquarkus.native.container-build=true
----

You may also opt-in to use Mandrel instead of GraalVM. In this case the command is

.Building a native image using a container image (Mandrel)
[source]
----
$ mvn verify -Dnative -Dquarkus.native.container-build -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:21.1-java11
# alternatively
$ quarkus build --native -Dquarkus.native.container-build -Dquarkus.native.builder-image=quay.io/quarkus/ubi-quarkus-mandrel:21.1-java11
----

For further information on how to build a native image please follow [the Quarkus guide](https://quarkus.io/guides/building-native-image#container-runtime)

=== Creating a Container Image with Quarkus

Quarkus provides [extensions for building (and pushing) container images](https://quarkus.io/guides/container-image). 
Read the corresponding quarkus guide to build a docker image. If you pick the `jib` extension you will not even need a container daemon (such as Docker) to be running in the background.

Finally, you can push your image to a registry such as DockerHub or Quay.io and pull it from your runtime environment. Even in this case, you can [configure Quarkus to do that for you](https://quarkus.io/guides/container-image#pushing).

=== Deploying a Container Image 

You can use `kubctl` or `oc` to pull your image from the selected registry.

