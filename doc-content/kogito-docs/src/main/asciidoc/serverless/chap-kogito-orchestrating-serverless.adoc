[id="chap-kogito-orchestrating-serverless"]
= Orchestrating microservices with Serverless Workflow in {PRODUCT}
ifdef::context[:parent-context: {context}]
:context: kogito-orchestrating-serverless

// Purpose statement for the assembly
[role="_abstract"]
As a microservices developer or architect, you can use the https://github.com/serverlessworkflow/specification[Serverless Workflow specification] to orchestrate application services in your {PRODUCT} project. The Serverless Workflow specification enables you to define declarative workflow models that orchestrate event-driven, serverless applications. The specification is hosted by the https://www.cncf.io/[Cloud Native Computing Foundation (CNCF)] and is currently a CNCF https://www.cncf.io/sandbox-projects/[Sandbox project] that is progressing to become an https://www.cncf.io/projects/[Incubating project].

For more information about Serverless Workflow, see the https://serverlessworkflow.github.io/[Serverless Workflow] website.

// Modules - concepts, procedures, refs, etc.
[id="con-serverless-workflow_{context}"]
== Serverless Workflow orchestration

[role="_abstract"]
https://github.com/serverlessworkflow/specification/blob/master/specification.md[Serverless Workflow] is a specification for defining declarative workflow models that orchestrate event-driven, serverless applications. The main benefit of a Serverless Workflow strategy is that it provides a clear separation of business logic and orchestration logic in your serverless applications. Developers can focus on solving business logic inside functions and use workflows to define function invocations, specify event behavior, and provide data management for different microservices.

The https://github.com/serverlessworkflow/specification[Serverless Workflow specification] defines a vendor-neutral, platform-independent, and declarative workflow model that you can use across multiple cloud or container platforms. This portability enables you to move your workflow definitions from one cloud or container platform to another with the same execution results.

The specification is hosted by the https://www.cncf.io/[Cloud Native Computing Foundation (CNCF)] and is currently a CNCF https://www.cncf.io/sandbox-projects/[Sandbox project] that is progressing to become an https://www.cncf.io/projects/[Incubating project]. The specification has been created by CNCF community members and individuals from different companies and is a fully open source project (Apache 2.0 license).

The target users of Serverless Workflow orchestration are mostly developers and architects who want to define logical steps of execution declaratively (no code) for cloud-native services. Although you can orchestrate your services using process diagrams in https://www.omg.org/spec/BPMN/2.0/About-BPMN[Business Process Model and Notation (BPMN)], the Serverless Workflow has less focus on business definition and more focus on function-level steps of execution. Serverless Workflow is also designed specifically for microservice orchestration and therefore has a smaller scope than BPMN. Serverless Workflow also enables you to write workflows in formats (JSON or YAML) that might be better suited for developing and deploying serverless applications in cloud or container environments.

Ultimately, the choice of which specification to use for orchestrating event-driven microservices depends on your environment needs, development goals, and personal preference.

=== Serverless Workflow architecture

The https://github.com/serverlessworkflow/specification[Serverless Workflow specification] provides a https://github.com/serverlessworkflow/specification/blob/master/schema/workflow.json[JSON schema] that defines the structure of JSON or YAML workflow definitions. The specification also provides a set of SDKs for https://github.com/serverlessworkflow/sdk-java[Java] and https://github.com/serverlessworkflow/sdk-go[Go] that can help developers get started with the specification to create workflows. The specification provides a set of https://github.com/serverlessworkflow/specification/blob/master/extensions/README.md[workflow extensions], such as key performance indicators (KPIs), that you can use to enhance workflow definitions with additional information. This information can then be used during execution of the workflows to provide additional data, such as metrics for improving workflow performance.

The following diagram illustrates a general Serverless Workflow architecture:

.General Serverless Workflow architecture
image::kogito/serverless/serverless-workflow-spec-overview.png[Image of Serverless Workflow architecture]

Serverless Workflow focuses on orchestration of event-driven microservices. Although the specification provides a generic markup that you can use for general workflow or pipeline (CI/CD) definitions, its declarative nature is designed for microservice orchestration.

Similar to other specification-based standards for business automation, Serverless Workflow provides a unified core definition for workflows. For example, the following diagram illustrates a single Serverless Workflow definition that is executed on multiple runtime services. Each of these services can then be deployed onto various cloud or container platforms with the same execution results.

.Example Serverless Workflow implementation
image::kogito/serverless/serverless-workflow-example-implementation.png[Image of example Serverless Workflow implementation ,95%]

[id="con-serverless-workflow-definitions_{context}"]
=== Serverless Workflow definitions

[role="_abstract"]
In the https://github.com/serverlessworkflow/specification[Serverless Workflow specification], Serverless Workflow definitions are JSON or YAML files with the extension `.sw.json` or `.sw.yaml` that provide the orchestration details for the relevant application services.

A Serverless Workflow definition file consists of the following basic components:

.Serverless Workflow definition format in JSON
[source,json]
----
{
  "id": "sampleWorkflow",
  "version": "1.0",
  "name": "Sample Workflow",
  "description": "Sample Workflow",
  "functions": [],
  "events": [],
  "states": []
}
----

.Serverless Workflow definition format in YAML
[source,yaml]
----
id: sampleWorkflow
version: '1.0'
name: Sample Workflow
description: Sample Workflow
functions: []
events: []
states: []
----

The Serverless Workflow `functions`, `events`, and `states` are the core constructs for defining the orchestration behavior for your services. You can use one or all of these three constructs in your workflow definitions.

* `functions`: Function definitions are reusable constructs that you can use to define invocation information about services that need to be invoked during workflow execution. Function definitions can be referenced by workflow `states` (control-logic blocks) whenever a service needs to be invoked.
* `events`: Event definitions are reusable constructs that you can use to define all consumed and produced events during workflow execution. Serverless Workflow requires https://cloudevents.io/[CloudEvents] format for both consumed and produced events. Event definitions can be referenced by workflow states to determine how a workflow instance is created, what events are needed to continue workflow execution, what events need to be produced during workflow execution, and how multiple events are associated with one another (correlation rules). You can also use event definitions to trigger function or service invocation for services that do not use exposed invocation endpoints and that are only invoked by events.
* `states`: State definitions enable you to define your workflow states (control-logic blocks) and determine what your workflow should do. State definitions specify details such as how the workflow is started, what data is expected, how the workflow should transition from one state to another given some data or event constraints, error handling, and how and when the workflow execution completes.
+
The following diagram illustrates some of the control-flow constructs that you can build with Serverless Workflow state definitions:
+
.Example control-flow constructs from state definitions
image::kogito/serverless/serverless-workflow-states.png[Image of example control-flow constructs from state definitions]
+
For more information about supported workflow states, see the https://github.com/serverlessworkflow/specification/blob/master/specification.md#state-definition[Serverless Workflow specification].

For example, the following Serverless Workflow definition performs a customer credit check in a loan application service. In this example, the Serverless Workflow integrates with an external microservice to assess customer credit and approve or deny the customer loan application. After this decision is made, the service emits a CloudEvents message that includes the decision information as part of the payload. The workflow receives this callback event and triggers workflow transitions based on the credit check decision results.

.Example Serverless Workflow definition for credit check (JSON)
[source,json]
----
{
  "id": "customercreditcheck",
  "version": "1.0",
  "name": "Customer Credit Check Workflow",
  "description": "Perform Customer Credit Check",
  "functions": [
    {
      "name": "callCreditCheckMicroservice",
      "resource": "creditCheckResource",
      "type": "service"
    },
    {
      "name": "sendRejectionEmailFunction",
      "resource": "rejectEmailResource"
    }
  ],
  "events": [
    {
      "name": "CreditCheckCompletedEvent",
      "type": "creditCheckCompleteType",
      "source": "creditCheckSource",
      "correlation": [
        {
          "contextAttributeName": "customerId"
        }
      ]
    }
  ],
  "states": [
    {
      "name": "CheckCredit",
      "type": "callback",
      "start": {
        "kind": "default"
      },
      "action": {
        "functionRef": {
          "refName": "callCreditCheckMicroservice",
          "parameters": {
            "customer": "{{ $.customer }}"
          }
        }
      },
      "eventRef": "CreditCheckCompletedEvent",
      "timeout": "PT15M",
      "transition": {
        "nextState": "EvaluateDecision"
      },
      ,
      "onErrors": [
        {
          "error": "Network Connection",
          "transition": "Reject Application"
        }
      ]
    },
    {
      "name": "EvaluateDecision",
      "type": "switch",
      "dataConditions": [
        {
          "condition": "{{ $.creditCheck[?(@.decision == 'Approved')] }}",
          "transition": {
            "nextState": "StartApplication"
          }
        },
        {
          "condition": "{{ $.creditCheck[?(@.decision == 'Denied')] }}",
          "transition": {
            "nextState": "RejectApplication"
          }
        }
      ],
      "default": {
        "transition": {
          "nextState": "RejectApplication"
        }
      }
    },
    {
      "name": "StartApplication",
      "type": "subflow",
      "workflowId": "startApplicationWorkflowId",
      "end": {
        "kind": "default"
      }
    },
    {
      "name": "RejectApplication",
      "type": "operation",
      "actionMode": "sequential",
      "actions": [
        {
          "functionRef": {
            "refName": "sendRejectionEmailFunction",
            "parameters": {
              "applicant": "{{ $.customer }}"
            }
          }
        }
      ],
      "end": {
        "kind": "default"
      }
    }
  ]
}
----

.Example Serverless Workflow definition for credit check (YAML)
[source,yaml]
----
id: customercreditcheck
version: '1.0'
name: Customer Credit Check Workflow
description: Perform Customer Credit Check
functions:
- name: callCreditCheckMicroservice
  resource: creditCheckResource
  type: microservice
- name: sendRejectionEmailFunction
  resource: rejectEmailResource
events:
- name: CreditCheckCompletedEvent
  type: creditCheckCompleteType
  source: creditCheckSource
  correlation:
  - contextAttributeName: customerId
states:
- name: CheckCredit
  type: callback
  start:
    kind: default
  action:
    functionRef:
      refName: callCreditCheckMicroservice
      parameters:
        customer: "{{ $.customer }}"
  eventRef: CreditCheckCompletedEvent
  timeout: PT15M
  transition:
    nextState: EvaluateDecision
  onErrors:
    - error : Network Connection
      transition:
        nextState: RejectApplication  
- name: EvaluateDecision
  type: switch
  dataConditions:
  - condition: "{{ $.creditCheck[?(@.decision == 'Approved')] }}"
    transition:
      nextState: StartApplication
  - condition: "{{ $.creditCheck[?(@.decision == 'Denied')] }}"
    transition:
      nextState: RejectApplication
  default:
    transition:
      nextState: RejectApplication
- name: StartApplication
  type: subflow
  workflowId: startApplicationWorkflowId
  end:
    kind: default
- name: RejectApplication
  type: operation
  actionMode: sequential
  actions:
  - functionRef:
      refName: sendRejectionEmailFunction
      parameters:
        applicant: "{{ $.customer }}"
  end:
    kind: default
----

In this example, the workflow uses the following data input:

.Example data input
[source,json]
----
{
  "customer": {
    "id": "customer123",
    "name": "John Doe",
    "SSN": 123456,
    "yearlyIncome": 50000,
    "address": "123 MyLane, MyCity, MyCountry",
    "employer": "MyCompany"
  }
}
----

The example workflow receives the following callback events:

.Example callback event for approved credit check
[source,json]
----
{
  "specversion" : "1.0",
  "type" : "creditCheckCompleteType",
  "datacontenttype" : "application/json",
  ...
  "data": {
    "creditCheck": [
        {
          "id": "customer123",
          "score": 700,
          "decision": "Approved",
          "reason": "Good credit score"
        }
      ]
  }
}
----

.Example callback event for denied credit check
[source,json]
----
{
  "specversion" : "1.0",
  "type" : "creditCheckCompleteType",
  "datacontenttype" : "application/json",
  ...
  "data": {
    "creditCheck": [
        {
          "id": "customer123",
          "score": 580,
          "decision": "Denied",
          "reason": "Low credit score. Recent late payments"
        }
      ]
  }
}
----

For more Serverless Workflow definition examples, see the https://github.com/serverlessworkflow/specification/blob/master/examples/examples.md[Serverless Workflow specification].

[id="ref-serverless-workflow-use-cases_{context}"]
=== Serverless Workflow use cases

[role="_abstract"]
Use cases for the https://github.com/serverlessworkflow/specification[Serverless Workflow specification] vary widely and depend on the reference implementations and the ecosystem available during workflow execution, such as available functions, services, and events.

The following scenarios illustrate example use cases for Serverless Workflow orchestration with microservices. For more Serverless Workflow use cases, see the https://github.com/serverlessworkflow/specification/tree/master/usecases[Serverless Workflow specification].

Payment processing::
+
--
Servlerless Workflow is ideal for coordinating session-based applications, such as e-commerce sites. You can
use Serverless Workflow to coordinate all steps of the checkout process, and even enable users to take a photo of their credit card instead of having to type in the numbers and information.

.Serverless Workflow orchestration for payment processing
image::kogito/serverless/serverless-workflow-usecase-app-payment.png[Image of Serverless Workflow orchestration for payment processing]
--

Online vehicle auction::
+
--
You can use Serverless Workflow to coordinate all steps of an online vehicle auction, such as the following aspects of the orchestration:

* Authentication of users making bids
* Communication with bidding and inventory services
* Decisions to start and end the auction under certain conditions

.Serverless Workflow orchestration for online vehicle auction
image::kogito/serverless/serverless-workflow-usecase-vehicle-auction.png[Image of Serverless Workflow orchestration for online vehicle auction]
--

Data analysis::
+
--
You can use Serverless Workflow to coordinate data analysis, such as for marketing and sales information. Analysis can be scheduled on a timely basis to trigger workflow coordination of different extract, transform, load (ETL) services.

.Serverless Workflow orchestration for data analysis
image::kogito/serverless/serverless-workflow-usecase-data-analysis.png[Image of Serverless Workflow orchestration for data analysis]
--

Error notifications::
+
--
You can design Serverless Workflow definitions that trigger notifications about the success or failure of the workflow orchestration. In conjunction with available messaging services, you can notify developers on different platforms of any failures, including error information and the exact point in the execution where the failure occurred. You can also log the workflow execution status to cloud storage services for further analysis.

.Serverless Workflow orchestration for error notifications
image::kogito/serverless/serverless-workflow-usecase-error-notifications.png[Image of Serverless Workflow orchestration for error notifications]
--

Continuous integration and continuous deployment (CI/CD)::
+
--
Serverless Workflow can help you build efficient continuous integration and continuous deployment (CI/CD) solutions. Code check-ins can trigger website builds and automatic redeploys. Pull requests can trigger automated tests that ensure the code is well-tested before human reviews.

.Serverless Workflow orchestration for CI/CD
image::kogito/serverless/serverless-workflow-usecase-continuous-integration.png[Image of Serverless Workflow orchestration for CI/CD]
--

[id="con-serverless-workflow-in-kogito_{context}"]
== Serverless Workflow orchestration in {PRODUCT}

[role="_abstract"]
{PRODUCT} provides the runtime implementation that supports Serverless Workflow, including both JSON and YAML formats, in compliance with the https://github.com/serverlessworkflow/specification[Serverless Workflow specification].

You can use Serverless Workflow definition files in your {PRODUCT} project to define your domain-specific orchestration services. Your Serverless Workflow files can be in JSON or YAML format with the extension `.sw.json` or `.sw.yaml`.

The following diagram illustrates Serverless Workflow orchestration in {PRODUCT}:

.Serverless Workflow orchestration in {PRODUCT}
image::kogito/serverless/serverless-workflow-kogito.png[Image of Serverless Workflow orchestration in Kogito]

=== Serverless Workflow example in {PRODUCT}

The following example is a real-world Serverless Workflow scenario in {PRODUCT} that demonstrates how you can use Serverless Workflow definitions to orchestrate your {PRODUCT} services. In this scenario, an order service uses Serverless Workflow to process orders from multiple sources and approve or deny orders.

NOTE: For more {PRODUCT} examples that use Serverless Workflow, see the https://github.com/kiegroup/kogito-examples[`kogito-examples`] repository in GitHub.

The following diagram illustrates the basic architecture of this scenario:

.Example Serverless Workflow orchestration for processing orders in {PRODUCT}
image::kogito/serverless/serverless-workflow-kogito-orders.png[Image of example Serverless Workflow orchestration for processing orders in Kogito]

New orders can come from different sources, such as web applications or messaging services. Each order is then converted into https://cloudevents.io/[CloudEvents] messages, which represent the events that need to trigger the workflow execution. The events are pushed to an Apache Kafka topic.

New order events that are pushed to Kafka trigger new instances of the workflow. The workflow invokes a business rule service and a human task service to make the order approval decision. The business rule service can be a {PRODUCT} service with Decision Model and Notation (DMN) decision models or Drools Rule Language (DRL) rules, or it can be an external service. For this example, the rule service uses a DRL rules in {PRODUCT} to verify whether the order can be auto-approved. If the order cannot be auto-approved, then the workflow uses the human task service, which likewise can be a {PRODUCT} service or an external service, to notify a manager that the order requires human approval.

After the order decision is made, the workflow generates an event in CloudEvents format that notifies other services or other workflows that a decision was made for a particular order.

To orchestrate these services in this way, the example uses the following `ordersworkflow.sw.json` Serverless Workflow definition:

.Example `ordersworkflow.sw.json` workflow definition (JSON)
[source,json]
----
{
  "id": "ordersworkflow",
  "name": "Orders Workflow",
  "version": "1.0",
  "events": [
    {
      "name": "NewOrderEvent",
      "source": "neworder",
      "type": "kafka"
    },
    {
      "name": "ApprovalDecisionEvent",
      "source": "out-approvaldecision",
      "type": "kafka"
    }
  ],
  "functions": [
    {
      "name": "AutoAproveOrderFunction",
      "type": "rule",
      "metadata": {
        "ruleflowgroup": "neworder"
      }
    },
    {
      "name": "OrderManagerApprovalFunction",
      "type": "decision",
      "metadata": {
        "taskname": "managerApproval",
        "actorid": "managers",
        "groupid": "managers"
      }
    }
  ],
  "states": [
    {
      "name": "HandleNewOrder",
      "type": "event",
      "start": {
        "kind": "default"
      },
      "eventsActions": [
        {
          "eventRefs": [
            "NewOrderEvent"
          ],
          "actions": [
            {
              "functionRef": {
                "refName": "AutoAproveOrderFunction"
              }
            }
          ]
        }
      ],
      "transition": {
        "nextState": "CheckIfNeedManagerApproval"
      }
    },
    {
      "name": "CheckIfNeedManagerApproval",
      "type": "switch",
      "dataConditions": [
        {
          "path": "$.decision",
          "value": "Approved",
          "operator": "equals",
          "transition": {
            "nextState": "OrderAutoApproved"
          }
        },
        {
          "path": "$.decision",
          "value": "NeedManagerApproval",
          "operator": "equals",
          "transition": {
            "nextState": "OrderManagerApproval"
          }
        }
      ],
      "default": {
        "nextState": "OrderManagerApproval"
      }
    },
    {
      "name": "OrderAutoApproved",
      "type": "inject",
      "data": {
        "finalDecision": "Approved"
      },
      "end": {
        "kind": "event",
        "produceEvent": {
          "eventRef": "ApprovalDecisionEvent"
        }
      }
    },
    {
      "name": "OrderManagerApproval",
      "type": "operation",
      "actionMode": "sequential",
      "actions": [
        {
          "name": "managerAprovalAction",
          "functionRef": {
            "refName": "OrderManagerApprovalFunction"
          }
        }
      ],
      "end": {
        "kind": "event",
        "produceEvent": {
          "eventRef": "ApprovalDecisionEvent"
        }
      }
    }
  ]
}
----

The following diagram illustrates the basic structure and sequence of this example workflow definition:

.Structure of the example `ordersworkflow.sw.json` workflow definition
image::kogito/serverless/serverless-workflow-kogito-orders-structure.png[Image of `ordersworkflow.sw.json` workflow definition]

The `HandleNewOrder` state is the workflow starting state. This state is an `event` type state that requires one or more events to be consumed before the workflow can be invoked. This event state defines the instances of this workflow that are created when the referenced `NewOrderEvent` is consumed. In this case, events are consumed via Kafka.

After the `NewOrderEvent` is consumed, the state defines a list of `actions` to be performed. Actions define all the functions or services that must be invoked as part of the workflow. In this case, a single `AutoApproveOrderFunction` function or service defines how to invoke the rule service.

After the execution of the rule service is complete, the event state specifies that the workflow must transition to the `CheckIfNeedManagerApprvoal` state, which is a `switch` type state. The order is then either auto-approved if no manager approval is required, or is assigned to a manager to complete the remaining states of the workflow.

For more {PRODUCT} examples that use Serverless Workflow, see the following example applications in GitHub:

* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-events-quarkus[`serverless-workflow-events-quarkus`]: A Serverless Workflow service for processing job applicant approvals and that showcases event-driven services
* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-greeting-quarkus[`serverless-workflow-greeting-quarkus`] and https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-greeting-springboot[`serverless-workflow-greeting-springboot`]: A Serverless Workflow greeting service with both JSON and YAML workflow definitions
* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-service-calls-quarkus[`serverless-workflow-service-calls-quarkus`] and https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-service-calls-springboot[`serverless-workflow-service-calls-springboot`]: A Serverless Workflow service for returning country information
* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-github-showcase[`serverless-workflow-github-showcase`]: In this example we will deploy a GitHub "bot" application that will react upon a new PR being opened in a given GitHub project. The "bot" is implemented via service and event orchestration approach with Kogito implementation of the Serverless Workflow specification.

[id="proc-serverless-workflow-definitions_{context}"]
== Creating and editing Serverless Workflow definitions in {PRODUCT}

[role="_abstract"]
You can use https://github.com/serverlessworkflow/specification/blob/master/specification.md[Serverless Workflow] definition files in your {PRODUCT} project to define your domain-specific orchestration services. Your Serverless Workflow definition files can be in JSON or YAML format with the extension `.sw.json` or `.sw.yaml`.

.Prerequisites
* You have created a {PRODUCT} project and have included any Java objects or other business assets required for your Serverless Workflow service. For information about creating a project, see {URL_CREATING_RUNNING}#chap-kogito-creating-running[_{CREATING_RUNNING}_].

.Procedure
. In your {PRODUCT} project, create or import a `.sw.json` or `.sw.yaml` Serverless Workflow definition file in the relevant folder, typically in `src/main/resources`.
+
{PRODUCT} supports both JSON and YAML formats for workflow definitions. You can use multiple workflow definitions in both formats if needed.
. Open the workflow definition file and define the following basic components:
+
--
.Serverless Workflow definition format in JSON
[source,json]
----
{
  "id": "sampleWorkflow",
  "version": "1.0",
  "name": "Sample Workflow",
  "description": "Sample Workflow",
  "functions": [],
  "events": [],
  "states": []
}
----

.Serverless Workflow definition format in YAML
[source,yaml]
----
id: sampleWorkflow
version: '1.0'
name: Sample Workflow
description: Sample Workflow
functions: []
events: []
states: []
----

The Serverless Workflow `functions`, `events`, and `states` are the core constructs for defining the orchestration behavior for your services. You can use one or all of these three constructs in your workflow definitions.

* `functions`: Function definitions are reusable constructs that you can use to define invocation information about services that need to be invoked during workflow execution. Function definitions can be referenced by workflow `states` (control-logic blocks) whenever a service needs to be invoked.
* `events`: Event definitions are reusable constructs that you can use to define all consumed and produced events during workflow execution. Serverless Workflow requires https://cloudevents.io/[CloudEvents] format for both consumed and produced events. Event definitions can be referenced by workflow states to determine how a workflow instance is created, what events are needed to continue workflow execution, what events need to be produced during workflow execution, and how multiple events are associated with one another (correlation rules). You can also use event definitions to trigger function or service invocation for services that do not use exposed invocation endpoints and that are only invoked by events.
* `states`: State definitions enable you to define your workflow states (control-logic blocks) and determine what your workflow should do. State definitions specify details such as how the workflow is started, what data is expected, how the workflow should transition from one state to another given some data or event constraints, and how and when the workflow execution completes.

For example, the following Serverless Workflow definition performs a customer credit check in a loan application service to approve or deny the customer loan application:

.Example Serverless Workflow definition for credit check (JSON)
[source,json]
----
{
  "id": "customercreditcheck",
  "version": "1.0",
  "name": "Customer Credit Check Workflow",
  "description": "Perform Customer Credit Check",
  "functions": [
    {
      "name": "callCreditCheckMicroservice",
      "resource": "creditCheckResource",
      "type": "service"
    },
    {
      "name": "sendRejectionEmailFunction",
      "resource": "rejectEmailResource"
    }
  ],
  "events": [
    {
      "name": "CreditCheckCompletedEvent",
      "type": "creditCheckCompleteType",
      "source": "creditCheckSource",
      "correlation": [
        {
          "contextAttributeName": "customerId"
        }
      ]
    }
  ],
  "states": [
    {
      "name": "CheckCredit",
      "type": "callback",
      "start": {
        "kind": "default"
      },
      "action": {
        "functionRef": {
          "refName": "callCreditCheckMicroservice",
          "parameters": {
            "customer": "{{ $.customer }}"
          }
        }
      },
      "eventRef": "CreditCheckCompletedEvent",
      "timeout": "PT15M",
      "transition": {
        "nextState": "EvaluateDecision"
      }
    },
    {
      "name": "EvaluateDecision",
      "type": "switch",
      "dataConditions": [
        {
          "condition": "{{ $.creditCheck[?(@.decision == 'Approved')] }}",
          "transition": {
            "nextState": "StartApplication"
          }
        },
        {
          "condition": "{{ $.creditCheck[?(@.decision == 'Denied')] }}",
          "transition": {
            "nextState": "RejectApplication"
          }
        }
      ],
      "default": {
        "transition": {
          "nextState": "RejectApplication"
        }
      }
    },
    {
      "name": "StartApplication",
      "type": "subflow",
      "workflowId": "startApplicationWorkflowId",
      "end": {
        "kind": "default"
      }
    },
    {
      "name": "RejectApplication",
      "type": "operation",
      "actionMode": "sequential",
      "actions": [
        {
          "functionRef": {
            "refName": "sendRejectionEmailFunction",
            "parameters": {
              "applicant": "{{ $.customer }}"
            }
          }
        }
      ],
      "end": {
        "kind": "default"
      }
    }
  ]
}
----

.Example Serverless Workflow definition for credit check (YAML)
[source,yaml]
----
id: customercreditcheck
version: '1.0'
name: Customer Credit Check Workflow
description: Perform Customer Credit Check
functions:
- name: callCreditCheckMicroservice
  resource: creditCheckResource
  type: microservice
- name: sendRejectionEmailFunction
  resource: rejectEmailResource
events:
- name: CreditCheckCompletedEvent
  type: creditCheckCompleteType
  source: creditCheckSource
  correlation:
  - contextAttributeName: customerId
states:
- name: CheckCredit
  type: callback
  start:
    kind: default
  action:
    functionRef:
      refName: callCreditCheckMicroservice
      parameters:
        customer: "{{ $.customer }}"
  eventRef: CreditCheckCompletedEvent
  timeout: PT15M
  transition:
    nextState: EvaluateDecision
- name: EvaluateDecision
  type: switch
  dataConditions:
  - condition: "{{ $.creditCheck[?(@.decision == 'Approved')] }}"
    transition:
      nextState: StartApplication
  - condition: "{{ $.creditCheck[?(@.decision == 'Denied')] }}"
    transition:
      nextState: RejectApplication
  default:
    transition:
      nextState: RejectApplication
- name: StartApplication
  type: subflow
  workflowId: startApplicationWorkflowId
  end:
    kind: default
- name: RejectApplication
  type: operation
  actionMode: sequential
  actions:
  - functionRef:
      refName: sendRejectionEmailFunction
      parameters:
        applicant: "{{ $.customer }}"
  end:
    kind: default
----

For more Serverless Workflow definition examples in {PRODUCT}, see xref:con-serverless-workflow-in-kogito_kogito-orchestrating-serverless[].
--
. Continue adding and defining any remaining components for your workflow definition files and save the completed files.

After you define your serverless workflow definitions, you can build and deploy your {PRODUCT} services as usual to your preferred cloud or container platform, such as {OPENSHIFT}. When an event trigger occurs, your application orchestrates your {PRODUCT} services according to the workflow definition or definitions that you have defined. If you are using a serverless deployment platform, such as OpenShift Serverless, your application automatically scales up based on incoming demand, or scales to zero after use.

[role="_additional-resources"]
.Additional resources
* {URL_CREATING_RUNNING}#chap-kogito-creating-running[_{CREATING_RUNNING}_]
* {URL_DEPLOYING_ON_OPENSHIFT}#chap-kogito-deploying-on-openshift[_{DEPLOYING_ON_OPENSHIFT}_]

ifdef::KOGITO-ENT[]
[role="_additional-resources"]
== Additional resources
* {URL_CREATING_RUNNING}[_{CREATING_RUNNING}_]
* {URL_DEPLOYING_ON_OPENSHIFT}[_{DEPLOYING_ON_OPENSHIFT}_]
* {URL_DECISION_SERVICES}[_{DECISION_SERVICES}_]
* {URL_PROCESS_SERVICES}[_{PROCESS_SERVICES}_]
* {URL_CONFIGURING_KOGITO}[_{CONFIGURING_KOGITO}_]
endif::[]

ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]

[id="con-serverless-workflow-error-handling_{context}"]
== Error handling in Serverless Workflow

You can handle the exceptions that are thrown by `operation` nodes as described in the https://github.com/serverlessworkflow/specification/blob/main/specification.md#Workflow-Error-Handling[Serverless Workflow Specification].

NOTE: You need to specify the qualified name of the exception that might be thrown by the `operation` in the `code` field of the error definition.

The following is an example that invokes an `EvenService`, which is throwing `IllegalArgumentException` if the number in the workflow model is odd.
----
{
  "id": "error",
  "version": "1.0",
  "name": "Workflow Error example",
  "description": "An example of how to handle an exception thrown by a service",
  "start": "checkEven",
  "functions": [
    {
      "name": "isEven",
      "metadata": {
        "interface": "org.kie.kogito.examples.EvenService",
        "operation": "isEven",
        "type": "service"
      }
    },
    {
      "name": "printMessage",
      "metadata": {
        "type": "sysout"
      }
    }
  ],
  "states": [
    {
      "name": "checkEven",
      "type": "operation",
      "actions": [
        {
          "name": "checkEvenAction",
          "functionRef": {
            "refName": "isEven",
            "arguments": {
              "number": "$.number"
            }
          }
        }
      ],
      "transition": "even",
      "onErrors": [
        {
          "error": "odd number",
          "code": "java.lang.IllegalArgumentException",
          "transition": "odd"
        }
      ]
    },
    {
      "name": "even",
      "type": "inject",
      "data": {
        "numberType": "even"
      },
      "transition": "finish"
    },
    {
      "name": "odd",
      "type": "inject",
      "data": {
        "numberType": "odd"
      },
      "transition": "finish"
    },
    {
      "name": "finish",
      "type": "operation",
      "actions": [
        {
          "name": "printAction",
          "functionRef": {
            "refName": "printMessage",
            "arguments": {
              "message": "$.numberType"
            }
          }
        }
      ],
      "end": {
        "terminate": "true"
      }
    }
  ]
} 
----


