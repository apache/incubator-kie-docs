[id='proc-serverless-workflow-definitions_{context}']
= Creating and editing Serverless Workflow definitions in {PRODUCT}

You can use https://github.com/serverlessworkflow/specification/blob/master/specification.md[Serverless Workflow] definition files in your {PRODUCT} project to define your domain-specific orchestration services. Your Serverless Workflow definition files can be in JSON or YAML format with the extension `.sw.json` or `.sw.yaml`.

.Prerequisites
* You have created a {PRODUCT} project and have included any Java objects or other business assets required for your Serverless Workflow service. For information about creating a project, see
ifdef::KOGITO[]
{URL_CREATING_RUNNING}[_{CREATING_RUNNING}_].
endif::[]
ifdef::KOGITO-COMM[]
xref:chap-kogito-creating-running[].
endif::[]

.Procedure
. In your {PRODUCT} project, create or import a `.sw.json` or `.sw.yaml` Serverless Workflow definition file in the relevant folder, typically in `src/main/resources`.
+
{PRODUCT} supports both JSON and YAML formats for workflow definitions. You can use multiple workflow definitions in both formats if needed.
. Open the workflow definition file and define the following basic components:
+
--
.Serverless Workflow definition format in JSON
[source,json]
----
{
  "id": "sampleWorkflow",
  "version": "1.0",
  "name": "Sample Workflow",
  "description": "Sample Workflow",
  "functions": [],
  "events": [],
  "states": []
}
----

.Serverless Workflow definition format in YAML
[source,yaml]
----
id: sampleWorkflow
version: '1.0'
name: Sample Workflow
description: Sample Workflow
functions: []
events: []
states: []
----

The Serverless Workflow `functions`, `events`, and `states` are the core constructs for defining the orchestration behavior for your services. You can use one or all of these three constructs in your workflow definitions.

* `functions`: Function definitions are reusable constructs that you can use to define invocation information about services that need to be invoked during workflow execution. Function definitions can be referenced by workflow `states` (control-logic blocks) whenever a service needs to be invoked.
* `events`: Event definitions are reusable constructs that you can use to define all consumed and produced events during workflow execution. Serverless Workflow requires https://cloudevents.io/[CloudEvents] format for both consumed and produced events. Event definitions can be referenced by workflow states to determine how a workflow instance is created, what events are needed to continue workflow execution, what events need to be produced during workflow execution, and how multiple events are associated with one another (correlation rules). You can also use event definitions to trigger function or service invocation for services that do not use exposed invocation endpoints and that are only invoked by events.
* `states`: State definitions enable you to define your workflow states (control-logic blocks) and determine what your workflow should do. State definitions specify details such as how the workflow is started, what data is expected, how the workflow should transition from one state to another given some data or event constraints, and how and when the workflow execution completes.

For example, the following Serverless Workflow definition performs a customer credit check in a loan application service to approve or deny the customer loan application:

.Example Serverless Workflow definition for credit check (JSON)
[source,json]
----
{
  "id": "customercreditcheck",
  "version": "1.0",
  "name": "Customer Credit Check Workflow",
  "description": "Perform Customer Credit Check",
  "functions": [
    {
      "name": "callCreditCheckMicroservice",
      "resource": "creditCheckResource",
      "type": "service"
    },
    {
      "name": "sendRejectionEmailFunction",
      "resource": "rejectEmailResource"
    }
  ],
  "events": [
    {
      "name": "CreditCheckCompletedEvent",
      "type": "creditCheckCompleteType",
      "source": "creditCheckSource",
      "correlation": [
        {
          "contextAttributeName": "customerId"
        }
      ]
    }
  ],
  "states": [
    {
      "name": "CheckCredit",
      "type": "callback",
      "start": {
        "kind": "default"
      },
      "action": {
        "functionRef": {
          "refName": "callCreditCheckMicroservice",
          "parameters": {
            "customer": "{{ $.customer }}"
          }
        }
      },
      "eventRef": "CreditCheckCompletedEvent",
      "timeout": "PT15M",
      "transition": {
        "nextState": "EvaluateDecision"
      }
    },
    {
      "name": "EvaluateDecision",
      "type": "switch",
      "dataConditions": [
        {
          "condition": "{{ $.creditCheck[?(@.decision == 'Approved')] }}",
          "transition": {
            "nextState": "StartApplication"
          }
        },
        {
          "condition": "{{ $.creditCheck[?(@.decision == 'Denied')] }}",
          "transition": {
            "nextState": "RejectApplication"
          }
        }
      ],
      "default": {
        "transition": {
          "nextState": "RejectApplication"
        }
      }
    },
    {
      "name": "StartApplication",
      "type": "subflow",
      "workflowId": "startApplicationWorkflowId",
      "end": {
        "kind": "default"
      }
    },
    {
      "name": "RejectApplication",
      "type": "operation",
      "actionMode": "sequential",
      "actions": [
        {
          "functionRef": {
            "refName": "sendRejectionEmailFunction",
            "parameters": {
              "applicant": "{{ $.customer }}"
            }
          }
        }
      ],
      "end": {
        "kind": "default"
      }
    }
  ]
}
----

.Example Serverless Workflow definition for credit check (YAML)
[source,yaml]
----
id: customercreditcheck
version: '1.0'
name: Customer Credit Check Workflow
description: Perform Customer Credit Check
functions:
- name: callCreditCheckMicroservice
  resource: creditCheckResource
  type: microservice
- name: sendRejectionEmailFunction
  resource: rejectEmailResource
events:
- name: CreditCheckCompletedEvent
  type: creditCheckCompleteType
  source: creditCheckSource
  correlation:
  - contextAttributeName: customerId
states:
- name: CheckCredit
  type: callback
  start:
    kind: default
  action:
    functionRef:
      refName: callCreditCheckMicroservice
      parameters:
        customer: "{{ $.customer }}"
  eventRef: CreditCheckCompletedEvent
  timeout: PT15M
  transition:
    nextState: EvaluateDecision
- name: EvaluateDecision
  type: switch
  dataConditions:
  - condition: "{{ $.creditCheck[?(@.decision == 'Approved')] }}"
    transition:
      nextState: StartApplication
  - condition: "{{ $.creditCheck[?(@.decision == 'Denied')] }}"
    transition:
      nextState: RejectApplication
  default:
    transition:
      nextState: RejectApplication
- name: StartApplication
  type: subflow
  workflowId: startApplicationWorkflowId
  end:
    kind: default
- name: RejectApplication
  type: operation
  actionMode: sequential
  actions:
  - functionRef:
      refName: sendRejectionEmailFunction
      parameters:
        applicant: "{{ $.customer }}"
  end:
    kind: default
----

For more Serverless Workflow definition examples in {PRODUCT}, see xref:con-serverless-workflow-in-kogito_kogito-orchestrating-serverless[].
--
. Continue adding and defining any remaining components for your workflow definition files and save the completed files.

After you define your serverless workflow definitions, you can build and deploy your {PRODUCT} services as usual to your preferred cloud or container platform, such as {OPENSHIFT}. When an event trigger occurs, your application orchestrates your {PRODUCT} services according to the workflow definition or definitions that you have defined. If you are using a serverless deployment platform, such as OpenShift Serverless, your application automatically scales up based on incoming demand, or scales to zero after use.

.Additional resources
ifdef::KOGITO[]
* {URL_CREATING_RUNNING}[_{CREATING_RUNNING}_]
* {URL_DEPLOYING_ON_OPENSHIFT}[_{DEPLOYING_ON_OPENSHIFT}_]
endif::[]
ifdef::KOGITO-COMM[]
* xref:chap-kogito-creating-running[]
* xref:chap-kogito-deploying-on-openshift[]
endif::[]
