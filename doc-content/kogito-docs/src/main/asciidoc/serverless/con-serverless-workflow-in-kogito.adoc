[id='con-serverless-workflow-in-kogito_{context}']
= Serverless Workflow orchestration in {PRODUCT}

{PRODUCT} provides the runtime implementation that supports Serverless Workflow, including both JSON and YAML formats, in compliance with the https://github.com/serverlessworkflow/specification[Serverless Workflow specification].

You can use Serverless Workflow definition files in your {PRODUCT} project to define your domain-specific orchestration services. Your Serverless Workflow files can be in JSON or YAML format with the extension `.sw.json` or `.sw.yaml`.

The following diagram illustrates Serverless Workflow orchestration in {PRODUCT}:

.Serverless Workflow orchestration in {PRODUCT}
image::kogito/serverless/serverless-workflow-kogito.png[Image of Serverless Workflow orchestration in Kogito]

== Serverless Workflow example in {PRODUCT}

The following example is a real-world Serverless Workflow scenario in {PRODUCT} that demonstrates how you can use Serverless Workflow definitions to orchestrate your {PRODUCT} services. In this scenario, an order service uses Serverless Workflow to process orders from multiple sources and approve or deny orders.

NOTE: This example is based on the `orders-demo` application in the https://github.com/Serverless-Workflow-Kogito[`Serverless-Workflow-Kogito`] repository in GitHub. However, this example may differ from the exact example source code as {PRODUCT} continues to be developed. For more example {PRODUCT} services that use Serverless Workflow, see the https://github.com/kiegroup/kogito-examples[`kogito-examples`] repository in GitHub.

The following diagram illustrates the basic architecture of this scenario:

.Example Serverless Workflow orchestration for processing orders in {PRODUCT}
image::kogito/serverless/serverless-workflow-kogito-orders.png[Image of example Serverless Workflow orchestration for processing orders in Kogito]

New orders can come from different sources, such as web applications or messaging services. Each order is then converted into https://cloudevents.io/[CloudEvents] messages, which represent the events that need to trigger the workflow execution. The events are pushed to an Apache Kafka topic.

New order events that are pushed to Kafka trigger new instances of the workflow. The workflow invokes a business rule service and a human task service to make the order approval decision. The business rule service can be a {PRODUCT} service with Decision Model and Notation (DMN) decision models or Drools Rule Language (DRL) rules, or it can be an external service. For this example, the rule service uses a DRL rules in {PRODUCT} to verify whether the order can be auto-approved. If the order cannot be auto-approved, then the workflow uses the human task service, which likewise can be a {PRODUCT} service or an external service, to notify a manager that the order requires human approval.

After the order decision is made, the workflow generates an event in CloudEvents format that notifies other services or other workflows that a decision was made for a particular order.

To orchestrate these services in this way, the example uses the following `ordersworkflow.sw.json` Serverless Workflow definition:

.Example `ordersworkflow.sw.json` workflow definition (JSON)
[source,json]
----
{
  "id": "ordersworkflow",
  "name": "Orders Workflow",
  "version": "1.0",
  "events": [
    {
      "name": "NewOrderEvent",
      "source": "neworder",
      "type": "kafka"
    },
    {
      "name": "ApprovalDecisionEvent",
      "source": "out-approvaldecision",
      "type": "kafka"
    }
  ],
  "functions": [
    {
      "name": "AutoAproveOrderFunction",
      "type": "rule",
      "metadata": {
        "ruleflowgroup": "neworder"
      }
    },
    {
      "name": "OrderManagerApprovalFunction",
      "type": "decision",
      "metadata": {
        "taskname": "managerApproval",
        "actorid": "managers",
        "groupid": "managers"
      }
    }
  ],
  "states": [
    {
      "name": "HandleNewOrder",
      "type": "event",
      "start": {
        "kind": "default"
      },
      "eventsActions": [
        {
          "eventRefs": [
            "NewOrderEvent"
          ],
          "actions": [
            {
              "functionRef": {
                "refName": "AutoAproveOrderFunction"
              }
            }
          ]
        }
      ],
      "transition": {
        "nextState": "CheckIfNeedManagerApproval"
      }
    },
    {
      "name": "CheckIfNeedManagerApproval",
      "type": "switch",
      "dataConditions": [
        {
          "path": "$.decision",
          "value": "Approved",
          "operator": "equals",
          "transition": {
            "nextState": "OrderAutoApproved"
          }
        },
        {
          "path": "$.decision",
          "value": "NeedManagerApproval",
          "operator": "equals",
          "transition": {
            "nextState": "OrderManagerApproval"
          }
        }
      ],
      "default": {
        "nextState": "OrderManagerApproval"
      }
    },
    {
      "name": "OrderAutoApproved",
      "type": "inject",
      "data": {
        "finalDecision": "Approved"
      },
      "end": {
        "kind": "event",
        "produceEvent": {
          "eventRef": "ApprovalDecisionEvent"
        }
      }
    },
    {
      "name": "OrderManagerApproval",
      "type": "operation",
      "actionMode": "sequential",
      "actions": [
        {
          "name": "managerAprovalAction",
          "functionRef": {
            "refName": "OrderManagerApprovalFunction"
          }
        }
      ],
      "end": {
        "kind": "event",
        "produceEvent": {
          "eventRef": "ApprovalDecisionEvent"
        }
      }
    }
  ]
}
----

The following diagram illustrates the basic structure and sequence of this example workflow definition:

.Structure of the example `ordersworkflow.sw.json` workflow definition
image::kogito/serverless/serverless-workflow-kogito-orders-structure.png[Image of `ordersworkflow.sw.json` workflow definition]

The `HandleNewOrder` state is the workflow starting state. This state is an `event` type state that requires one or more events to be consumed before the workflow can be invoked. This event state defines the instances of this workflow that are created when the referenced `NewOrderEvent` is consumed. In this case, events are consumed by Kafka.

After the `NewOrderEvent` is consumed, the state defines a list of `actions` to be performed. Actions define all the functions or services that must be invoked as part of the workflow. In this case, a single `AutoApproveOrderFunction` function or service defines how to invoke the rule service.

After the execution of the rule service is complete, the event state specifies that the workflow must transition to the `CheckIfNeedManagerApprvoal` state, which is a `switch` type state. The order is then either auto-approved if no manager approval is required, or is assigned to a manager to complete the remaining states of the workflow.

For more example {PRODUCT} services that use Serverless Workflow, see the following example applications in GitHub:

* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-events-quarkus[`serverless-workflow-events-quarkus`]: A Serverless Workflow service for processing job applicant approvals and that showcases event-driven services
* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-greeting-quarkus[`serverless-workflow-greeting-quarkus`] and https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-greeting-springboot[`serverless-workflow-greeting-springboot`]: A Serverless Workflow greeting service with both JSON and YAML workflow definitions
* https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-service-calls-quarkus[`serverless-workflow-service-calls-quarkus`] and https://github.com/kiegroup/kogito-examples/tree/stable/serverless-workflow-service-calls-springboot[`serverless-workflow-service-calls-springboot`]: A Serverless Workflow service for returning country information
