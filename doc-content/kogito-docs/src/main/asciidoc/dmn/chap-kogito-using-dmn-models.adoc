[id="chap-kogito-using-dmn-models"]
= Using DMN models in {PRODUCT} services
ifdef::context[:parent-context: {context}]
:context: kogito-dmn-models

[role="_abstract"]
As a developer of business decisions, you can use Decision Model and Notation (DMN) to model a decision service graphically. The decision requirements of a DMN decision model are determined by a decision requirements graph (DRG) that is depicted in one or more decision requirements diagrams (DRDs). A DRD can represent part or all of the overall DRG for the DMN model. DRDs trace business decisions from start to finish, with each decision node using logic defined in DMN boxed expressions such as decision tables.

{PRODUCT} provides runtime support for DMN 1.1, 1.2, 1.3, and 1.4 models at conformance level 3 and design support for DMN 1.2 models at conformance level 3. You can design your DMN models with the {PRODUCT} DMN modeler in VSCode or import existing DMN models into your {PRODUCT} projects for deployment and execution. Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import, open in the DMN designer, and save are converted to DMN 1.2 models.

For more information about DMN, see the Object Management Group (OMG) https://www.omg.org/spec/DMN[Decision Model and Notation specification].

// tag::ref-decision-authoring-assets[]
[id="ref-decision-authoring-assets_{context}"]
== Decision-authoring assets in {PRODUCT}

[role="_abstract"]
{PRODUCT} supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.

The following table highlights the main decision-authoring assets supported in {PRODUCT} projects to help you decide or confirm the best method for defining decisions in your decision service.

.Decision-authoring assets supported in {PRODUCT}
[cols="20%,40%,20%,20%", options="header"]
|===
|Asset
|Highlights
|Authoring tools
|Documentation

|Decision Model and Notation (DMN) models
a|
* Are decision models based on a notation standard defined by the Object Management Group (OMG)
* Use graphical decision requirements diagrams (DRDs) that represent part or all of the overall decision requirements graph (DRG) to trace business decision flows
* Use an XML schema that allows the DMN models to be shared between DMN-compliant platforms
* Support Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions
* Can be integrated efficiently with Business Process Model and Notation (BPMN) process models
* Are optimal for creating comprehensive, illustrative, and stable decision flows
|{PRODUCT} DMN modeler in VSCode or other DMN-compliant editor
|xref:con-dmn_kogito-dmn-models[]

|DRL rules
a|
* Are individual rules that you define directly in `.drl` text files
* Provide the most flexibility for defining rules and other technicalities of rule behavior
* Are optimal for creating rules that require advanced DRL options, such as rule units
* Have strict syntax requirements for rules to be compiled properly
|Any integrated development environment (IDE)
|xref:con-drl_kogito-drl-rules[]

|Spreadsheet decision tables
a|
* Are tabular sets of rules that you define in `.xls` or `.xlsx` spreadsheet files
* Support template keys and values for creating rule templates
* Are optimal for business environments that already rely on decision tables for rules
* Have strict syntax requirements for rules to be compiled properly when used in {PRODUCT}
|Spreadsheet editor
|xref:con-decision-tables_kogito-decision-tables[]
|===
// end::ref-decision-authoring-assets[]

[id="con-dmn_{context}"]
== Decision Model and Notation (DMN)

[role="_abstract"]
Decision Model and Notation (DMN) is a standard established by the https://www.omg.org/[Object Management Group (OMG)] for describing and modeling operational decisions. DMN defines an XML schema that enables DMN models to be shared between DMN-compliant platforms and across organizations so that business analysts and business rules developers can collaborate in designing and implementing DMN decision services. The DMN standard is similar to and can be used together with the Business Process Model and Notation (BPMN) standard for designing and modeling business processes.

For more information about the background and applications of DMN, see the OMG https://www.omg.org/spec/DMN[Decision Model and Notation specification].

[id="con-dmn-conformance-levels_{context}"]
=== DMN conformance levels

[role="_abstract"]
The DMN specification defines three incremental levels of conformance in a software implementation. A product that claims compliance at one level must also be compliant with any preceding levels. For example, a conformance level 3 implementation must also include the supported components in conformance levels 1 and 2. For the formal definitions of each conformance level, see the OMG https://www.omg.org/spec/DMN[Decision Model and Notation specification].

The following list summarizes the three DMN conformance levels:

Conformance level 1::
A DMN conformance level 1 implementation supports decision requirement diagrams (DRDs), decision logic, and decision tables, but decision models are not executable. Any language can be used to define the expressions, including natural, unstructured languages.

Conformance level 2::
A DMN conformance level 2 implementation includes the requirements in conformance level 1, and supports Simplified Friendly Enough Expression Language (S-FEEL) expressions and fully executable decision models.

Conformance level 3::
A DMN conformance level 3 implementation includes the requirements in conformance levels 1 and 2, and supports Friendly Enough Expression Language (FEEL) expressions, the full set of boxed expressions, and fully executable decision models.

{PRODUCT} provides runtime support for DMN 1.1, 1.2, 1.3, and 1.4 models at conformance level 3 and design support for DMN 1.2 models at conformance level 3. You can design your DMN models with the {PRODUCT} DMN modeler in VSCode or import existing DMN models into your {PRODUCT} projects for deployment and execution. Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import, open in the DMN designer, and save are converted to DMN 1.2 models.

[id="ref-dmn-drd-components-ref-{context}"]
=== DMN decision requirements diagram (DRD) components

[role="_abstract"]
A decision requirements diagram (DRD) is a visual representation of your DMN model. A DRD can represent part or all of the overall decision requirements graph (DRG) for the DMN model. DRDs trace business decisions using decision nodes, business knowledge models, sources of business knowledge, input data, and decision services.

The following table summarizes the components in a DRD:

.DRD components
[cols="20%,20%,40%,20%" options="header"]
|===
2+|Component
|Description
|Notation

.5+|Elements
|Decision
|Node where one or more input elements determine an output based on defined decision logic.
a|
image::kogito/dmn/dmn-decision-node.png[]

|Business knowledge model
|Reusable function with one or more decision elements. Decisions that have the same logic but depend on different sub-input data or sub-decisions use business knowledge models to determine which procedure to follow.
a|
image::kogito/dmn/dmn-bkm-node.png[]

|Knowledge source
|External authorities, documents, committees, or policies that regulate a decision or business knowledge model. Knowledge sources are references to real-world factors rather than executable business rules.
a|
image::kogito/dmn/dmn-knowledge-source-node.png[]

|Input data
|Information used in a decision node or a business knowledge model. Input data usually includes business-level concepts or objects relevant to the business, such as loan applicant data used in a lending strategy.
a|
image::kogito/dmn/dmn-input-data-node.png[]

|Decision service
a|Top-level decision containing a set of reusable decisions published as a service for invocation. A decision service can be invoked from an external application or a BPMN business process.

a|
image::kogito/dmn/dmn-decision-service-node.png[]

.3+|Requirement connectors
|Information requirement
|Connection from an input data node or decision node to another decision node that requires the information.
a|
image::kogito/dmn/dmn-info-connector.png[]

|Knowledge requirement
|Connection from a business knowledge model to a decision node or to another business knowledge model that invokes the decision logic.
a|
image::kogito/dmn/dmn-knowledge-connector.png[]

|Authority requirement
|Connection from an input data node or a decision node to a dependent knowledge source or from a knowledge source to a decision node, business knowledge model, or another knowledge source.
a|
image::kogito/dmn/dmn-authority-connector.png[]

.2+|Artifacts
|Text annotation
|Explanatory note associated with an input data node, decision node, business knowledge model, or knowledge source.
a|
image::kogito/dmn/dmn-annotation-node.png[]

|Association
|Connection from an input data node, decision node, business knowledge model, or knowledge source to a text annotation.
a|
image::kogito/dmn/dmn-association-connector.png[]
|===

The following table summarizes the permitted connectors between DRD elements:

.DRD connector rules
[cols="20%,20%,20%,40%" options="header"]
|===
|Starts from
|Connects to
|Connection type
|Example

|Decision
|Decision
|Information requirement
a|
image::kogito/dmn/dmn-decision-to-decision.png[]

.2+|Business knowledge model
|Decision
.2+|Knowledge requirement
a|
image::kogito/dmn/dmn-bkm-to-decision.png[]

|Business knowledge model
a|
image::kogito/dmn/dmn-bkm-to-bkm.png[]

.2+a|Decision service

|Decision
.2+|Knowledge requirement
a|
image::kogito/dmn/dmn-decision-service-to-decision.png[]

|Business knowledge model
a|
image::kogito/dmn/dmn-decision-service-to-bkm.png[]

.2+|Input data
|Decision
|Information requirement
a|
image::kogito/dmn/dmn-input-to-decision.png[]

|Knowledge source
|Authority requirement
a|
image::kogito/dmn/dmn-input-to-knowledge-source.png[]

.3+|Knowledge source
|Decision
.3+|Authority requirement
a|
image::kogito/dmn/dmn-knowledge-source-to-decision.png[]

|Business knowledge model
a|
image::kogito/dmn/dmn-knowledge-source-to-bkm.png[]

|Knowledge source
a|
image::kogito/dmn/dmn-knowledge-source-to-knowledge-source.png[]

|Decision
.4+|Text annotation
.4+|Association
a|
image::kogito/dmn/dmn-decision-to-annotation.png[]

|Business knowledge model
a|
image::kogito/dmn/dmn-bkm-to-annotation.png[]

|Knowledge source
a|
image::kogito/dmn/dmn-knowledge-source-to-annotation.png[]

|Input data
a|
image::kogito/dmn/dmn-input-to-annotation.png[]
|===

The following example DRD illustrates some of these DMN components in practice:

.Example DRD: Loan prequalification
image::kogito/dmn/dmn-example-drd.png[]

The following example DRD illustrates DMN components that are part of a reusable decision service:

.Example DRD: Phone call handling as a decision service
image::kogito/dmn/dmn-example-drd3.png[width=90%]

In a DMN decision service node, the decision nodes in the bottom segment incorporate input data from outside of the decision service to arrive at a final decision in the top segment of the decision service node. The resulting top-level decisions from the decision service are then implemented in any subsequent decisions or business knowledge requirements of the DMN model. You can reuse DMN decision services in other DMN models to apply the same decision logic with different input data and different outgoing connections.

////
.Advanced DRD example: Lending strategy
image::kogito/dmn/dmn-example-drd2.png[]
////

[id="con-dmn-feel_{context}"]
=== Rule expressions in FEEL

[role="_abstract"]
Friendly Enough Expression Language (FEEL) is an expression language defined by the Object Management Group (OMG) DMN specification. FEEL expressions define the logic of a decision in a DMN model. FEEL is designed to facilitate both decision modeling and execution by assigning semantics to the decision model constructs. FEEL expressions in decision requirements diagrams (DRDs) occupy table cells in boxed expressions for decision nodes and business knowledge models.

For more information about FEEL in DMN, see the OMG https://www.omg.org/spec/DMN[Decision Model and Notation specification].

[id="ref-dmn-feel-data-types_{context}"]
==== Data types in FEEL

[role="_abstract"]
Friendly Enough Expression Language (FEEL) supports the following data types:

* Numbers
* Strings
* Boolean values
* Dates
* Time
* Date and time
* Days and time duration
* Years and months duration
* Functions
* Contexts
* Ranges (or intervals)
* Lists

NOTE: The DMN specification currently does not provide an explicit way of declaring a variable as a `function`, `context`, `range`, or `list`, but {PRODUCT} extends the DMN built-in types to support variables of these types.

The following list describes each data type:

Numbers::
Numbers in FEEL are based on the http://ieeexplore.ieee.org/document/4610935/[IEEE 754-2008] Decimal 128 format, with 34 digits of precision. Internally, numbers are represented in Java as https://docs.oracle.com/javase/8/docs/api/java/math/BigDecimal.html[`BigDecimals`] with `MathContext DECIMAL128`. FEEL supports only one number data type, so the same type is used to represent both integers and floating
point numbers.
+
--
FEEL numbers use a dot (`.`) as a decimal separator. FEEL does not support `-INF`, `+INF`, or `NaN`. FEEL uses
`null` to represent invalid numbers.

{PRODUCT} extends the DMN specification and supports additional number notations:

* *Scientific:* You can use scientific notation with the suffix `e<exp>` or `E<exp>`. For example, `1.2e3` is the same as writing the expression `1.2*10**3`, but is a literal instead of an expression.
* *Hexadecimal:* You can use hexadecimal numbers with the prefix `0x`. For example, `0xff` is the same as the decimal number `255`. Both uppercase and lowercase letters are supported. For example, `0XFF` is the same as `0xff`.
* *Type suffixes:* You can use the type suffixes `f`, `F`, `d`, `D`, `l`, and `L`. These suffixes are ignored.
--

Strings::
Strings in FEEL are any sequence of characters delimited by double quotation marks.
+
--
.Example
----
"John Doe"
----
--

Boolean values::
FEEL uses three-valued boolean logic, so a boolean logic expression may have values `true`, `false`, or `null`.


Dates::
Date literals are not supported in FEEL, but you can use the built-in `date()` function to construct date values. Date strings in FEEL follow the format defined in the https://www.w3.org/TR/xmlschema-2/#date[XML Schema Part 2: Datatypes] document. The format is `"YYYY-MM-DD"` where `YYYY` is the year with four digits, `MM` is the number of the month with two digits, and `DD` is the number of the day.
+
--
Example:
----
date( "2017-06-23" )
----

Date objects have time equal to `"00:00:00"`, which is midnight. The dates are considered to be local, without a timezone.
--

Time::
Time literals are not supported in FEEL, but you can use the built-in `time()` function to construct time values. Time strings in FEEL follow the format defined in the https://www.w3.org/TR/xmlschema-2/#time[XML Schema Part 2: Datatypes] document. The format is `"hh:mm:ss[.uuu][(+-)hh:mm]"` where `hh` is the hour of the day (from `00` to `23`), `mm` is the minutes in the hour, and `ss` is the number of seconds in the minute. Optionally, the string may define the number of milliseconds (`uuu`) within the second and contain a positive (`+`) or negative (`-`) offset from UTC time to define its timezone. Instead of using an offset, you can use the letter `z` to represent the UTC time, which is the same as an offset of `-00:00`. If no offset is defined, the time is considered to be local.
+
--
Examples:
----
time( "04:25:12" )
time( "14:10:00+02:00" )
time( "22:35:40.345-05:00" )
time( "15:00:30z" )
----

Time values that define an offset or a timezone cannot be compared to local times that do not define an offset or a timezone.
--

Date and time::
Date and time literals are not supported in FEEL, but you can use the built-in `date and time()` function to construct date and time values. Date and time strings in FEEL follow the format defined in the https://www.w3.org/TR/xmlschema-2/#dateTime[XML Schema Part 2: Datatypes] document. The format is `"<date>T<time>"`, where `<date>` and `<time>` follow the prescribed XML schema formatting, conjoined by `T`.
+
--
Examples:
----
date and time( "2017-10-22T23:59:00" )
date and time( "2017-06-13T14:10:00+02:00" )
date and time( "2017-02-05T22:35:40.345-05:00" )
date and time( "2017-06-13T15:00:30z" )
----

Date and time values that define an offset or a timezone cannot be compared to local date and time values
that do not define an offset or a timezone.

IMPORTANT: If your implementation of the DMN specification does not support spaces in the XML schema, use the keyword `dateTime` as a synonym of `date and time`.

--

Days and time duration::
Days and time duration literals are not supported in FEEL, but you can use the built-in `duration()` function to construct days and time duration values. Days and time duration strings in FEEL follow the format defined in the https://www.w3.org/TR/xmlschema-2/#duration[XML Schema Part 2: Datatypes] document, but are restricted to only days, hours, minutes and seconds. Months and years are not supported.
+
--
Examples:
----
duration( "P1DT23H12M30S" )
duration( "P23D" )
duration( "PT12H" )
duration( "PT35M" )
----

IMPORTANT: If your implementation of the DMN specification does not support spaces in the XML schema, use the keyword `dayTimeDuration` as a synonym of `days and time duration`.

--

Years and months duration::
Years and months duration literals are not supported in FEEL, but you can use the built-in `duration()` function to construct days and time duration values. Years and months duration strings in FEEL follow the format defined in the https://www.w3.org/TR/xmlschema-2/#duration[XML Schema Part 2: Datatypes] document, but are restricted to only years and months. Days, hours, minutes, or seconds are not supported.
+
--
Examples:
----
duration( "P3Y5M" )
duration( "P2Y" )
duration( "P10M" )
duration( "P25M" )
----

IMPORTANT: If your implementation of the DMN specification does not support spaces in the XML schema, use the keyword `yearMonthDuration` as a synonym of `years and months duration`.

--

Functions::
FEEL has `function` literals (or anonymous functions) that you can use to create functions. The DMN specification currently does not provide an explicit way of declaring a variable as a `function`, but {PRODUCT} extends the DMN built-in types to support variables of functions.
+
--
Example:
----
function(a, b) a + b
----
In this example, the FEEL expression creates a function that adds the parameters `a` and `b` and returns the result.
--

Contexts::
FEEL has `context` literals that you can use to create contexts. A `context` in FEEL is a list of key and value pairs, similar to maps in languages like Java. The DMN specification currently does not provide an explicit way of declaring a variable as a `context`, but {PRODUCT} extends the DMN built-in types to support variables of contexts.
+
--
Example:
----
{ x : 5, y : 3 }
----
In this example, the expression creates a context with two entries, `x` and `y`, representing a coordinate in a chart.

In DMN 1.2, another way to create contexts is to create an item definition that contains the list of keys as attributes, and then declare the variable as having that item definition type.

The {PRODUCT} DMN API supports DMN `ItemDefinition` structural types in a `DMNContext` represented in two ways:

* User-defined Java type: Must be a valid JavaBeans object defining properties and getters for each of the components in the DMN `ItemDefinition`. If necessary, you can also use the `@FEELProperty` annotation for those getters representing a component name which would result in an invalid Java identifier.
* `java.util.Map` interface: The map needs to define the appropriate entries, with the keys corresponding to the component name in the DMN `ItemDefinition`.
--

Ranges (or intervals)::
FEEL has `range` literals that you can use to create ranges or intervals. A `range` in FEEL is a value that defines a lower and an upper bound, where either can be open or closed. The DMN specification currently does not provide an explicit way of declaring a variable as a `range`, but {PRODUCT} extends the DMN built-in types to support variables of ranges.
+
--
The syntax of a range is defined in the following formats:
----
range          := interval_start endpoint '..' endpoint interval_end
interval_start := open_start | closed_start
open_start     := '(' | ']'
closed_start   := '['
interval_end   := open_end | closed_end
open_end       := ')' | '['
closed_end     := ']'
endpoint       := expression
----

The expression for the endpoint must return a comparable value, and the lower bound endpoint must be lower than the upper bound endpoint.

For example, the following literal expression defines an interval between `1` and `10`, including the boundaries (a closed interval on both endpoints):

----
[ 1 .. 10 ]
----

The following literal expression defines an interval between 1 hour and 12 hours, including the lower boundary (a closed interval), but excluding the upper boundary (an open interval):

----
[ duration("PT1H") .. duration("PT12H") )
----

You can use ranges in decision tables to test for ranges of values, or use ranges in simple literal expressions. For example, the following literal expression returns `true` if the value of a variable `x` is between `0` and `100`:

----
x in [ 1 .. 100 ]
----
--

Lists::
FEEL has `list` literals that you can use to create lists of items. A `list` in FEEL is represented by a comma-separated list of values enclosed in square brackets. The DMN specification currently does not provide an explicit way of declaring a variable as a `list`, but {PRODUCT} extends the DMN built-in types to support variables of lists.
+
--
Example:
----
[ 2, 3, 4, 5 ]
----

All lists in FEEL contain elements of the same type and are immutable. Elements in a list can be accessed by index, where the first element is `1`. Negative indexes can access elements starting from the end of the list so that `-1` is the last element.

For example, the following expression returns the second element of a list `x`:

----
x[2]
----

The following expression returns the second-to-last element of a list `x`:

----
x[-2]
----

Elements in a list can also be counted by the function `count`, which uses the list of elements as the parameter.

For example, the following expression returns `4`:

----
count([ 2, 3, 4, 5 ])
----
--

//@comment: Keep this file as a standalone module because it is synced with the file at https://github.com/kiegroup/drools/blob/main/kie-dmn/ref-dmn-feel-builtin-functions.adoc
include::ref-dmn-feel-builtin-functions.adoc[leveloffset=+3]

[id="ref-dmn-feel-variable-function-names_{context}"]
=== Variable and function names in FEEL

[role="_abstract"]
Unlike many traditional expression languages, Friendly Enough Expression Language (FEEL) supports spaces and a few special characters as part of variable and function names. A FEEL name must start with a `letter`, `?`, or `_` element. The unicode letter characters are also allowed. Variable names cannot start with a language keyword, such as `and`, `true`, or `every`. The remaining characters in a variable name can be any of the starting characters, as well as `digits`, white spaces, and special characters such as `+`, `-`, `/`, `*`, `'`, and `.`.

For example, the following names are all valid FEEL names:

* Age
* Birth Date
* Flight 234 pre-check procedure

Several limitations apply to variable and function names in FEEL:

Ambiguity::
The use of spaces, keywords, and other special characters as part of names can make FEEL ambiguous. The ambiguities are resolved in the context of the expression, matching names from left to right. The parser resolves the variable name as the longest name matched in scope. You can use `( )` to disambiguate names if necessary.

Spaces in names::
The DMN specification limits the use of spaces in FEEL names. According to the DMN specification, names can contain multiple spaces but not two consecutive spaces.
+
--
In order to make the language easier to use and avoid common errors due to spaces, {PRODUCT} removes the limitation on the use of consecutive spaces. {PRODUCT} supports variable names with any number of consecutive spaces, but normalizes them into a single space. For example, the variable references `First Name` with one space and `First  Name` with two spaces are both acceptable in {PRODUCT}.

{PRODUCT} also normalizes the use of other white spaces, like the non-breakable white space that is common in web pages, tabs, and line breaks. From a {PRODUCT} FEEL engine perspective, all of these characters are normalized into a single white space before processing.
--

The keyword `in`::
The keyword `in` is the only keyword in the language that cannot be used as part of a variable name. Although the specifications allow the use of keywords in the middle of variable names, the use of `in` in variable names conflicts with the grammar definition of `for`, `every` and `some` expression constructs.

[id="con-dmn-boxed-expressions_{context}"]
=== DMN decision logic in boxed expressions

[role="_abstract"]
Boxed expressions in DMN are tables that you use to define the underlying logic of decision nodes and business knowledge models in a decision requirements diagram (DRD). Some boxed expressions can contain other boxed expressions, but the top-level boxed expression corresponds to the decision logic of a single DRD artifact. While DRDs represent the flow of a DMN decision model, boxed expressions define the actual decision logic of individual nodes. DRDs and boxed expressions together form a complete and functional DMN decision model.

The following are the types of DMN boxed expressions:

* Decision tables
* Literal expressions
* Contexts
* Relations
* Functions
* Invocations
* Lists

All Friendly Enough Expression Language (FEEL) expressions that you use in your boxed expressions must conform to the FEEL syntax requirements in the OMG https://www.omg.org/spec/DMN[Decision Model and Notation specification].


[id="con-dmn-decision-tables_{context}"]
==== DMN decision tables

[role="_abstract"]
A decision table in DMN is a visual representation of one or more business rules in a tabular format. You use decision tables to define rules for a decision node that applies those rules at a given point in the decision model. Each rule consists of a single row in the table, and includes columns that define the conditions (input) and outcome (output) for that particular row. The definition of each row is precise enough to derive the outcome using the values of the conditions. Input and output values can be FEEL expressions or defined data type values.

For example, the following decision table determines credit score ratings based on a defined range of a loan applicant's credit score:

.Decision table for credit score rating
image::kogito/dmn/dmn-decision-table-example.png[]

The following decision table determines the next step in a lending strategy for applicants depending on applicant loan eligibility and the bureau call type:

.Decision table for lending strategy
image::kogito/dmn/dmn-decision-table-example2.png[]

The following decision table determines applicant qualification for a loan as the concluding decision node in a loan prequalification decision model:

.Decision table for loan prequalification
image::kogito/dmn/dmn-decision-table-example3.png[]

Decision tables are a popular way of modeling rules and decision logic, and are used in many methodologies (such as DMN) and implementation frameworks (such as Drools).

IMPORTANT: {PRODUCT} supports both DMN decision tables and Drools-native decision tables, but they are different types of assets with different syntax requirements and are not interchangeable. For more information about Drools-native decision tables in {PRODUCT}, see xref:con-decision-tables_kogito-decision-tables[].

[id="con-dmn-decision-tables-hit-policies_{context}"]
===== Hit policies in DMN decision tables

[role="_abstract"]
Hit policies determine how to reach an outcome when multiple rules in a decision table match the provided input values. For example, if one rule in a decision table applies a sales discount to military personnel and another rule applies a discount to students, then when a customer is both a student and in the military, the decision table hit policy must indicate whether to apply one discount or the other (*Unique*, *First*) or both discounts (*Collect Sum*). You specify the single character of the hit policy (*U*, *F*, *C+*) in the upper-left corner of the decision table.

The following decision table hit policies are supported in DMN:

* *Unique (U):* Permits only one rule to match. Any overlap raises an error.
* *Any (A):* Permits multiple rules to match, but they must all have the same output. If multiple matching rules do not have the same output, an error is raised.
* *Priority (P):* Permits multiple rules to match, with different outputs. The output that comes first in the output values list is selected.
* *First (F):* Uses the first match in rule order.
* *Collect (C+, C>, C<, C#):* Aggregates output from multiple rules based on an aggregation function.
** *Collect ( C ):* Aggregates values in an arbitrary list.
** *Collect Sum (C+):* Outputs the sum of all collected values. Values must be numeric.
** *Collect Min (C<):* Outputs the minimum value among the matches. The resulting values must be comparable, such as numbers, dates, or text (lexicographic order).
** *Collect Max (C>):* Outputs the maximum value among the matches. The resulting values must be comparable, such as numbers, dates or text (lexicographic order).
** *Collect Count (C#):* Outputs the number of matching rules.
** *Rule Order (R):* Collects output from multiple rules into a list ordered according to rules order. It is very similar to 'Collect' without any aggregation function, but with explicit consistent ordering in the final list as defined in the table.
** *Output Order (O):* Collects output from multiple rules into a list ordered using the same sorting mechanism as the 'Priority' hit policy.

[id="con-dmn-literal-expressions_{context}"]
==== Boxed literal expressions

[role="_abstract"]
A boxed literal expression in DMN is a literal FEEL expression as text in a table cell, typically with a labeled column and an assigned data type. You use boxed literal expressions to define simple or complex node logic or decision data directly in FEEL for a particular node in a decision. Literal FEEL expressions must conform to FEEL syntax requirements in the OMG https://www.omg.org/spec/DMN[Decision Model and Notation specification].

For example, the following boxed literal expression defines the minimum acceptable PITI calculation (principal, interest, taxes, and insurance) in a lending decision, where `acceptable rate` is a variable defined in the DMN model:

.Boxed literal expression for minimum PITI value
image::kogito/dmn/dmn-literal-expression-example2.png[]

The following boxed literal expression sorts a list of possible dating candidates (soul mates) in an online dating application based on their score on criteria such as age, location, and interests:

.Boxed literal expression for matching online dating candidates
image::kogito/dmn/dmn-literal-expression-example3b.png[]

[id="con-dmn-context-expressions_{context}"]
==== Boxed context expressions

[role="_abstract"]
A boxed context expression in DMN is a set of variable names and values with a result value. Each name-value pair is a context entry. You use context expressions to represent data definitions in decision logic and set a value for a desired decision element within the DMN decision model. A value in a boxed context expression can be a data type value or FEEL expression, or can contain a nested sub-expression of any type, such as a decision table, a literal expression, or another context expression.

For example, the following boxed context expression defines the factors for sorting delayed passengers in a flight-rebooking decision model, based on defined data types (`tPassengerTable`, `tFlightNumberList`):

.Boxed context expression for flight passenger waiting list
image::kogito/dmn/dmn-context-expression-example.png[]

The following boxed context expression defines the factors that determine whether a loan applicant can meet minimum mortgage payments based on principal, interest, taxes, and insurance (PITI), represented as a front-end ratio calculation with a sub-context expression:

.Boxed context expression for front-end client PITI ratio
image::kogito/dmn/dmn-context-expression-example2.png[]

[id="con-dmn-relation-expressions_{context}"]
==== Boxed relation expressions

[role="_abstract"]
A boxed relation expression in DMN is a traditional data table with information about given entities, listed as rows. You use boxed relation tables to define decision data for relevant entities in a decision at a particular node. Boxed relation expressions are similar to context expressions in that they set variable names and values, but relation expressions contain no result value and list all variable values based on a single defined variable in each column.

For example, the following boxed relation expression provides information about employees in an employee rostering decision:

.Boxed relation expression with employee information
image::kogito/dmn/dmn-relation-expression-example.png[]

[id="con-dmn-function-expressions_{context}"]
==== Boxed function expressions

[role="_abstract"]
A boxed function expression in DMN is a parameterized boxed expression containing a literal FEEL expression, a nested context expression of an external JAVA or PMML function, or a nested boxed expression of any type. By default, all business knowledge models are defined as boxed function expressions. You use boxed function expressions to call functions on your decision logic and to define all business knowledge models.

For example, the following boxed function expression determines airline flight capacity in a flight-rebooking decision model:

.Boxed function expression for flight capacity
image::kogito/dmn/dmn-function-expression-example.png[]

The following boxed function expression contains a basic Java function as a context expression for determining absolute value in a decision model calculation:

.Boxed function expression for absolute value
image::kogito/dmn/dmn-function-expression-example2.png[]

The following boxed function expression determines a monthly mortgage installment as a business knowledge model in a lending decision, with the function value defined as a nested context expression:

.Boxed function expression for installment calculation in business knowledge model
image::kogito/dmn/dmn-function-expression-example3.png[]

The following boxed function expression uses a PMML model included in the DMN file to define the minimum acceptable PITI calculation (principal, interest, taxes, and insurance) in a lending decision:
////
//@comment: Excluding until included models is supported in Kogito (Stetson, 5 Mar 2020)
.Boxed function expression with an included PMML model in business knowledge model
image::kogito/dmn/dmn-function-expression-example5.png[]
////

[id="con-dmn-invocation-expressions_{context}"]
==== Boxed invocation expressions

[role="_abstract"]
A boxed invocation expression in DMN is a boxed expression that invokes a business knowledge model. A boxed invocation expression contains the name of the business knowledge model to be invoked and a list of parameter bindings. Each binding is represented by two boxed expressions on a row: The box on the left contains the name of a parameter and the box on the right contains the binding expression whose value is assigned to the parameter to evaluate the invoked business knowledge model. You use boxed invocations to invoke at a particular decision node a business knowledge model defined in the decision model.

For example, the following boxed invocation expression invokes a `Reassign Next Passenger` business knowledge model as the concluding decision node in a flight-rebooking decision model:

.Boxed invocation expression to reassign flight passengers
image::kogito/dmn/dmn-invocation-example.png[]

The following boxed invocation expression invokes an `InstallmentCalculation` business knowledge model to calculate a monthly installment amount for a loan before proceeding to affordability decisions:

.Boxed invocation expression for required monthly installment
image::kogito/dmn/dmn-invocation-example2.png[]

[id="con-dmn-list-expressions_{context}"]
==== Boxed list expressions

[role="_abstract"]
A boxed list expression in DMN represents a FEEL list of items. You use boxed lists to define lists of relevant items for a particular node in a decision. You can also use literal FEEL expressions for list items in cells to create more complex lists.

For example, the following boxed list expression identifies approved credit score agencies in a loan application decision service:

.Boxed list expression for approved credit score agencies
image::kogito/dmn/dmn-list-expression-example.png[]

The following boxed list expression also identifies approved credit score agencies but uses FEEL logic to define the agency status (Inc., LLC, SA, GA) based on a DMN input node:

.Boxed list expression using FEEL logic for approved credit score agency status
image::kogito/dmn/dmn-list-expression-example2.png[]

image::kogito/dmn/dmn-list-expression-example2a.png[]

[id="ref-dmn-model-example_{context}"]
=== DMN model example

[role="_abstract"]
The following is a real-world DMN model example that demonstrates how you can use decision modeling to reach a decision based on input data, circumstances, and company guidelines. In this scenario, a flight from San Diego to New York is canceled, requiring the affected airline to find alternate arrangements for its inconvenienced passengers.

First, the airline collects the information necessary to determine how best to get the travelers to their destinations:

Input data::
* List of flights
* List of passengers

Decisions::
* Prioritize the passengers who will get seats on a new flight
* Determine which flights those passengers will be offered

Business knowledge models::
* The company process for determining passenger priority
* Any flights that have space available
* Company rules for determining how best to reassign inconvenienced passengers

The airline then uses the DMN standard to model its decision process in the following decision requirements diagram (DRD) for determining the best rebooking solution:

.DRD for flight rebooking
image::kogito/dmn/dmn-passenger-rebooking-drd.png[]

Similar to flowcharts, DRDs use shapes to represent the different elements in a process. Ovals contain the two necessary input data, rectangles contain the decision points in the model, and rectangles with clipped corners (business knowledge models) contain reusable logic that can be repeatedly invoked.

The DRD draws logic for each element from boxed expressions that provide variable definitions using FEEL expressions or data type values.

Some boxed expressions are basic, such as the following decision for establishing a prioritized waiting list:

.Boxed context expression example for prioritized wait list
image::kogito/dmn/dmn-context-expression-example.png[]

Some boxed expressions are more complex with greater detail and calculation, such as the following business knowledge model for reassigning the next delayed passenger:

.Boxed function expression for passenger reassignment
image::kogito/dmn/dmn-reassign-passenger.png[]

The following is the DMN source file for this decision model:

[source,xml]
----
<dmn:definitions xmlns="https://www.drools.org/kie-dmn/Flight-rebooking" xmlns:dmn="http://www.omg.org/spec/DMN/20151101/dmn.xsd" xmlns:feel="http://www.omg.org/spec/FEEL/20140401" id="_0019_flight_rebooking" name="0019-flight-rebooking" namespace="https://www.drools.org/kie-dmn/Flight-rebooking">
  <dmn:itemDefinition id="_tFlight" name="tFlight">
    <dmn:itemComponent id="_tFlight_Flight" name="Flight Number">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tFlight_From" name="From">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tFlight_To" name="To">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tFlight_Dep" name="Departure">
      <dmn:typeRef>feel:dateTime</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tFlight_Arr" name="Arrival">
      <dmn:typeRef>feel:dateTime</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tFlight_Capacity" name="Capacity">
      <dmn:typeRef>feel:number</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tFlight_Status" name="Status">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
  </dmn:itemDefinition>
  <dmn:itemDefinition id="_tFlightTable" isCollection="true" name="tFlightTable">
    <dmn:typeRef>tFlight</dmn:typeRef>
  </dmn:itemDefinition>
  <dmn:itemDefinition id="_tPassenger" name="tPassenger">
    <dmn:itemComponent id="_tPassenger_Name" name="Name">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tPassenger_Status" name="Status">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tPassenger_Miles" name="Miles">
      <dmn:typeRef>feel:number</dmn:typeRef>
    </dmn:itemComponent>
    <dmn:itemComponent id="_tPassenger_Flight" name="Flight Number">
      <dmn:typeRef>feel:string</dmn:typeRef>
    </dmn:itemComponent>
  </dmn:itemDefinition>
  <dmn:itemDefinition id="_tPassengerTable" isCollection="true" name="tPassengerTable">
    <dmn:typeRef>tPassenger</dmn:typeRef>
  </dmn:itemDefinition>
  <dmn:itemDefinition id="_tFlightNumberList" isCollection="true" name="tFlightNumberList">
    <dmn:typeRef>feel:string</dmn:typeRef>
  </dmn:itemDefinition>
  <dmn:inputData id="i_Flight_List" name="Flight List">
    <dmn:variable name="Flight List" typeRef="tFlightTable"/>
  </dmn:inputData>
  <dmn:inputData id="i_Passenger_List" name="Passenger List">
    <dmn:variable name="Passenger List" typeRef="tPassengerTable"/>
  </dmn:inputData>
  <dmn:decision name="Prioritized Waiting List" id="d_PrioritizedWaitingList">
    <dmn:variable name="Prioritized Waiting List" typeRef="tPassengerTable"/>
    <dmn:informationRequirement>
      <dmn:requiredInput href="#i_Passenger_List"/>
    </dmn:informationRequirement>
    <dmn:informationRequirement>
      <dmn:requiredInput href="#i_Flight_List"/>
    </dmn:informationRequirement>
    <dmn:knowledgeRequirement>
      <dmn:requiredKnowledge href="#b_PassengerPriority"/>
    </dmn:knowledgeRequirement>
    <dmn:context>
      <dmn:contextEntry>
        <dmn:variable name="Cancelled Flights" typeRef="tFlightNumberList"/>
        <dmn:literalExpression>
          <dmn:text>Flight List[ Status = "cancelled" ].Flight Number</dmn:text>
        </dmn:literalExpression>
      </dmn:contextEntry>
      <dmn:contextEntry>
        <dmn:variable name="Waiting List" typeRef="tPassengerTable"/>
        <dmn:literalExpression>
          <dmn:text>Passenger List[ list contains( Cancelled Flights, Flight Number ) ]</dmn:text>
        </dmn:literalExpression>
      </dmn:contextEntry>
      <dmn:contextEntry>
        <dmn:literalExpression>
          <dmn:text>sort( Waiting List, passenger priority )</dmn:text>
        </dmn:literalExpression>
      </dmn:contextEntry>
    </dmn:context>
  </dmn:decision>
  <dmn:decision name="Rebooked Passengers" id="d_RebookedPassengers">
    <dmn:variable name="Rebooked Passengers" typeRef="tPassengerTable"/>
    <dmn:informationRequirement>
      <dmn:requiredDecision href="#d_PrioritizedWaitingList"/>
    </dmn:informationRequirement>
    <dmn:informationRequirement>
      <dmn:requiredInput href="#i_Flight_List"/>
    </dmn:informationRequirement>
    <dmn:knowledgeRequirement>
      <dmn:requiredKnowledge href="#b_ReassignNextPassenger"/>
    </dmn:knowledgeRequirement>
    <dmn:invocation>
      <dmn:literalExpression>
        <dmn:text>reassign next passenger</dmn:text>
      </dmn:literalExpression>
      <dmn:binding>
        <dmn:parameter name="Waiting List"/>
        <dmn:literalExpression>
          <dmn:text>Prioritized Waiting List</dmn:text>
        </dmn:literalExpression>
      </dmn:binding>
      <dmn:binding>
        <dmn:parameter name="Reassigned Passengers List"/>
        <dmn:literalExpression>
          <dmn:text>[]</dmn:text>
        </dmn:literalExpression>
      </dmn:binding>
      <dmn:binding>
        <dmn:parameter name="Flights"/>
        <dmn:literalExpression>
          <dmn:text>Flight List</dmn:text>
        </dmn:literalExpression>
      </dmn:binding>
    </dmn:invocation>
  </dmn:decision>
  <dmn:businessKnowledgeModel id="b_PassengerPriority" name="passenger priority">
    <dmn:encapsulatedLogic>
      <dmn:formalParameter name="Passenger1" typeRef="tPassenger"/>
      <dmn:formalParameter name="Passenger2" typeRef="tPassenger"/>
      <dmn:decisionTable hitPolicy="UNIQUE">
        <dmn:input id="b_Passenger_Priority_dt_i_P1_Status" label="Passenger1.Status">
          <dmn:inputExpression typeRef="feel:string">
            <dmn:text>Passenger1.Status</dmn:text>
          </dmn:inputExpression>
          <dmn:inputValues>
            <dmn:text>"gold", "silver", "bronze"</dmn:text>
          </dmn:inputValues>
        </dmn:input>
        <dmn:input id="b_Passenger_Priority_dt_i_P2_Status" label="Passenger2.Status">
          <dmn:inputExpression typeRef="feel:string">
            <dmn:text>Passenger2.Status</dmn:text>
          </dmn:inputExpression>
          <dmn:inputValues>
            <dmn:text>"gold", "silver", "bronze"</dmn:text>
          </dmn:inputValues>
        </dmn:input>
        <dmn:input id="b_Passenger_Priority_dt_i_P1_Miles" label="Passenger1.Miles">
          <dmn:inputExpression typeRef="feel:string">
            <dmn:text>Passenger1.Miles</dmn:text>
          </dmn:inputExpression>
        </dmn:input>
        <dmn:output id="b_Status_Priority_dt_o" label="Passenger1 has priority">
          <dmn:outputValues>
            <dmn:text>true, false</dmn:text>
          </dmn:outputValues>
          <dmn:defaultOutputEntry>
            <dmn:text>false</dmn:text>
          </dmn:defaultOutputEntry>
        </dmn:output>
        <dmn:rule id="b_Passenger_Priority_dt_r1">
          <dmn:inputEntry id="b_Passenger_Priority_dt_r1_i1">
            <dmn:text>"gold"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r1_i2">
            <dmn:text>"gold"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r1_i3">
            <dmn:text>>= Passenger2.Miles</dmn:text>
          </dmn:inputEntry>
          <dmn:outputEntry id="b_Passenger_Priority_dt_r1_o1">
            <dmn:text>true</dmn:text>
          </dmn:outputEntry>
        </dmn:rule>
        <dmn:rule id="b_Passenger_Priority_dt_r2">
          <dmn:inputEntry id="b_Passenger_Priority_dt_r2_i1">
            <dmn:text>"gold"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r2_i2">
            <dmn:text>"silver","bronze"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r2_i3">
            <dmn:text>-</dmn:text>
          </dmn:inputEntry>
          <dmn:outputEntry id="b_Passenger_Priority_dt_r2_o1">
            <dmn:text>true</dmn:text>
          </dmn:outputEntry>
        </dmn:rule>
        <dmn:rule id="b_Passenger_Priority_dt_r3">
          <dmn:inputEntry id="b_Passenger_Priority_dt_r3_i1">
            <dmn:text>"silver"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r3_i2">
            <dmn:text>"silver"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r3_i3">
            <dmn:text>>= Passenger2.Miles</dmn:text>
          </dmn:inputEntry>
          <dmn:outputEntry id="b_Passenger_Priority_dt_r3_o1">
            <dmn:text>true</dmn:text>
          </dmn:outputEntry>
        </dmn:rule>
        <dmn:rule id="b_Passenger_Priority_dt_r4">
          <dmn:inputEntry id="b_Passenger_Priority_dt_r4_i1">
            <dmn:text>"silver"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r4_i2">
            <dmn:text>"bronze"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r4_i3">
            <dmn:text>-</dmn:text>
          </dmn:inputEntry>
          <dmn:outputEntry id="b_Passenger_Priority_dt_r4_o1">
            <dmn:text>true</dmn:text>
          </dmn:outputEntry>
        </dmn:rule>
        <dmn:rule id="b_Passenger_Priority_dt_r5">
          <dmn:inputEntry id="b_Passenger_Priority_dt_r5_i1">
            <dmn:text>"bronze"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r5_i2">
            <dmn:text>"bronze"</dmn:text>
          </dmn:inputEntry>
          <dmn:inputEntry id="b_Passenger_Priority_dt_r5_i3">
            <dmn:text>>= Passenger2.Miles</dmn:text>
          </dmn:inputEntry>
          <dmn:outputEntry id="b_Passenger_Priority_dt_r5_o1">
            <dmn:text>true</dmn:text>
          </dmn:outputEntry>
        </dmn:rule>
      </dmn:decisionTable>
    </dmn:encapsulatedLogic>
    <dmn:variable name="passenger priority" typeRef="feel:boolean"/>
  </dmn:businessKnowledgeModel>
  <dmn:businessKnowledgeModel id="b_ReassignNextPassenger" name="reassign next passenger">
    <dmn:encapsulatedLogic>
      <dmn:formalParameter name="Waiting List" typeRef="tPassengerTable"/>
      <dmn:formalParameter name="Reassigned Passengers List" typeRef="tPassengerTable"/>
      <dmn:formalParameter name="Flights" typeRef="tFlightTable"/>
      <dmn:context>
        <dmn:contextEntry>
          <dmn:variable name="Next Passenger" typeRef="tPassenger"/>
          <dmn:literalExpression>
            <dmn:text>Waiting List[1]</dmn:text>
          </dmn:literalExpression>
        </dmn:contextEntry>
        <dmn:contextEntry>
          <dmn:variable name="Original Flight" typeRef="tFlight"/>
          <dmn:literalExpression>
            <dmn:text>Flights[ Flight Number = Next Passenger.Flight Number ][1]</dmn:text>
          </dmn:literalExpression>
        </dmn:contextEntry>
        <dmn:contextEntry>
          <dmn:variable name="Best Alternate Flight" typeRef="tFlight"/>
          <dmn:literalExpression>
            <dmn:text>Flights[ From = Original Flight.From and To = Original Flight.To and Departure > Original Flight.Departure and Status = "scheduled" and has capacity( item, Reassigned Passengers List ) ][1]</dmn:text>
          </dmn:literalExpression>
        </dmn:contextEntry>
        <dmn:contextEntry>
          <dmn:variable name="Reassigned Passenger" typeRef="tPassenger"/>
          <dmn:context>
            <dmn:contextEntry>
              <dmn:variable name="Name" typeRef="feel:string"/>
              <dmn:literalExpression>
                <dmn:text>Next Passenger.Name</dmn:text>
              </dmn:literalExpression>
            </dmn:contextEntry>
            <dmn:contextEntry>
              <dmn:variable name="Status" typeRef="feel:string"/>
              <dmn:literalExpression>
                <dmn:text>Next Passenger.Status</dmn:text>
              </dmn:literalExpression>
            </dmn:contextEntry>
            <dmn:contextEntry>
              <dmn:variable name="Miles" typeRef="feel:number"/>
              <dmn:literalExpression>
                <dmn:text>Next Passenger.Miles</dmn:text>
              </dmn:literalExpression>
            </dmn:contextEntry>
            <dmn:contextEntry>
              <dmn:variable name="Flight Number" typeRef="feel:string"/>
              <dmn:literalExpression>
                <dmn:text>Best Alternate Flight.Flight Number</dmn:text>
              </dmn:literalExpression>
            </dmn:contextEntry>
          </dmn:context>
        </dmn:contextEntry>
        <dmn:contextEntry>
          <dmn:variable name="Remaining Waiting List" typeRef="tPassengerTable"/>
          <dmn:literalExpression>
            <dmn:text>remove( Waiting List, 1 )</dmn:text>
          </dmn:literalExpression>
        </dmn:contextEntry>
        <dmn:contextEntry>
          <dmn:variable name="Updated Reassigned Passengers List" typeRef="tPassengerTable"/>
          <dmn:literalExpression>
            <dmn:text>append( Reassigned Passengers List, Reassigned Passenger )</dmn:text>
          </dmn:literalExpression>
        </dmn:contextEntry>
        <dmn:contextEntry>
          <dmn:literalExpression>
            <dmn:text>if count( Remaining Waiting List ) > 0 then reassign next passenger( Remaining Waiting List, Updated Reassigned Passengers List, Flights ) else Updated Reassigned Passengers List</dmn:text>
          </dmn:literalExpression>
        </dmn:contextEntry>
      </dmn:context>
    </dmn:encapsulatedLogic>
    <dmn:variable name="reassign next passenger" typeRef="tPassengerTable"/>
    <dmn:knowledgeRequirement>
      <dmn:requiredKnowledge href="#b_HasCapacity"/>
    </dmn:knowledgeRequirement>
  </dmn:businessKnowledgeModel>
  <dmn:businessKnowledgeModel id="b_HasCapacity" name="has capacity">
    <dmn:encapsulatedLogic>
      <dmn:formalParameter name="flight" typeRef="tFlight"/>
      <dmn:formalParameter name="rebooked list" typeRef="tPassengerTable"/>
      <dmn:literalExpression>
        <dmn:text>flight.Capacity > count( rebooked list[ Flight Number = flight.Flight Number ] )</dmn:text>
      </dmn:literalExpression>
    </dmn:encapsulatedLogic>
    <dmn:variable name="has capacity" typeRef="feel:boolean"/>
  </dmn:businessKnowledgeModel>
</dmn:definitions>
----

[id="con-dmn-support_{context}"]
== DMN support in {PRODUCT}

[role="_abstract"]
{PRODUCT} provides runtime support for DMN 1.1, 1.2, 1.3, and 1.4 models at conformance level 3 and design support for DMN 1.2 models at conformance level 3. You can design your DMN models with the {PRODUCT} DMN modeler in VSCode or import existing DMN models into your {PRODUCT} projects for deployment and execution. Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import, open in the DMN designer, and save are converted to DMN 1.2 models.

The following table summarizes the design and runtime support for each DMN version in {PRODUCT}:

.DMN support in {PRODUCT}
[cols="25%,25%,25%,25%"]
|===
.2+h|DMN version
1+h|DMN engine support
2+h|DMN modeler support

h|Execution
h|Open
h|Save

|DMN 1.1
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/bk_x.png[]

|DMN 1.2
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/grn_check.png[]

|DMN 1.3
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/bk_x.png[]

|DMN 1.4
|image:kogito/bpmn/grn_check.png[]
|image:kogito/bpmn/bk_x.png[]
|image:kogito/bpmn/bk_x.png[]
|===

In addition to all DMN conformance level 3 requirements, {PRODUCT} also includes enhancements and fixes to FEEL and DMN model components to optimize the experience of implementing DMN decision services with {PRODUCT}. From a platform perspective, DMN models are like any other business asset in {PRODUCT}, such as DRL files or spreadsheet decision tables, that you can include in your {PRODUCT} project and execute to start your DMN decision services.

////
//@comment: Under investigation for Kogito. (Stetson, 5 March 2020)

[id="ref-dmn-properties_{context}"]
=== Configurable DMN properties in {PRODUCT}

[role="_abstract"]
{PRODUCT} provides the following DMN properties that you can configure when you execute your DMN models on {KIE_SERVER} or on your client application:

org.kie.dmn.strictConformance::
When enabled, this property disables by default any extensions or profiles provided beyond the DMN standard, such as some helper functions or enhanced features of DMN 1.2 backported into DMN 1.1. You can use this property to configure the {DECISION_ENGINE} to support only pure DMN features, such as when running the https://dmn-tck.github.io/tck/[DMN Technology Compatibility Kit] (TCK).
+
--
Default value: `false`

[source]
----
-Dorg.kie.dmn.strictConformance=true
----
--

org.kie.dmn.runtime.typecheck::
When enabled, this property enables verification of actual values conforming to their declared types in the DMN model, as input or output of DRD elements. You can use this property to verify whether data supplied to the DMN model or produced by the DMN model is compliant with what is specified in the model.
+
--
Default value: `false`

[source]
----
-Dorg.kie.dmn.runtime.typecheck=true
----
--

org.kie.dmn.decisionservice.coercesingleton::
By default, this property makes the result of a decision service defining a single output decision be the single value of the output decision value. When disabled, this property makes the result of a decision service defining a single output decision be a `context` with the single entry for that decision. You can use this property to adjust your decision service outputs according to your project requirements.
+
--
Default value: `true`

[source]
----
-Dorg.kie.dmn.decisionservice.coercesingleton=false
----
--

org.kie.dmn.profiles.$PROFILE_NAME::
When valorized with a Java fully qualified name, this property loads a DMN profile onto the {DECISION_ENGINE} at start time. You can use this property to implement a predefined DMN profile with supported features different from or beyond the DMN standard. For example, if you are creating DMN models using the Signavio DMN modeller, use this property to implement features from the Signavio DMN profile into your DMN decision service.
+
--
[source]
----
-Dorg.kie.dmn.profiles.signavio=org.kie.dmn.signavio.KieDMNSignavioProfile
----
--

org.kie.dmn.runtime.listeners.$LISTENER_NAME::
When valorized with a Java fully qualified name, this property loads and registers a DMN Runtime Listener onto the {DECISION_ENGINE} at start time. You can use this property to register a DMN listener in order to be notified of several events during DMN model evaluations.
+
--
[source]
----
-Dorg.kie.dmn.runtime.listeners.mylistener=org.acme.MyDMNListener
----

You can also configure this property in the `kmodule.xml` file in your project.

[source,xml]
----
<kmodule xmlns="http://www.drools.org/xsd/kmodule">
  <configuration>
    <property key="org.kie.dmn.runtime.listeners.mylistener" value="org.acme.MyDMNListener"/>
  </configuration>
</kmodule>
----
--

org.kie.dmn.compiler.execmodel::
When enabled, this property enables DMN decision table logic to be compiled into executable rule models during run time. You can use this property to evaluate DMN decision table logic more efficiently. This property is helpful when the executable model compilation was not originally performed during project compile time. Enabling this property may result in added compile time during the first evaluation by the {DECISION_ENGINE}, but subsequent compilations are more efficient.
+
--
Default value: `false`

[source]
----
-Dorg.kie.dmn.compiler.execmodel=true
----
--
////

[id="con-dmn-validation_{context}"]
=== Configurable DMN validation in {PRODUCT}

[role="_abstract"]
By default, the {PRODUCT} CodeGen component uses the `kogito.decisions.validation=ENABLED` configuration to perform pre-compilation validation of DMN model assets and to perform DMN decision table static analysis.

When this configuration is enabled, {PRODUCT} performs the following DMN validations:

* DMN model files are verified against the DMN specification XSD schema to ensure that the files are valid XML and compliant with the specification.
* The pre-compilation analysis is performed for the DMN model to ensure that the basic semantic is aligned with the DMN specification.
* DMN decision tables are statically analyzed for gaps or overlaps and to ensure that the semantic of the decision table follows best practices.

Any DMN validation error causes the {PRODUCT} CodeGen build to fail and errors are reported accordingly, as shown in the following example:

.DMN validation errors
image::kogito/dmn/kogito-dmn-validation-con-error.png[Image of DMN validation errors]

You can modify the default DMN validation and DMN decision table analysis behavior to ignore errors during the project build, or you can disable this default behavior completely, as shown in the following examples:

.Default configuration for DMN validation and decision table analysis
[source]
----
kogito.decisions.validation=ENABLED
----

.Configuration to validate DMN models and DMN decision tables but ignore errors
[source]
----
kogito.decisions.validation=IGNORE
----

.Configuration to disable all DMN validation
[source]
----
kogito.decisions.validation=DISABLED
----

NOTE: If you enter an unrecognized `kogito.decisions.validation` configuration flag, all pre-compilation validation features are disabled and the {PRODUCT} CodeGen emits related log messages.

ifdef::KOGITO-COMM[]
[id="ref-dmn-feel-enhancements_{context}"]
=== FEEL enhancements in {PRODUCT}

[role="_abstract"]
{PRODUCT} includes the following enhancements and other changes to FEEL in the current DMN implementation:

* _Space Sensitivity_: This DMN implementation of the FEEL language is space insensitive. The goal is to avoid non-deterministic behavior based on the context and differences in behavior based on invisible characters, such as white spaces. This means that for this implementation, a variable named `first name` with one space is exactly the same as `first  name` with two spaces in it.

* __List functions `or()` and `and()` __: The specification defines two list functions named `or()` and `and()`. However,
according to the FEEL grammar, these are not valid function names, as `and` and `or` are reserved keywords.
 This implementation renames these functions to `any()` and `all()` respectively, in anticipation for DMN 1.2.

* __Keyword `in` cannot be used in variable names__: The specification defines that any keyword can be reused as part
 of a variable name, but the ambiguities caused with the `for ... in ... return` loop prevent the reuse of the `in`
 keyword. All other keywords are supported as part of variable names.

* __Keywords are not supported in attributes of anonymous types__: FEEL is not a strongly typed language and the parser must resolve ambiguity in name parts of an attribute of an anonymous type. The parser supports reusable keywords as part of a variable name defined in the scope, but the parser does not support keywords in attributes of an anonymous type. For example, `for item in Order.items return Federal Tax for Item( item )` is a valid and supported FEEL expression, where a function named `Federal Tax for Item(...)` can be defined and invoked correctly in the scope. However, the expression `for i in [ {x and y : true, n : 1}, {x and y : false, n: 2} ] return i.x and y` is not supported because anonymous types are defined in the iteration context of the `for` expression and the parser cannot resolve the ambiguity.

* __Support for date and time literals on ranges__: According to the grammar rules #8, #18, #19, #34 and #62, `date
 and time` literals are supported in ranges (pages 110-111). Chapter 10.3.2.7 on page 114, on the other hand, contradicts
 the grammar and says they are not supported. This implementation chose to follow the grammar and support `date and
 time` literals on ranges, as well as extend the specification to support any arbitrary expression (see extensions below).

* __Invalid time syntax__: Chapter 10.3.2.3.4 on page 112 and bullet point about `time` on page 131 both state that
 the `time` string lexical representation follows the XML Schema Datatypes specification as well as ISO 8601. According
 to the XML Schema specification (https://www.w3.org/TR/xmlschema-2/#time), the lexical representation of a time follows
 the pattern `hh:mm:ss.sss` without any leading character. The DMN specification uses a leading "T" in several examples,
 that we understand is a typo and not in accordance with the standard.

* __Support for scientific and hexadecimal notations__: This implementation supports scientific and hexadecimal
  notation for numbers. For example, `1.2e5` (scientific notation), `0xD5` (hexadecimal notation).

* __Support for expressions as end points in ranges__: This implementation supports expressions as endpoints
  for ranges. For example, `[date("2016-11-24")..date("2016-11-27")]`

* __Support for additional types__: The specification only defines the following as basic types of the language:
  ** number
  ** string
  ** boolean
  ** days and time duration
  ** years and month duration
  ** time
  ** date and time
+
For completeness and orthogonality, this implementation also supports the following types:

  ** context
  ** list
  ** range
  ** function
  ** unary test

* __Support for unary tests__: For completeness and orthogonality, unary tests are supported
  as first class citizens in the language. They are functions with an implicit single
  parameter and can be invoked in the same way as functions. For example,
+
[source,json]
.UnaryTestAsFunction.feel
----
  {
      is minor : < 18,
      Bob is minor : is minor( bob.age )
  }
----

* __Support for additional built-in functions__: The following additional functions are supported:

  ** `now()` : Returns the current local date and time.
  ** `today()` : Returns the current local date.
  ** `decision table()` : Returns a decision table function, although the specification mentions a decision table.
  The function on page 114 is not implementable as defined.
  ** `string( mask, p... )` : Returns a string formatted as per the mask. See Java String.format() for
  details on the mask syntax. For example, `string( "%4.2f", 7.1298 )` returns the string `"7.12"`.

* __Support for additional date and time arithmetics__: Subtracting two dates returns a day and time duration with the number of days between the two
  dates, ignoring daylight savings. For example,
+
[source,json]
.DateArithmetic.feel
----
date( "2017-05-12" ) - date( "2017-04-25" ) = duration( "P17D" )
----

[id="ref-dmn-model-enhancements_{context}"]
=== DMN model enhancements in {PRODUCT}

[role="_abstract"]
{PRODUCT} includes the following enhancements to DMN model support in the current DMN implementation:

* __Support for types with spaces on names__: The DMN XML schema defines type refs such as QNames. The QNames do not allow spaces. Therefore, it is not possible to use types like FEEL `date and time`,   `days and time duration` or `years and months duration`. This implementation does parse such typerefs as strings and allows type names with spaces. However, in order to comply with the XML schema, it also adds the following aliases to such types that can be used instead:

  ** `date and time` = `dateTime`
  ** `days and time duration` = `duration` or `dayTimeDuration`
  ** `years and months duration` = `duration` or `yearMonthDuration`
+
Note that, for the "duration" types, the user can simply use `duration` and the {DECISION_ENGINE} will infer the proper duration, either `days and time duration` or `years and months duration`.

* __Lists support heterogeneous element types__: Currently this implementation supports lists with heterogeneous element types. This is an experimental extension and does limit the functionality of some functions and filters. This decision will be re-evaluated in the future.

* __TypeRef link between Decision Tables and Item Definitions__: On decision tables/input clause, if no values list is defined, the {DECISION_ENGINE} automatically checks the type reference and applies the allowed values check if it is defined.
endif::[]

[id="proc-dmn-model-creating_{context}"]
== Creating and editing DMN models in the {PRODUCT} DMN modeler

[role="_abstract"]
You can use the {PRODUCT} DMN modeler in VSCode to design DMN decision requirements diagrams (DRDs) and define decision logic for a complete and functional DMN decision model. {PRODUCT} provides design support for DMN 1.2 models at conformance level 3, and includes enhancements and fixes to FEEL and DMN model components to optimize the experience of implementing DMN decision services with {PRODUCT}. {PRODUCT} also provides runtime support for DMN 1.1, 1.2, 1.3, and 1.4 models at conformance level 3. Any DMN 1.1 and 1.3 models (do not contain DMN 1.3 features) that you import, open in the DMN designer, and save are converted to DMN 1.2 models.

.Prerequisites
* https://code.visualstudio.com/[VSCode] 1.46.0 or later is installed.
* The *{PRODUCT} Bundle* VSCode extension is installed and enabled in your VSCode IDE. For information about enabling the VSCode extension, see {URL_CREATING_RUNNING}#proc-kogito-vscode-extension_kogito-creating-running[_{CREATING_RUNNING}_].
* You have created a {PRODUCT} project and have included any Java objects required for your {PRODUCT} service. For information about creating a project, see {URL_CREATING_RUNNING}[_{CREATING_RUNNING}_].

.Procedure
. In your VSCode IDE, create or import a DMN file in the relevant folder of your {PRODUCT} project, typically in `src/main/resources`.
+
NOTE: For a new DMN file, you can also enter `dmn.new` in a web browser to design your decision model in the {PRODUCT} online DMN modeler. When you finish creating your decision model, you can click *Download* in the online modeler page to import your DMN file into your {PRODUCT} project.

. Open the new or imported DMN file to view the decision requirements diagram (DRD) in the {PRODUCT} DMN modeler.
+
--
If the DRD does not open in the {PRODUCT} DMN modeler, ensure that you have installed and enabled the *{PRODUCT} Bundle* VSCode extension.

If the {PRODUCT} DMN modeler opens only the XML source of the DMN file and displays an error message, review the reported errors and the DMN model file to ensure that all DMN elements are correctly defined.
--
. Begin adding components to your new or imported DRD by clicking and dragging one of the DMN nodes from the left toolbar:
+
--
.Adding DRD components
image::kogito/dmn/dmn-drag-decision-node.png[]

The following DRD components are available:

* *Decision*: Use this node for a DMN decision, where one or more input elements determine an output based on defined decision logic.
* *Business knowledge model*: Use this node for reusable functions with one or more decision elements. Decisions that have the same logic but depend on different sub-input data or sub-decisions use business knowledge models to determine which procedure to follow.
* *Knowledge source*: Use this node for external authorities, documents, committees, or policies that regulate a decision or business knowledge model. Knowledge sources are references to real-world factors rather than executable business rules.
* *Input data*: Use this node for information used in a decision node or a business knowledge model. Input data usually includes business-level concepts or objects relevant to the business, such as loan applicant data used in a lending strategy.
* *Text annotation*: Use this node for explanatory notes associated with an input data node, decision node, business knowledge model, or knowledge source.
* *Decision service*: Use this node to enclose a set of reusable decisions implemented as a decision service for invocation. A decision service can be used in other DMN models and can be invoked from an external application or a BPMN business process.

--
. In the DMN modeler canvas, double-click the new DRD node to enter an informative node name.
. If the node is a decision or business knowledge model, select the node to display the node options and click the *Edit* icon to open the DMN boxed expression editor to define the decision logic for the node:
+
--
.Opening a new decision node boxed expression
image::kogito/dmn/dmn-decision-edit.png[]

.Opening a new business knowledge model boxed expression
image::kogito/dmn/dmn-bkm-edit.png[]

By default, all business knowledge models are defined as boxed function expressions containing a literal FEEL expression, a nested context expression of an external JAVA or PMML function, or a nested boxed expression of any type.

For decision nodes, you click the undefined table to select the type of boxed expression you want to use, such as a boxed literal expression, boxed context expression, decision table, or other DMN boxed expression.

.Selecting the logic type for a decision node
image::kogito/dmn/dmn-decision-boxed-expression-options.png[]

For business knowledge models, you click the upper-left function cell to select the function type, or right-click the function value cell, select *Clear*, and select a boxed expression of another type.

.Selecting the function or other logic type for a business knowledge model
image::kogito/dmn/dmn-bkm-define.png[]
--
. In the selected boxed expression editor for either a decision node (any expression type) or business knowledge model (function expression), click the applicable table cells to define the table name, variable data types, variable names and values, function parameters and bindings, or FEEL expressions to include in the decision logic.
+
--
You can right-click cells for additional actions where applicable, such as inserting or removing table rows and columns or clearing table contents.

The following is an example decision table for a decision node that determines credit score ratings based on a defined range of a loan applicant's credit score:

.Decision node decision table for credit score rating
image::kogito/dmn/dmn-decision-table-example1a.png[]

The following is an example boxed function expression for a business knowledge model that calculates mortgage payments based on principal, interest, taxes, and insurance (PITI) as a literal expression:

.Business knowledge model function for PITI calculation
image::kogito/dmn/dmn-function-expression-example4.png[]
////
NOTE: This PITI calculation logic can also be expressed as a boxed literal expression outside of a business knowledge model, but because business knowledge models are defined as function expressions, this expression becomes a function in this case. This requirement applies to any expression types that you use in business knowledge models.

For more details about the types of boxed expressions, see xref:dmn-boxed-expressions-con-dmn-models[].

For more details about defining decision logic in boxed expressions, see xref:dmn-defining-logic-proc-dmn-models[].
////
--
. After you define the decision logic for the selected node, click *Back to __MODEL_NAME__* to return to the DRD view.
. For the selected DRD node, use the available connection options to create and connect to the next node in the DRD, or click and drag a new node onto the DRD canvas from the left toolbar.
+
--
The node type determines which connection options are supported. For example, an *Input data* node can connect to a decision node, knowledge source, or text annotation using the applicable connection type, whereas a *Knowledge source* node can connect to any DRD element. A *Decision* node can connect only to another decision or a text annotation.

The following connection types are available, depending on the node type:

* *Information requirement*: Use this connection from an input data node or decision node to another decision node that requires the information.
* *Knowledge requirement*: Use this connection from a business knowledge model to a decision node or to another business knowledge model that invokes the decision logic.
* *Authority requirement*: Use this connection from an input data node or a decision node to a dependent knowledge source or from a knowledge source to a decision node, business knowledge model, or another knowledge source.
* *Association*: Use this connection from an input data node, decision node, business knowledge model, or knowledge source to a text annotation.
////
For more details about DRD components and connector rules, see xref:dmn-drd-components-ref-dmn-models[].
////

.Connecting credit score input to the credit score rating decision
image::kogito/dmn/dmn-input-connection-example.png[]

image::kogito/dmn/dmn-input-connection-example2.png[]
--
. Continue adding and defining the remaining DRD components of your decision model and save the completed DRD.
+
--
The following is an example DRD for a loan prequalification decision model:

.Completed DRD for loan prequalification
image::kogito/dmn/dmn-example-drd.png[]

The following is an example DRD for a phone call handling decision model using a reusable decision service:

.Completed DRD for phone call handling with a decision service
image::kogito/dmn/dmn-example-drd3.png[width=90%]

In a DMN decision service node, the decision nodes in the bottom segment incorporate input data from outside of the decision service to arrive at a final decision in the top segment of the decision service node. The resulting top-level decisions from the decision service are then implemented in any subsequent decisions or business knowledge requirements of the DMN model. You can reuse DMN decision services in other DMN models to apply the same decision logic with different input data and different outgoing connections.
--

[id="proc-dmn-logic-defining_{context}"]
=== Defining DMN decision logic in boxed expressions in the {PRODUCT} DMN modeler

[role="_abstract"]
Boxed expressions in DMN are tables that you use to define the underlying logic of decision nodes and business knowledge models in a decision requirements diagram (DRD). Some boxed expressions can contain other boxed expressions, but the top-level boxed expression corresponds to the decision logic of a single DRD artifact. While DRDs represent the flow of a DMN decision model, boxed expressions define the actual decision logic of individual nodes. DRDs and boxed expressions together form a complete and functional DMN decision model.

You can use the {PRODUCT} DMN modeler in VSCode to define decision logic for your DRD components using built-in boxed expressions.

.Prerequisites
* A DMN file is created or imported in your {PRODUCT} project in VSCode.

.Procedure
. In your VSCode IDE, open the DMN file to view the decision requirements diagram (DRD) in the {PRODUCT} DMN modeler.
+
--
If the DRD does not open in the {PRODUCT} DMN modeler, ensure that you have installed and enabled the *{PRODUCT} Bundle* VSCode extension.

If the {PRODUCT} DMN modeler opens only the XML source of the DMN file and displays an error message, review the reported errors and the DMN model file to ensure that all DMN elements are correctly defined.
--
. In the DMN modeler canvas, select a decision node or business knowledge model node that you want to define and click the *Edit* icon to open the DMN boxed expression editor:
+
--
.Opening a new decision node boxed expression
image::kogito/dmn/dmn-decision-edit.png[]

.Opening a new business knowledge model boxed expression
image::kogito/dmn/dmn-bkm-edit.png[]

By default, all business knowledge models are defined as boxed function expressions containing a literal FEEL expression, a nested context expression of an external JAVA or PMML function, or a nested boxed expression of any type.

For decision nodes, you click the undefined table to select the type of boxed expression you want to use, such as a boxed literal expression, boxed context expression, decision table, or other DMN boxed expression.

.Selecting the logic type for a decision node
image::kogito/dmn/dmn-decision-boxed-expression-options.png[]

For business knowledge model nodes, you click the upper-left function cell to select the function type, or right-click the function value cell, select *Clear*, and select a boxed expression of another type.

.Selecting the function or other logic type for a business knowledge model
image::kogito/dmn/dmn-bkm-define.png[]
--
. For this example, use a decision node and select *Decision Table* as the boxed expression type.
+
A decision table in DMN is a visual representation of one or more rules in a tabular format. Each rule consists of a single row in the table, and includes columns that define the conditions (input) and outcome (output) for that particular row.
. Click the input column header to define the name and data type for the input condition. For example, name the input column *Credit Score.FICO* with a `number` data type. This column specifies numeric credit score values or ranges of loan applicants.
. Click the output column header to define the name and data type for the output values. For example, name the output column *Credit Score Rating* and next to the *Data Type* option, click *Manage* to go to the *Data Types* page where you can create a custom data type with score ratings as constraints.
+
.Managing data types for a column header value
image::kogito/dmn/dmn-manage-data-types.png[]

. On the *Data Types* page, click *New Data Type* to add a new data type.
+
--
For this example, click *New Data Type* and create a *Credit_Score_Rating* data type as a `string`:

.Adding a new data type
image::kogito/dmn/dmn-custom-data-type-add.png[]
--
. Click *Add Constraints*, select *Enumeration* from the drop-down options, and add the following constraints:
+
--
* `"Excellent"`
* `"Good"`
* `"Fair"`
* `"Poor"`
* `"Bad"`

.Adding constraints to the new data type
image::kogito/dmn/dmn-custom-data-type-constraints.png[]

To change the order of data type constraints, you can click the left end of the constraint row and drag the row as needed:

.Dragging constraints to change constraint order
image::kogito/dmn/dmn-custom-data-type-constraints-drag.png[]

For information about constraint types and syntax requirements for the specified data type, see the https://www.omg.org/spec/DMN[Decision Model and Notation specification].
--

. Click *OK* to save the constraints and click the check mark to the right of the data type to save the data type.
. Return to the *Credit Score Rating* decision table, click the *Credit Score Rating* column header, and set the data type to this new custom data type.
. Use the *Credit Score.FICO* input column to define credit score values or ranges of values, and use the *Credit Score Rating* column to specify one of the corresponding ratings you defined in the *Credit_Score_Rating* data type.
+
Right-click any value cell to insert or delete rows (rules) or columns (clauses).
+
.Decision node decision table for credit score rating
image::kogito/dmn/dmn-decision-table-example1a.png[]

. After you define all rules, click the upper-left corner of the decision table to define the rule *Hit Policy* and *Builtin Aggregator* (for *COLLECT* hit policy only).
+
--
The hit policy determines how to reach an outcome when multiple rules in a decision table match the provided input values. The built-in aggregator determines how to aggregate rule values when you use the *COLLECT* hit policy.

.Defining the decision table hit policy
image::kogito/dmn/dmn-hit-policies.png[]

The following example is a more complex decision table that determines applicant qualification for a loan as the concluding decision node in the same loan prequalification decision model:

.Decision table for loan prequalification
image::kogito/dmn/dmn-decision-table-example3.png[]
--

For boxed expression types other than decision tables, you follow these guidelines similarly to navigate the boxed expression tables and define variables and parameters for decision logic, but according to the requirements of the boxed expression type. Some boxed expressions, such as boxed literal expressions, can be single-column tables, while other boxed expressions, such as function, context, and invocation expressions, can be multi-column tables with nested boxed expressions of other types.

For example, the following boxed context expression defines the parameters that determine whether a loan applicant can meet minimum mortgage payments based on principal, interest, taxes, and insurance (PITI), represented as a front-end ratio calculation with a sub-context expression:

.Boxed context expression for front-end client PITI ratio
image::kogito/dmn/dmn-context-expression-example2.png[]

The following boxed function expression determines a monthly mortgage installment as a business knowledge model in a lending decision, with the function value defined as a nested context expression:

.Boxed function expression for installment calculation in business knowledge model
image::kogito/dmn/dmn-function-expression-example3.png[]

For more information and examples of each boxed expression type, see xref:con-dmn-boxed-expressions_kogito-dmn-models[].

[id="proc-dmn-data-types-defining_{context}"]
=== Creating custom data types for DMN boxed expressions in the {PRODUCT} DMN modeler

[role="_abstract"]
In DMN boxed expressions in the {PRODUCT} DMN modeler, data types determine the structure of the data that you use within an associated table, column, or field in the boxed expression. You can use default DMN data types (such as String, Number, Boolean) or you can create custom data types to specify additional fields and constraints that you want to implement for the boxed expression values.

Custom data types that you create for a boxed expression can be simple or structured:

* *Simple* data types have only a name and a type assignment. Example: `Age (number)`.
* *Structured* data types contain multiple fields associated with a parent data type. Example: A single type `Person` containing the fields `Name (string)`, `Age (number)`, `Email (string)`.

.Prerequisites
* A DMN file is created or imported in your {PRODUCT} project in VSCode.

.Procedure
. In your VSCode IDE, open the DMN file to view the decision requirements diagram (DRD) in the {PRODUCT} DMN modeler.
+
--
If the DRD does not open in the {PRODUCT} DMN modeler, ensure that you have installed and enabled the *{PRODUCT} Bundle* VSCode extension.

If the {PRODUCT} DMN modeler opens only the XML source of the DMN file and displays an error message, review the reported errors and the DMN model file to ensure that all DMN elements are correctly defined.
--
. In the DMN modeler canvas, select a decision node or business knowledge model for which you want to define the data types and click the *Edit* icon to open the DMN boxed expression editor.
. If the boxed expression is for a decision node that is not yet defined, click the undefined table to select the type of boxed expression you want to use, such as a boxed literal expression, boxed context expression, decision table, or other DMN boxed expression.
+
.Selecting the logic type for a decision node
image::kogito/dmn/dmn-decision-boxed-expression-options.png[]

. Click the cell for the table header, column header, or parameter field (depending on the boxed expression type) for which you want to define the data type and click *Manage* to go to the *Data Types* page where you can create a custom data type.
+
--
.Managing data types for a column header value
image::kogito/dmn/dmn-manage-data-types.png[]

You can also set and manage custom data types for a specified decision node or business knowledge model node by selecting the *Properties* icon in the upper-right corner of the DMN modeler:

.Managing data types in decision requirements diagram (DRD) properties
image::kogito/dmn/dmn-manage-data-types1a.png[]

The data type that you define for a specified cell in a boxed expression determines the structure of the data that you use within that associated table, column, or field in the boxed expression.

In this example, an output column *Credit Score Rating* for a DMN decision table defines a set of custom credit score ratings based on an applicant's credit score.
--
. On the *Data Types* page, click *New Data Type* to add a new data type.
+
--
For this example, click *New Data Type* and create a *Credit_Score_Rating* data type as a `string`:

.Adding a new data type
image::kogito/dmn/dmn-custom-data-type-add.png[]

If the data type requires a list of items, enable the *List* setting.
--
. Click *Add Constraints*, select *Enumeration* from the drop-down options, and add the following constraints:
+
--
* `"Excellent"`
* `"Good"`
* `"Fair"`
* `"Poor"`
* `"Bad"`

.Adding constraints to the new data type
image::kogito/dmn/dmn-custom-data-type-constraints.png[]

To change the order of data type constraints, you can click the left end of the constraint row and drag the row as needed:

.Dragging constraints to change constraint order
image::kogito/dmn/dmn-custom-data-type-constraints-drag.png[]

For information about constraint types and syntax requirements for the specified data type, see the https://www.omg.org/spec/DMN[Decision Model and Notation specification].
--

. Click *OK* to save the constraints and click the check mark to the right of the data type to save the data type.

. Return to the *Credit Score Rating* decision table, click the *Credit Score Rating* column header, set the data type to this new custom data type, and define the rule values for that column with the rating constraints that you specified.
+
--
.Decision table for credit score rating
image::kogito/dmn/dmn-decision-table-example1a.png[]

In the DMN decision model for this scenario, the *Credit Score Rating* decision flows into the following *Loan Prequalification* decision that also requires custom data types:

.Decision table for loan prequalification
image::kogito/dmn/dmn-manage-data-types-blank.png[]
--
. Continuing with this example, return to the *Data Types* window, click *New Data Type*, and create a *Loan_Qualification* data type as a `Structure` with no constraints.
+
--
When you save the new structured data type, the first sub-field appears so that you can begin defining nested data fields in this parent data type. You can use these sub-fields in association with the parent structured data type in boxed expressions, such as nested column headers in decision tables or nested table parameters in context or function expressions.

For additional sub-fields, select the addition icon next to the *Loan_Qualification* data type:

.Adding a new structured data type with nested fields
image::kogito/dmn/dmn-manage-data-types-structured.png[]
--
. For this example, under the structured *Loan_Qualification* data type, add a *Qualification* field with `"Qualified"` and `"Not Qualified"` enumeration constraints, and a *Reason* field with no constraints. Add also a simple *Back_End_Ratio* and a *Front_End_Ratio* data type, both with `"Sufficient"` and `"Insufficient"` enumeration constraints.
+
--
Click the check mark to the right of each data type that you create to save your changes.

.Adding nested data types with constraints
image::kogito/dmn/dmn-manage-data-types-structured2.png[]

To change the order or nesting of data types, you can click the left end of the data type row and drag the row as needed:

.Dragging data types to change data type order or nesting
image::kogito/dmn/dmn-manage-data-types-structured2-drag.png[]
--
. Return to the decision table and, for each column, click the column header cell, set the data type to the new corresponding custom data type, and define the rule values as needed for the column with the constraints that you specified, if applicable.
+
.Decision table for loan prequalification
image::kogito/dmn/dmn-decision-table-example3.png[]

For boxed expression types other than decision tables, you follow these guidelines similarly to navigate the boxed expression tables and define custom data types as needed.

For example, the following boxed function expression uses custom `tCandidate` and `tProfile` structured data types to associate data for online dating compatibility:

.Boxed function expression for online dating compatibility
image::kogito/dmn/dmn-manage-data-types-structured3.png[]

.Custom data type definitions for online dating compatibility
image::kogito/dmn/dmn-manage-data-types-structured3a.png[]

.Parameter definitions with custom data types for online dating compatibility
image::kogito/dmn/dmn-manage-data-types-structured3b.png[]

[id="con-dmn-included-models_{context}"]
=== Included models in DMN files in the {PRODUCT} VSCode DMN modeler

[role="_abstract"]
In the {PRODUCT} DMN modeler in VSCode, you can use the *Included Models* tab to include other DMN models and Predictive Model Markup Language (PMML) models from your project in a specified DMN file. When you include a DMN model within another DMN file, you can use all of the nodes and logic from both models in the same decision requirements diagram (DRD). When you include a PMML model within a DMN file, you can invoke that PMML model as a boxed function expression for a DMN decision node or business knowledge model node.

You cannot include DMN or PMML models from different directories within your {PRODUCT} project or from other {PRODUCT} projects.

NOTE: Included models are not supported in the *{PRODUCT} GitHub Chrome extension* and *Business Modeler standalone editors*.

[id="proc-dmn-included-models-dmn_{context}"]
==== Including other DMN models within a DMN file in the {PRODUCT} VSCode DMN modeler

[role="_abstract"]
In the {PRODUCT} DMN modeler in VSCode, you can include other DMN models from the same directory of your {PRODUCT} project in a specified DMN file. When you include a DMN model within another DMN file, you can use all of the nodes and logic from both models in the same decision requirements diagram (DRD), but you cannot edit the nodes from the included model. To edit nodes from included models, you must update the source file for the included model directly. If you update the source file for an included DMN model, open the DMN file where the DMN model is included (or close and re-open) to verify the changes.

You cannot include DMN models from different directories within your {PRODUCT} project or from other {PRODUCT} projects.

.Prerequisites
* The DMN models are created or imported (as `.dmn` files) in the same directory of your {PRODUCT} project as the DMN file in which you want to include the models, such as in `src/main/resources`.

.Procedure
. In your VSCode IDE, open the DMN file to view the decision requirements diagram (DRD) in the {PRODUCT} DMN modeler.
+
--
If the DRD does not open in the {PRODUCT} DMN modeler, ensure that you have installed and enabled the *{PRODUCT} Bundle* VSCode extension.

If the {PRODUCT} DMN modeler opens only the XML source of the DMN file and displays an error message, review the reported errors and the DMN model file to ensure that all DMN elements are correctly defined.
--
. In the DMN modeler, click the *Included Models* tab.
. Click *Include Model*, select a DMN model from your directory in the *Models* list, enter a unique name for the included model, and click *Include*:
+
--
.Including a DMN model
image::kogito/dmn/dmn-include-model.png[]

The DMN model is added to this DMN file, and all DRD nodes from the included model are listed under *Decision Components* in the *Decision Navigator* view:

.DMN file with decision components from the included DMN model
image::kogito/dmn/dmn-include-model-list.png[]

All data types from the included model are also listed in read-only mode in the *Data Types* tab for the DMN file:

.DMN file with data types from the included DMN model
image::kogito/dmn/dmn-include-model-data-types.png[]
--
. In the *Editor* tab of the DMN modeler, click and drag the included DRD components onto the canvas to begin implementing them in your DRD:
+
--
.Adding DRD components from the included DMN model
image::kogito/dmn/dmn-include-model-drd.png[]

To edit DRD nodes or data types from included models, you must update the source file for the included model directly. If you update the source file for an included DMN model, open the DMN file where the DMN model is included (or close and re-open) to verify the changes.

To edit the included model name or to remove the included model from the DMN file, use the *Included Models* tab in the DMN modeler.

IMPORTANT: When you remove an included model, any nodes from that included model that are currently used in the DRD are also removed.
--

[id="proc-dmn-included-models-pmml_{context}"]
==== Including PMML models within a DMN file in the {PRODUCT} VSCode DMN modeler

[role="_abstract"]
In the {PRODUCT} DMN modeler in VSCode, you can include Predictive Model Markup Language (PMML) models from your project in a specified DMN file. When you include a PMML model within a DMN file, you can invoke that PMML model as a boxed function expression for a DMN decision node or business knowledge model node. If you update the source file for an included PMML model, you must remove and re-include the PMML model in the DMN file to apply the source changes.

You cannot include PMML models from different directories within your {PRODUCT} project or from other {PRODUCT} projects.

.Prerequisites
* The PMML models are created or imported (as `.pmml` files) in the same directory of your {PRODUCT} project as the DMN file in which you want to include the models, such as in `src/main/resources`.


.Procedure
. In your VSCode IDE, open the DMN file to view the decision requirements diagram (DRD) in the {PRODUCT} DMN modeler.
+
--
If the DRD does not open in the {PRODUCT} DMN modeler, ensure that you have installed and enabled the *{PRODUCT} Bundle* VSCode extension.

If the {PRODUCT} DMN modeler opens only the XML source of the DMN file and displays an error message, review the reported errors and the DMN model file to ensure that all DMN elements are correctly defined.
--
. In the DMN modeler, click the *Included Models* tab.
. Click *Include Model*, select a PMML model from your directory in the *Models* list, enter a unique name for the included model, and click *Include*:
+
--
.Including a PMML model
image::kogito/dmn/dmn-include-model-pmml.png[]

The PMML model is added to this DMN file:

.DMN file with included PMML model
image::kogito/dmn/dmn-include-model-list-pmml.png[]
--
. In the *Editor* tab of the DMN modeler, select or create the decision node or business knowledge model node in which you want to invoke the PMML model and click the *Edit* icon to open the DMN boxed expression editor:
+
--
.Opening a new decision node boxed expression
image::kogito/dmn/dmn-decision-edit.png[]

.Opening a new business knowledge model boxed expression
image::kogito/dmn/dmn-bkm-edit.png[]
--
. Set the expression type to *Function* (default for business knowledge model nodes), click the upper-left function cell, and select *PMML*.
. In the *document* and *model* rows in the table, double-click the undefined cells to specify the included PMML document and the relevant PMML model within that document:
+
--
.Adding a PMML model in a DMN business knowledge model
image::kogito/dmn/dmn-include-model-expression-pmml.png[]

.Example PMML definition in a DMN business knowledge model
image::kogito/dmn/dmn-function-expression-example5.png[]

If you update the source file for an included PMML model, you must remove and re-include the PMML model in the DMN file to apply the source changes.

To edit the included model name or to remove the included model from the DMN file, use the *Included Models* tab in the DMN modeler.
--

[id="proc-dmn-model-creating-multiples_{context}"]
=== Creating DMN models with multiple diagrams in the {PRODUCT} DMN modeler

[role="_abstract"]
For complex DMN models, you can use the {PRODUCT} DMN modeler in VSCode to design multiple DMN decision requirements diagrams (DRDs) that represent parts of the overall decision requirements graph (DRG) for the DMN decision model. In simple cases, you can use a single DRD to represent all of the overall DRG for the decision model, but in complex cases, a single DRD can become large and difficult to follow. Therefore, to better organize DMN decision models with many decision requirements, you can divide the model into smaller nested DRDs that constitute the larger central DRD representation of the overall DRG.

.Prerequisites
* You understand how to design DRDs in the {PRODUCT} DMN modeler. For information about creating DRDs, see xref:proc-dmn-model-creating_kogito-dmn-models[].

.Procedure
. In your VSCode IDE, create or import a DMN file in the relevant folder of your {PRODUCT} project, typically in `src/main/resources`.
+
NOTE: For a new DMN file, you can also enter `dmn.new` in a web browser to design your decision model in the {PRODUCT} online DMN modeler. When you finish creating your decision model, you can click *Download* in the online modeler page to import your DMN file into your {PRODUCT} project.

. Open the new or imported DMN file to view the DRD in the {PRODUCT} DMN modeler, and begin designing or modifying the DRD using the DMN nodes in the left toolbar.
+
--
If the DRD does not open in the {PRODUCT} DMN modeler, ensure that you have installed and enabled the *{PRODUCT} Bundle* VSCode extension.

If the {PRODUCT} DMN modeler opens only the XML source of the DMN file and displays an error message, review the reported errors and the DMN model file to ensure that all DMN elements are correctly defined.
--
. For any DMN nodes that you want to define in a separate nested DRD, select the node, click the *DRD Actions* icon, and select from the available options.
+
--
.DRD actions icon for subdividing a DRD
image::kogito/dmn/dmn-drd-actions.png[]

The following options are available:

* *Create*: Use this option to create a nested DRD where you can separately define the DMN components and diagram for the selected node.
* *Add to*: If you already created a nested DRD, use this option to add the selected node to an existing DRD.
* *Remove*: If the node that you selected is already within a nested DRD, use this option to remove the node from that nested DRD.

After you create a nested DRD within your DMN decision model, the new DRD opens in a separate DRD canvas and the available DRD and components are listed in the *Decision Navigator* right menu. You can use the *Decision Navigator* menu to rename or remove a nested DRD.

.Rename new nested DRD in the Decision Navigator menu
image::kogito/dmn/dmn-drd-actions-rename.png[]
--
. In the separate canvas for the new nested DRD, design the flow and logic for all required components in this portion of the DMN model, as usual.
. Continue adding and defining any other nested DRDs for your decision model and save the completed DMN file.
+
--
For example, the following DRD for a loan prequalification decision model contains all DMN components for the model without any nested DRDs. This example relies on the single DRD for all components and logic, resulting in a large and complex diagram.

.Single DRD for loan prequalification
image::kogito/dmn/dmn-example-drd.png[]

Alternatively, by following the steps in this procedure, you can divide this example DRD into multiple nested DRDs to better organize the decision requirements, as shown in the following example:

.Multiple nested DRDs for loan prequalification
image::kogito/dmn/dmn-drd-multiple.png[]

.Overview of front end ratio DRD
image::kogito/dmn/dmn-drd-multiple-front-end.png[]

.DRD for front end ratio
image::kogito/dmn/dmn-drd-multiple-front-end-details.png[]

.Overview of credit score rating DRD
image::kogito/dmn/dmn-drd-multiple-credit-score.png[]

.DRD for credit score rating
image::kogito/dmn/dmn-drd-multiple-credit-score-details.png[]

.Overview of back end ratio DRD
image::kogito/dmn/dmn-drd-multiple-back-end.png[]

.DRD for back end ratio
image::kogito/dmn/dmn-drd-multiple-back-end-details.png[]
--

[id="con-dmn-documentation_{context}"]
=== DMN model documentation in the {PRODUCT} DMN modeler

[role="_abstract"]
In the {PRODUCT} DMN modeler, you can use the *Documentation* tab to generate a report of your DMN model. The DMN model report contains all decision requirements diagrams (DRDs), data types, and boxed expressions in your DMN model. You can use this report to share your DMN model details or as part of your internal reporting workflow.

.Example DMN model report
image::kogito/dmn/dmn-documentation.png[]

[id="ref-dmn-designer-nav_{context}"]
=== {PRODUCT} DMN modeler navigation and properties

[role="_abstract"]
The {PRODUCT} DMN modeler provides the following additional features to help you navigate through the components and properties of decision requirements diagrams (DRDs).

DMN decision and diagram views::
In the upper-right corner of the DMN modeler, select the *Decision Navigator* view to navigate between the decision components, graphs, and boxed expressions of a selected DRD:
+
--
.Decision Navigator view
image::kogito/dmn/dmn-designer-nav-view.png[]

image::kogito/dmn/dmn-designer-nav-view2.png[]

NOTE: The DRD components from any DMN models included in the DMN file (in the *Included Models* tab) are also listed in the *Decision Components* panel for the DMN file.

In the upper-right corner of the DMN modeler, select the *Preview* icon to view an elevated preview of the DRD:

.Diagram preview
image::kogito/dmn/dmn-designer-preview.png[]
--

DRD properties and design::
In the upper-right corner of the DMN modeler, select the *Properties* icon to modify the identifying information, data types, and appearance of a selected DRD, DRD node, or boxed expression cell:
+
--
.DRD node properties
image::kogito/dmn/dmn-designer-properties.png[]

To view the properties of the entire DRD, click the DRD canvas background instead of a specific node.
--

DRD search::
In the upper-right corner of the DMN modeler, use the search bar to search for text that appears in your DRD. The search feature is especially helpful in complex DRDs with many nodes:
+
.DRD search
image::kogito/dmn/dmn-designer-search.png[]

DMN decision service details::
Select a decision service node in the DMN designer to view additional properties, including *Input Data*, *Encapsulated Decisions*, and *Output Decisions* in the *Properties* panel.
+
.Decision Service details
image::kogito/dmn/dmn-decision-service-details.png[]

////
//@comment: Not yet applicable for Kogito. (Stetson, 5 March 2020)

[id="con-dmn-execution_{context}"]
== DMN model execution

[role="_abstract"]
You can create or import DMN files in your {PRODUCT} project using {CENTRAL} or package the DMN files as part of your project knowledge JAR (KJAR) file without {CENTRAL}. After you implement your DMN files in your {PRODUCT} project, you can execute the DMN decision service by deploying the KIE container that contains it to {KIE_SERVER} for remote access
ifeval::["{context}" == "decision-service-getting-started"]
and interacting with the container using the {KIE_SERVER} REST API.
endif::[]
ifeval::["{context}" == "kogito-dmn-models"]
or by manipulating the KIE container directly as a dependency of the calling application. Other options for creating and deploying DMN knowledge packages are also available, and most are similar for all types of knowledge assets, such as DRL files or process definitions.
endif::[]

For information about including external DMN assets with your project packaging and deployment method, see {URL_PACKAGING_DEPLOYING_PROJECT}#_builddeployutilizeandrunsection[_{PACKAGING_DEPLOYING_PROJECT}_].

[id="proc-dmn-execution-embedded_{context}"]
=== Embedding a DMN call directly in a Java application

[role="_abstract"]
A KIE container is local when the knowledge assets are either embedded directly into the calling program or are physically pulled in using Maven dependencies for the KJAR. You typically embed knowledge assets directly into a project if there is a tight relationship between the version of the code and the version of the DMN definition. Any changes to the decision take effect after you have intentionally updated and redeployed the application. A benefit of this approach is that proper operation does not rely on any external dependencies to the run time, which can be a limitation of locked-down environments.

Using Maven dependencies enables further flexibility because the specific version of the decision can dynamically change, (for example, by using a system property), and it can be periodically scanned for updates and automatically updated. This introduces an external dependency on the deploy time of the service, but executes the decision locally, reducing reliance on an external service being available during run time.

.Prerequisites
* You have built the DMN project as a KJAR artifact and deployed it to a Maven repository, or you have included your DMN assets as part of your project class path. Ideally, you have built the DMN project as an executable model for more efficient execution:
+
--
[source]
----
mvn clean install -DgenerateDMNModel=yes
----

For more information about project packaging and deployment and executable models, see {URL_PACKAGING_DEPLOYING_PROJECT}#_builddeployutilizeandrunsection[_{PACKAGING_DEPLOYING_PROJECT}_].
--

.Procedure
. In your client application, add the following dependencies to the relevant classpath of your Java project:
+
--
[source,xml,subs="attributes+"]
----
<!-- Required for the DMN runtime API -->
<dependency>
  <groupId>org.kie</groupId>
  <artifactId>kie-dmn-core</artifactId>
  <version>${{PRODUCT_INIT}.version}</version>
</dependency>

<!-- Required if not using classpath KIE container -->
<dependency>
  <groupId>org.kie</groupId>
  <artifactId>kie-ci</artifactId>
  <version>${{PRODUCT_INIT}.version}</version>
</dependency>
----

The `<version>` is the Maven artifact version for {PRODUCT} currently used in your project (for example, {MAVEN_ARTIFACT_VERSION}).

ifdef::DM,PAM[]
[NOTE]
====
Instead of specifying a {PRODUCT} `<version>` for individual dependencies, consider adding the {PRODUCT_BA} bill of materials (BOM) dependency to your project `pom.xml` file. The {PRODUCT_BA} BOM applies to both {PRODUCT_DM} and {PRODUCT_PAM}. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.

Example BOM dependency:

[source,xml,subs="attributes+"]
----
<dependency>
  <groupId>com.redhat.ba</groupId>
  <artifactId>ba-platform-bom</artifactId>
  <version>{BOM_VERSION}</version>
  <scope>import</scope>
  <type>pom</type>
</dependency>
----

For more information about the {PRODUCT_BA} BOM, see
ifdef::PAM[]
https://access.redhat.com/solutions/3405361[What is the mapping between RHPAM product and maven library version?].
endif::[]
ifdef::DM[]
https://access.redhat.com/solutions/3363991[What is the mapping between RHDM product and maven library version?].
endif::[]
====
endif::DM,PAM[]
--
. Create a KIE container from `classpath` or `ReleaseId`:
+
[source,java]
----
KieServices kieServices = KieServices.Factory.get();

ReleaseId releaseId = kieServices.newReleaseId( "org.acme", "my-kjar", "1.0.0" );
KieContainer kieContainer = kieServices.newKieContainer( releaseId );
----
+
Alternative option:
+
[source,java]
----
KieServices kieServices = KieServices.Factory.get();

KieContainer kieContainer = kieServices.getKieClasspathContainer();
----

. Obtain `DMNRuntime` from the KIE container and a reference to the DMN model to be evaluated, by using the model `namespace` and `modelName`:
+
[source,java]
----
DMNRuntime dmnRuntime = KieRuntimeFactory.of(kieContainer.getKieBase()).get(DMNRuntime.class);

String namespace = "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a";
String modelName = "dmn-movieticket-ageclassification";

DMNModel dmnModel = dmnRuntime.getModel(namespace, modelName);
----

. Execute the decision services for the desired model:
+
[source,java]
----
DMNContext dmnContext = dmnRuntime.newContext();  // <1>

for (Integer age : Arrays.asList(1,12,13,64,65,66)) {
    dmnContext.set("Age", age);  // <2>
    DMNResult dmnResult =
        dmnRuntime.evaluateAll(dmnModel, dmnContext);  // <3>

    for (DMNDecisionResult dr : dmnResult.getDecisionResults()) {  // <4>
        log.info("Age: " + age + ", " +
                 "Decision: '" + dr.getDecisionName() + "', " +
                 "Result: " + dr.getResult());
  }
}
----
<1> Instantiate a new DMN Context to be the input for the model evaluation. Note that this example is looping through the Age Classification decision multiple times.
<2> Assign input variables for the input DMN context.
<3> Evaluate all DMN decisions defined in the DMN model.
<4> Each evaluation may result in one or more results, creating the loop.
+
--

This example prints the following output:

----
Age 1 Decision 'AgeClassification' : Child
Age 12 Decision 'AgeClassification' : Child
Age 13 Decision 'AgeClassification' : Adult
Age 64 Decision 'AgeClassification' : Adult
Age 65 Decision 'AgeClassification' : Senior
Age 66 Decision 'AgeClassification' : Senior
----

If the DMN model was not previously compiled as an executable model for more efficient execution, you can enable the following property when you execute your DMN models:

[source]
----
-Dorg.kie.dmn.compiler.execmodel=true
----
--

[id="proc-dmn-execution-remote-java_{context}"]
=== Executing a DMN service using the {KIE_SERVER} Java client API

[role="_abstract"]
The {KIE_SERVER} Java client API provides a lightweight approach to invoking a remote DMN service either through the REST or JMS interfaces of {KIE_SERVER}. This approach reduces the number of runtime dependencies necessary to interact with a KIE base. Decoupling the calling code from the decision definition also increases flexibility by enabling them to iterate independently at the appropriate pace.

For more information about the {KIE_SERVER} Java client API, see {URL_KIE_APIS}#kie-server-java-api-con-kie-apis[_{KIE_APIS}_].

.Prerequisites
* {KIE_SERVER} is installed and configured, including a known user name and credentials for a user with the `kie-server` role. For installation options, see {URL_PLANNING_INSTALL}#_installationandsetup[_{PLANNING_INSTALL}_].
* You have built the DMN project as a KJAR artifact and deployed it to {KIE_SERVER}. Ideally, you have built the DMN project as an executable model for more efficient execution:
+
--
[source]
----
mvn clean install -DgenerateDMNModel=yes
----

For more information about project packaging and deployment and executable models, see {URL_PACKAGING_DEPLOYING_PROJECT}#_builddeployutilizeandrunsection[_{PACKAGING_DEPLOYING_PROJECT}_].
--
* You have the ID of the KIE container containing the DMN model. If more than one model is present, you must also know the model namespace and model name of the relevant model.

.Procedure
. In your client application, add the following dependency to the relevant classpath of your Java project:
+
--
[source,xml,subs="attributes+"]
----
<!-- Required for the {KIE_SERVER} Java client API -->
<dependency>
  <groupId>org.kie.server</groupId>
  <artifactId>kie-server-client</artifactId>
  <version>${{PRODUCT_INIT}.version}</version>
</dependency>
----

The `<version>` is the Maven artifact version for {PRODUCT} currently used in your project (for example, {MAVEN_ARTIFACT_VERSION}).

ifdef::DM,PAM[]
[NOTE]
====
Instead of specifying a {PRODUCT} `<version>` for individual dependencies, consider adding the {PRODUCT_BA} bill of materials (BOM) dependency to your project `pom.xml` file. The {PRODUCT_BA} BOM applies to both {PRODUCT_DM} and {PRODUCT_PAM}. When you add the BOM files, the correct versions of transitive dependencies from the provided Maven repositories are included in the project.

Example BOM dependency:

[source,xml,subs="attributes+"]
----
<dependency>
  <groupId>com.redhat.ba</groupId>
  <artifactId>ba-platform-bom</artifactId>
  <version>{BOM_VERSION}</version>
  <scope>import</scope>
  <type>pom</type>
</dependency>
----

For more information about the {PRODUCT_BA} BOM, see
ifdef::PAM[]
https://access.redhat.com/solutions/3405361[What is the mapping between RHPAM product and maven library version?].
endif::[]
ifdef::DM[]
https://access.redhat.com/solutions/3363991[What is the mapping between RHDM product and maven library version?].
endif::[]
====
endif::DM,PAM[]
--
. Instantiate a `KieServicesClient` instance with the appropriate connection information.
+
--
Example:

[source,java]
----
KieServicesConfiguration conf =
    KieServicesFactory.newRestConfiguration(URL, USER, PASSWORD); // <1>

conf.setMarshallingFormat(MarshallingFormat.JSON);  // <2>

KieServicesClient kieServicesClient = KieServicesFactory.newKieServicesClient(conf);
----
<1> The connection information:
* Example URL: `\http://localhost:8080/kie-server/services/rest/server`
* The credentials should reference a user with the `kie-server` role.
<2> The Marshalling format is an instance of `org.kie.server.api.marshalling.MarshallingFormat`. It controls whether the messages will be JSON or XML. Options for Marshalling format are JSON, JAXB, or XSTREAM.
--
. Obtain a `DMNServicesClient` from the KIE server Java client connected to the related {KIE_SERVER} by invoking the method `getServicesClient()` on the KIE server Java client instance:
+
[source,java]
----
DMNServicesClient dmnClient = kieServicesClient.getServicesClient(DMNServicesClient.class );
----
+
The `dmnClient` can now execute decision services on {KIE_SERVER}.

. Execute the decision services for the desired model.
+
--
Example:

[source,java]
----
for (Integer age : Arrays.asList(1,12,13,64,65,66)) {
    DMNContext dmnContext = dmnClient.newContext(); // <1>
    dmnContext.set("Age", age);  // <2>
    ServiceResponse<DMNResult> serverResp =   // <3>
        dmnClient.evaluateAll($kieContainerId,
                              $modelNamespace,
                              $modelName,
                              dmnContext);

    DMNResult dmnResult = serverResp.getResult();  // <4>
    for (DMNDecisionResult dr : dmnResult.getDecisionResults()) {
        log.info("Age: " + age + ", " +
                 "Decision: '" + dr.getDecisionName() + "', " +
                 "Result: " + dr.getResult());
    }
}
----
<1> Instantiate a new DMN Context to be the input for the model evaluation. Note that this example is looping through the Age Classification decision multiple times.
<2> Assign input variables for the input DMN Context.
<3> Evaluate all the DMN Decisions defined in the DMN model:
* `$kieContainerId` is the ID of the container where the KJAR containing the DMN model is deployed
* `$modelNamespace` is the namespace for the model.
* `$modelName` is the name for the model.
<4> The DMN Result object is available from the server response.

At this point, the `dmnResult` contains all the decision results from the evaluated DMN model.

You can also execute only a specific DMN decision in the model by using alternative methods of the `DMNServicesClient`.

NOTE: If the KIE container only contains one DMN model, you can omit `$modelNamespace` and `$modelName` because the {KIE_SERVER} API selects it by default.

--

[id="proc-dmn-execution-rest_{context}"]
=== Executing a DMN service using the {KIE_SERVER} REST API

[role="_abstract"]
Directly interacting with the REST endpoints of {KIE_SERVER} provides the most separation between the calling code and the decision logic definition. The calling code is completely free of direct dependencies, and you can implement it in an entirely different development platform such as `Node.js` or `.NET`. The examples in this section demonstrate Nix-style curl commands but provide relevant information to adapt to any REST client.

For more information about the {KIE_SERVER} REST API, see {URL_KIE_APIS}#kie-server-rest-api-con-kie-apis[_{KIE_APIS}_].

.Prerequisites
* {KIE_SERVER} is installed and configured, including a known user name and credentials for a user with the `kie-server` role. For installation options, see {URL_PLANNING_INSTALL}#_installationandsetup[_{PLANNING_INSTALL}_].
* You have built the DMN project as a KJAR artifact and deployed it to {KIE_SERVER}. Ideally, you have built the DMN project as an executable model for more efficient execution:
+
--
[source]
----
mvn clean install -DgenerateDMNModel=yes
----

For more information about project packaging and deployment and executable models, see {URL_PACKAGING_DEPLOYING_PROJECT}#_builddeployutilizeandrunsection[_{PACKAGING_DEPLOYING_PROJECT}_].
--
* You have the ID of the KIE container containing the DMN model. If more than one model is present, you must also know the model namespace and model name of the relevant model.

.Procedure
. Determine the base URL for accessing the {KIE_SERVER} REST API endpoints. This requires knowing the following values (with the default local deployment values as an example):
+
--
* Host (`localhost`)
* Port (`8080`)
* Root context (`kie-server`)
* Base REST path (`services/rest/`)

ifeval::["{context}" == "kogito-dmn-models"]
Example base URL in local deployment:

`\http://localhost:8080/kie-server/services/rest/`
endif::[]

ifeval::["{context}" == "decision-service-getting-started"]
Example base URL in local deployment for the traffic violations project:

`\http://localhost:8080/kie-server/services/rest/server/containers/traffic-violation_1.0.0`
endif::[]
--
. Determine user authentication requirements.
+
When users are defined directly in the {KIE_SERVER} configuration, HTTP Basic authentication is used and requires the user name and password. Successful requests require that the user have the `kie-server` role.
+
The following example demonstrates how to add credentials to a curl request:
+
[source]
----
curl -u username:password <request>
----
+
If {KIE_SERVER} is configured with Red Hat Single Sign-On, the request must include a bearer token:
+
[source,java]
----
curl -H "Authorization: bearer $TOKEN" <request>
----

. Specify the format of the request and response. The REST API endpoints work with both JSON and XML formats and are set using request headers:
+
.JSON
[source]
----
curl -H "accept: application/json" -H "content-type: application/json"
----
+
.XML
[source]
----
curl -H "accept: application/xml" -H "content-type: application/xml"
----

. (Optional) Query the container for a list of deployed decision models:
+
--
*[GET]* `server/containers/{containerId}/dmn`

Example curl request:

ifeval::["{context}" == "kogito-dmn-models"]
[source]
----
curl -u krisv:krisv -H "accept: application/xml" -X GET "http://localhost:8080/kie-server/services/rest/server/containers/MovieDMNContainer/dmn"
----

Sample XML output:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<response type="SUCCESS" msg="OK models successfully retrieved from container 'MovieDMNContainer'">
    <dmn-model-info-list>
        <model>
            <model-namespace>http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a</model-namespace>
            <model-name>dmn-movieticket-ageclassification</model-name>
            <model-id>_99</model-id>
            <decisions>
                <dmn-decision-info>
                    <decision-id>_3</decision-id>
                    <decision-name>AgeClassification</decision-name>
                </dmn-decision-info>
            </decisions>
        </model>
    </dmn-model-info-list>
</response>
----

Sample JSON output:

[source,json]
----
{
  "type" : "SUCCESS",
  "msg" : "OK models successfully retrieved from container 'MovieDMNContainer'",
  "result" : {
    "dmn-model-info-list" : {
      "models" : [ {
        "model-namespace" : "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a",
        "model-name" : "dmn-movieticket-ageclassification",
        "model-id" : "_99",
        "decisions" : [ {
          "decision-id" : "_3",
          "decision-name" : "AgeClassification"
        } ]
      } ]
    }
  }
}
----
--
endif::[]
ifeval::["{context}" == "decision-service-getting-started"]
[source]
----
curl -u wbadmin:wbadmin -H "accept: application/xml" -X GET "http://localhost:8080/kie-server/services/rest/server/containers/traffic-violation_1.0.0/dmn"
----

Sample XML output:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<response type="SUCCESS" msg="Ok models successfully retrieved from container 'Traffic-Violation_1.0.0'">
    <dmn-model-info-list>
        <model>
            <model-namespace>https://github.com/kiegroup/drools/kie-dmn/_60b01f4d-e407-43f7-848e-258723b5fac8</model-namespace>
            <model-name>Traffic Violation</model-name>
            <model-id>_2CD7D1AA-BD84-4B43-AD21-B0342ADE655A</model-id>
            <decisions>
                <dmn-decision-info>
                    <decision-id>_23428EE8-DC8B-4067-8E67-9D7C53EC975F</decision-id>
                    <decision-name>Fine</decision-name>
                </dmn-decision-info>
                <dmn-decision-info>
                    <decision-id>_B5EEE2B1-915C-44DC-BE43-C244DC066FD8</decision-id>
                    <decision-name>Should the driver be suspended?</decision-name>
                </dmn-decision-info>
            </decisions>
            <inputs>
                <dmn-inputdata-info>
                    <inputdata-id>_CEB959CD-3638-4A87-93BA-03CD0FB63AE3</inputdata-id>
                    <inputdata-name>Violation</inputdata-name>
                    <inputdata-typeref>
                        <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                        <local-part>tViolation</local-part>
                        <prefix></prefix>
                    </inputdata-typeref>
                </dmn-inputdata-info>
                <dmn-inputdata-info>
                    <inputdata-id>_B0E810E6-7596-430A-B5CF-67CE16863B6C</inputdata-id>
                    <inputdata-name>Driver</inputdata-name>
                    <inputdata-typeref>
                        <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                        <local-part>tDriver</local-part>
                        <prefix></prefix>
                    </inputdata-typeref>
                </dmn-inputdata-info>
            </inputs>
            <itemdefinitions>
                <dmn-itemdefinition-info>
                    <itemdefinition-id>_9C758F4A-7D72-4D0F-B63F-2F5B8405980E</itemdefinition-id>
                    <itemdefinition-name>tViolation</itemdefinition-name>
                    <itemdefinition-itemcomponent>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_0B6FF1E2-ACE9-4FB3-876B-5BB30B88009B</itemdefinition-id>
                            <itemdefinition-name>Code</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60b01f4d-e407-43f7-848e-258723b5fac8</namespace-uri>
                                <local-part>string</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_27A5DA18-3CA7-4C06-81B7-CF7F2F050E29</itemdefinition-id>
                            <itemdefinition-name>date</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>date</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_8961969A-8A80-4F12-B568-346920C0F038</itemdefinition-id>
                            <itemdefinition-name>type</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>string</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_7450F12A-3E95-4D5E-8DCE-2CB1FAC2BDD4</itemdefinition-id>
                            <itemdefinition-name>speed limit</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60b01f4d-e407-43f7-848e-258723b5fac8</namespace-uri>
                                <local-part>number</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_0A9A6F26-6C14-414D-A9BF-765E5850429A</itemdefinition-id>
                            <itemdefinition-name>Actual Speed</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>number</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                    </itemdefinition-itemcomponent>
                    <itemdefinition-iscollection>false</itemdefinition-iscollection>
                </dmn-itemdefinition-info>
                <dmn-itemdefinition-info>
                    <itemdefinition-id>_13C7EFD8-B85C-43BF-94D3-14FABE39A4A0</itemdefinition-id>
                    <itemdefinition-name>tDriver</itemdefinition-name>
                    <itemdefinition-itemcomponent>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_EC11744C-4160-4549-9610-2C757F40DFE8</itemdefinition-id>
                            <itemdefinition-name>Name</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>string</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_E95BE3DB-4A51-4658-A166-02493EAAC9D2</itemdefinition-id>
                            <itemdefinition-name>Age</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>number</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_7B3023E2-BC44-4BF3-BF7E-773C240FB9AD</itemdefinition-id>
                            <itemdefinition-name>State</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>string</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_3D4B49DD-700C-4925-99A7-3B2B873F7800</itemdefinition-id>
                            <itemdefinition-name>city</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>string</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_B37C49E8-B0D9-4B20-9DC6-D655BB1CA7B1</itemdefinition-id>
                            <itemdefinition-name>Points</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>number</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                    </itemdefinition-itemcomponent>
                    <itemdefinition-iscollection>false</itemdefinition-iscollection>
                </dmn-itemdefinition-info>
                <dmn-itemdefinition-info>
                    <itemdefinition-id>_A4077C7E-B57A-4DEE-9C65-7769636316F3</itemdefinition-id>
                    <itemdefinition-name>tFine</itemdefinition-name>
                    <itemdefinition-itemcomponent>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_79B152A8-DE83-4001-B88B-52DFF0D73B2D</itemdefinition-id>
                            <itemdefinition-name>Amount</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>number</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                        <dmn-itemdefinition-info>
                            <itemdefinition-id>_D7CB5F9C-9D55-48C2-83EE-D47045EC90D0</itemdefinition-id>
                            <itemdefinition-name>Points</itemdefinition-name>
                            <itemdefinition-typeref>
                                <namespace-uri>https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8</namespace-uri>
                                <local-part>number</local-part>
                                <prefix></prefix>
                            </itemdefinition-typeref>
                            <itemdefinition-itemcomponent/>
                            <itemdefinition-iscollection>false</itemdefinition-iscollection>
                        </dmn-itemdefinition-info>
                    </itemdefinition-itemcomponent>
                    <itemdefinition-iscollection>false</itemdefinition-iscollection>
                </dmn-itemdefinition-info>
            </itemdefinitions>
            <decisionservices/>
        </model>
    </dmn-model-info-list>
</response>
----

Sample JSON output:

[source,json]
----
{
  "type" : "SUCCESS",
  "msg" : "OK models successfully retrieved from container 'Traffic-Violation_1.0.0'",
  "result" : {
    "dmn-model-info-list" : {
      "models" : [ {
        "model-namespace" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
        "model-name" : "Traffic Violation",
        "model-id" : "_2CD7D1AA-BD84-4B43-AD21-B0342ADE655A",
        "decisions" : [ {
          "decision-id" : "_23428EE8-DC8B-4067-8E67-9D7C53EC975F",
          "decision-name" : "Fine"
        }, {
          "decision-id" : "_B5EEE2B1-915C-44DC-BE43-C244DC066FD8",
          "decision-name" : "Should the driver be suspended?"
        } ],
        "inputs" : [ {
          "inputdata-id" : "_CEB959CD-3638-4A87-93BA-03CD0FB63AE3",
          "inputdata-name" : "Violation",
          "inputdata-typeRef" : {
            "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
            "local-part" : "tViolation",
            "prefix" : ""
          }
        }, {
          "inputdata-id" : "_B0E810E6-7596-430A-B5CF-67CE16863B6C",
          "inputdata-name" : "Driver",
          "inputdata-typeRef" : {
            "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
            "local-part" : "tDriver",
            "prefix" : ""
          }
        } ],
        "itemDefinitions" : [ {
          "itemdefinition-id" : "_13C7EFD8-B85C-43BF-94D3-14FABE39A4A0",
          "itemdefinition-name" : "tDriver",
          "itemdefinition-typeRef" : null,
          "itemdefinition-itemComponent" : [ {
            "itemdefinition-id" : "_EC11744C-4160-4549-9610-2C757F40DFE8",
            "itemdefinition-name" : "Name",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "string",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_E95BE3DB-4A51-4658-A166-02493EAAC9D2",
            "itemdefinition-name" : "Age",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "number",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_7B3023E2-BC44-4BF3-BF7E-773C240FB9AD",
            "itemdefinition-name" : "State",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "string",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_3D4B49DD-700C-4925-99A7-3B2B873F7800",
            "itemdefinition-name" : "City",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "string",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_B37C49E8-B0D9-4B20-9DC6-D655BB1CA7B1",
            "itemdefinition-name" : "Points",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "number",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          } ],
          "itemdefinition-isCollection" : false
        }, {
          "itemdefinition-id" : "_A4077C7E-B57A-4DEE-9C65-7769636316F3",
          "itemdefinition-name" : "tFine",
          "itemdefinition-typeRef" : null,
          "itemdefinition-itemComponent" : [ {
            "itemdefinition-id" : "_79B152A8-DE83-4001-B88B-52DFF0D73B2D",
            "itemdefinition-name" : "Amount",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "number",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_D7CB5F9C-9D55-48C2-83EE-D47045EC90D0",
            "itemdefinition-name" : "Points",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "number",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          } ],
          "itemdefinition-isCollection" : false
        }, {
          "itemdefinition-id" : "_9C758F4A-7D72-4D0F-B63F-2F5B8405980E",
          "itemdefinition-name" : "tViolation",
          "itemdefinition-typeRef" : null,
          "itemdefinition-itemComponent" : [ {
            "itemdefinition-id" : "_0B6FF1E2-ACE9-4FB3-876B-5BB30B88009B",
            "itemdefinition-name" : "Code",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "string",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_27A5DA18-3CA7-4C06-81B7-CF7F2F050E29",
            "itemdefinition-name" : "Date",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "date",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_8961969A-8A80-4F12-B568-346920C0F038",
            "itemdefinition-name" : "Type",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "string",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_7450F12A-3E95-4D5E-8DCE-2CB1FAC2BDD4",
            "itemdefinition-name" : "Speed Limit",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "number",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          }, {
            "itemdefinition-id" : "_0A9A6F26-6C14-414D-A9BF-765E5850429A",
            "itemdefinition-name" : "Actual Speed",
            "itemdefinition-typeRef" : {
              "namespace-uri" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
              "local-part" : "number",
              "prefix" : ""
            },
            "itemdefinition-itemComponent" : [ ],
            "itemdefinition-isCollection" : false
          } ],
          "itemdefinition-isCollection" : false
        } ],
        "decisionServices" : [ ]
      } ]
    }
  }
}
----
--
endif::[]

. Execute the model:

ifeval::["{context}" == "kogito-dmn-models"]
+
--
*[POST]* `server/containers/{containerId}/dmn`

Example curl request:

[source]
----
curl -u krisv:krisv -H "accept: application/json" -H "content-type: application/json" -X POST "http://localhost:8080/kie-server/services/rest/server/containers/MovieDMNContainer/dmn" -d "{ \"model-namespace\" : \"http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a\", \"model-name\" : \"dmn-movieticket-ageclassification\", \"decision-name\" : [ ], \"decision-id\" : [ ], \"dmn-context\" : {\"Age\" : 66}}"
----

Example JSON request:

[source,json]
----
{
  "model-namespace" : "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a",
  "model-name" : "dmn-movieticket-ageclassification",
  "decision-name" : [ ],
  "decision-id" : [ ],
  "dmn-context" : {"Age" : 66}
}
----

Example XML request (JAXB format):

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<dmn-evaluation-context>
    <model-namespace>http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a</model-namespace>
    <model-name>dmn-movieticket-ageclassification</model-name>
    <dmn-context xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <type>MAP</type>
        <element xsi:type="jaxbStringObjectPair" key="Age">
            <value xsi:type="xs:int" xmlns:xs="http://www.w3.org/2001/XMLSchema">66</value>
        </element>
    </dmn-context>
</dmn-evaluation-context>
----

[NOTE]
====
Regardless of the request format, the request requires the following elements:

* Model namespace
* Model name
* Context object containing input values
====

Example JSON response:

[source,json]
----
{
  "type" : "SUCCESS",
  "msg" : "OK from container 'MovieDMNContainer'",
  "result" : {
    "dmn-evaluation-result" : {
      "messages" : [ ],
      "model-namespace" : "http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a",
      "model-name" : "dmn-movieticket-ageclassification",
      "decision-name" : [ ],
      "dmn-context" : {
        "Age" : 66,
        "AgeClassification" : "Senior"
      },
      "decision-results" : {
        "_3" : {
          "messages" : [ ],
          "decision-id" : "_3",
          "decision-name" : "AgeClassification",
          "result" : "Senior",
          "status" : "SUCCEEDED"
        }
      }
    }
  }
}
----

Example XML (JAXB format) response:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<response type="SUCCESS" msg="OK from container 'MovieDMNContainer'">
      <dmn-evaluation-result>
            <model-namespace>http://www.redhat.com/_c7328033-c355-43cd-b616-0aceef80e52a</model-namespace>
            <model-name>dmn-movieticket-ageclassification</model-name>
            <dmn-context xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                  <type>MAP</type>
                  <element xsi:type="jaxbStringObjectPair" key="Age">
                        <value xsi:type="xs:int" xmlns:xs="http://www.w3.org/2001/XMLSchema">66</value>
                  </element>
                  <element xsi:type="jaxbStringObjectPair" key="AgeClassification">
                        <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">Senior</value>
                  </element>
            </dmn-context>
            <messages/>
            <decisionResults>
                  <entry>
                        <key>_3</key>
                        <value>
                              <decision-id>_3</decision-id>
                              <decision-name>AgeClassification</decision-name>
                              <result xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Senior</result>
                              <messages/>
                              <status>SUCCEEDED</status>
                        </value>
                  </entry>
            </decisionResults>
      </dmn-evaluation-result>
</response>
----
--
endif::[]
ifeval::["{context}" == "decision-service-getting-started"]
+
--
*[POST]* `server/containers/{containerId}/dmn`

[NOTE]
====
The attribute `model-namespace` is automatically generated and is different for every user. Ensure that the `model-namespace` and `model-name` attributes that you use match those of the deployed model.
====

Example curl request:

[source]
----
curl -u wbadmin:wbadmin -H "accept: application/json" -H "content-type: application/json" -X POST "http://localhost:8080/kie-server/services/rest/server/containers/traffic-violation_1.0.0/dmn" -d "{ \"model-namespace\" : \"https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8\", \"model-name\" : \"Traffic Violation\", \"dmn-context\" : {\"Driver\" : {\"Points\" : 15}, \"Violation\" : {\"Type\" : \"speed\", \"Actual Speed\" : 135, \"Speed Limit\" : 100}}}"
----

Example JSON request:

[source,json]
----
{
  "model-namespace" : "https://github.com/kiegroup/drools/kie-dmn/_60B01F4D-E407-43F7-848E-258723B5FAC8",
  "model-name" : "Traffic Violation",
  "dmn-context" :
  {
    "Driver" :
    {
  	   "Points" : 15
    },
  	"Violation" :
    {
  		"Type" : "speed",
  		"Actual Speed" : 135,
  		"Speed Limit" : 100
  	}
  }
}
----

Example XML request (JAXB format):

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<dmn-evaluation-context>
    <dmn-context xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
        <type>MAP</type>
        <element xsi:type="jaxbStringObjectPair" key="Violation">
            <value xsi:type="jaxbListWrapper">
                <type>MAP</type>
                <element xsi:type="jaxbStringObjectPair" key="Type">
                    <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">speed</value>
                </element>
                <element xsi:type="jaxbStringObjectPair" key="Speed Limit">
                    <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">100</value>
                </element>
                <element xsi:type="jaxbStringObjectPair" key="Actual Speed">
                    <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">135</value>
                </element>
            </value>
        </element>
        <element xsi:type="jaxbStringObjectPair" key="Driver">
            <value xsi:type="jaxbListWrapper">
                <type>MAP</type>
                <element xsi:type="jaxbStringObjectPair" key="Points">
                    <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">15</value>
                </element>
            </value>
        </element>
    </dmn-context>
</dmn-evaluation-context>
----

[NOTE]
====
Regardless of the request format, the request requires the following elements:

* Model namespace
* Model name
* Context object containing input values
====

Example JSON response:

[source,json]
----
{
  "type": "SUCCESS",
  "msg": "OK from container 'Traffic-Violation_1.0.0'",
  "result": {
      "dmn-evaluation-result": {
          "messages": [],
          "model-namespace": "https://github.com/kiegroup/drools/kie-dmn/_7D8116DE-ADF5-4560-A116-FE1A2EAFFF48",
          "model-name": "Traffic Violation",
          "decision-name": [],
          "dmn-context": {
              "Violation": {
                "Type": "speed",
                "Speed Limit": 100,
                "Actual Speed": 135
              },
              "Should Driver be Suspended?": "YES",
                "Driver": {
                  "Points": 15
                },
                "Fine": {
                  "Points": 7,
                  "Amount": 1000
                }
            },
      "decision-results": {
          "_E1AF5AC2-E259-455C-96E4-596E30D3BC86": {
              "messages": [],
              "decision-id": "_E1AF5AC2-E259-455C-96E4-596E30D3BC86",
              "decision-name": "Should the Driver be Suspended?",
              "result": "YES",
              "status": "SUCCEEDED"
            },
          "_D7F02CE0-AF50-4505-AB80-C7D6DE257920": {
              "messages": [],
              "decision-id": "_D7F02CE0-AF50-4505-AB80-C7D6DE257920",
              "decision-name": "Fine",
              "result": {
                "Points": 7,
                "Amount": 1000
              },
          "status": "SUCCEEDED"
        }
      }
    }
  }
}
----

Example XML (JAXB format) response:

[source,xml]
----
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<response type="SUCCESS" msg="OK from container 'Traffic_1.0.0-SNAPSHOT'">
    <dmn-evaluation-result>
        <model-namespace>https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF</model-namespace>
        <model-name>Traffic Violation</model-name>
        <dmn-context xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
            <type>MAP</type>
            <element xsi:type="jaxbStringObjectPair" key="Violation">
                <value xsi:type="jaxbListWrapper">
                    <type>MAP</type>
                    <element xsi:type="jaxbStringObjectPair" key="Type">
                        <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">speed</value>
                    </element>
                    <element xsi:type="jaxbStringObjectPair" key="Speed Limit">
                        <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">100</value>
                    </element>
                    <element xsi:type="jaxbStringObjectPair" key="Actual Speed">
                        <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">135</value>
                    </element>
                </value>
            </element>
            <element xsi:type="jaxbStringObjectPair" key="Driver">
                <value xsi:type="jaxbListWrapper">
                    <type>MAP</type>
                    <element xsi:type="jaxbStringObjectPair" key="Points">
                        <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">15</value>
                    </element>
                </value>
            </element>
            <element xsi:type="jaxbStringObjectPair" key="Fine">
                <value xsi:type="jaxbListWrapper">
                    <type>MAP</type>
                    <element xsi:type="jaxbStringObjectPair" key="Points">
                        <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">7</value>
                    </element>
                    <element xsi:type="jaxbStringObjectPair" key="Amount">
                        <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">1000</value>
                    </element>
                </value>
            </element>
            <element xsi:type="jaxbStringObjectPair" key="Should the driver be suspended?">
                <value xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema">Yes</value>
            </element>
        </dmn-context>
        <messages/>
        <decisionResults>
            <entry>
                <key>_4055D956-1C47-479C-B3F4-BAEB61F1C929</key>
                <value>
                    <decision-id>_4055D956-1C47-479C-B3F4-BAEB61F1C929</decision-id>
                    <decision-name>Fine</decision-name>
                    <result xsi:type="jaxbListWrapper" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
                        <type>MAP</type>
                        <element xsi:type="jaxbStringObjectPair" key="Points">
                            <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">7</value>
                        </element>
                        <element xsi:type="jaxbStringObjectPair" key="Amount">
                            <value xsi:type="xs:decimal" xmlns:xs="http://www.w3.org/2001/XMLSchema">1000</value>
                        </element>
                    </result>
                    <messages/>
                    <status>SUCCEEDED</status>
                </value>
            </entry>
            <entry>
                <key>_8A408366-D8E9-4626-ABF3-5F69AA01F880</key>
                <value>
                    <decision-id>_8A408366-D8E9-4626-ABF3-5F69AA01F880</decision-id>
                    <decision-name>Should the driver be suspended?</decision-name>
                    <result xsi:type="xs:string" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">Yes</result>
                    <messages/>
                    <status>SUCCEEDED</status>
                </value>
            </entry>
        </decisionResults>
    </dmn-evaluation-result>
</response>
----
--
endif::[]
////

// tag::con-kogito-service-execution[]
[id="con-kogito-service-execution_{context}"]
== {PRODUCT} service execution

[role="_abstract"]
After you design your {PRODUCT} service, you can build and run your application and then send REST API requests to the application to execute your services. The exact REST API requests that you can use depend on how you set up the application.

For example, consider a {PRODUCT} service that is set up to generate a `/persons` REST API endpoint and determines whether a specified customer is an adult or is underage. In this example, you can send the following `POST` request using a REST client or curl utility to add an adult and execute the service:

.Example POST request body to add an adult (JSON)
[source,json]
----
{
  "person": {
    "name": "John Quark",
    "age": 20
  }
}
----

.Example curl command to add an adult
[source]
----
curl -X POST http://localhost:8080/persons -H 'content-type: application/json' -H 'accept: application/json' -d '{"person": {"name":"John Quark", "age": 20}}'
----

.Example response (JSON)
[source,json]
----
{
  "id": "3af806dd-8819-4734-a934-728f4c819682",
  "person": {
    "name": "John Quark",
    "age": 20,
    "adult": false
  },
  "isAdult": true
}
----

Note that for JSON marshaling, {PRODUCT} is relying on the default mappers of https://quarkus.io/guides/rest-json#jackson[Quarkus] and https://docs.spring.io/spring-boot/docs/1.3.0.M3/reference/html/howto-spring-mvc.html#howto-customize-the-jackson-objectmapper[SpringBoot], which can be configured according to the specific requirements.

For information about creating, running, and testing an example application with {PRODUCT} services, see {URL_CREATING_RUNNING}#chap-kogito-creating-running[_{CREATING_RUNNING}_].

For information about deploying your {PRODUCT} service to {OPENSHIFT}, see {URL_DEPLOYING_ON_OPENSHIFT}#chap-kogito-deploying-on-openshift[_{DEPLOYING_ON_OPENSHIFT}_].
// end::con-kogito-service-execution[]

[id="ref-rest-dmn-endpoints_{context}"]
=== REST endpoints for DMN models in {PRODUCT}

[role="_abstract"]
For each DMN model in a {PRODUCT} application, the following REST endpoints are automatically generated based on the content of the model:

* `[POST] /{modelName}`: A business-domain endpoint for evaluating the entire DMN model
* `[POST] /{modelName}/{decisionServiceName}`: A business-domain endpoint for evaluating a specified decision service component in the DMN model
* `[POST] /{modelName}/dmnresult`: An endpoint for evaluating the entire DMN model and returning a `DMNResult` response, including the business-domain context, helper messages, and helper decision pointers for the DMN model
* `[POST] /{modelName}/{decisionServiceName}/dmnresult`: An endpoint for evaluating a specified decision service component in the DMN model and returning a `DMNResult` response, including the business-domain context, helper messages, and helper decision pointers for the decision service
* `[GET] /{modelName}`: An endpoint for returning the DMN XML without decision logic, typically for DMN model introspection

You can use these endpoints to interact with a DMN model or a specific decision service within a model. As you decide between using business-domain and `dmnresult` variants of these REST endpoints, review the following considerations:

* *REST business-domain endpoints*: Use this endpoint type if a client application is only concerned with a positive evaluation outcome, is not interested in parsing `Info` or `Warn` messages, and only needs an HTTP 5xx response for any errors. This type of endpoint is also helpful for single-page application-like clients, due to singleton coercion of decision service results that resemble the DMN modeling behavior.
* *REST `dmnresult` endpoints*: Use this endpoint type if a client needs to parse `Info`, `Warn`, or `Error` messages in all cases.

For each endpoint, use a REST client, curl utility, or Swagger UI (if configured for the application) to send requests with the following components:

* *Base URL*: `http://__HOST__:__PORT__/{modelName}`
* *Path parameters*:
** `{modelName}`: The string identifier of the DMN model, such as `Traffic Violation`
** `{decisionServiceName}`: The string identifier of the decision service component in the DMN DRG, such as `TrafficViolationDecisionService`
** `dmnresult`: The string identifier that enables the endpoint to return a full `DMNResult` response with more detailed `Info`, `Warn`, and `Error` messaging
* *HTTP headers*: For `POST` requests only:
** `accept`: `application/json`
** `content-type`: `application/json`
* *HTTP methods*: `GET` or `POST`

The examples in the following endpoints are based on a `Traffic Violation` DMN model that contains a `TrafficViolationDecisionService` decision service component.

For all of these endpoints, if a DMN evaluation `Error` message occurs, a `DMNResult` response is returned along with an HTTP 5xx error. If a DMN `Info` or `Warn` message occurs, the relevant response is returned along with the business-domain REST body, in the `X-{PRODUCT}-decision-messages` extended HTTP header, to be used for client-side business logic. When more refined client-side business logic is required, the client can use the `dmnresult` variant of the endpoints.

Return the DMN XML without decision logic::
+
--
`[GET] /{modelName}`

.Example REST endpoint
`\http://localhost:8080/Traffic Violation`

.Example curl request
[source]
----
curl -X GET http://localhost:8080/Traffic Violation
----

.Example response (XML)
[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>
<dmn:definitions xmlns:dmn="http://www.omg.org/spec/DMN/20180521/MODEL/" xmlns="https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF" xmlns:di="http://www.omg.org/spec/DMN/20180521/DI/" xmlns:kie="http://www.drools.org/kie/dmn/1.2" xmlns:feel="http://www.omg.org/spec/DMN/20180521/FEEL/" xmlns:dmndi="http://www.omg.org/spec/DMN/20180521/DMNDI/" xmlns:dc="http://www.omg.org/spec/DMN/20180521/DC/" id="_1C792953-80DB-4B32-99EB-25FBE32BAF9E" name="Traffic Violation" expressionLanguage="http://www.omg.org/spec/DMN/20180521/FEEL/" typeLanguage="http://www.omg.org/spec/DMN/20180521/FEEL/" namespace="https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF">
  <dmn:itemDefinition id="_63824D3F-9173-446D-A940-6A7F0FA056BB" name="tDriver" isCollection="false">
    ...
  </dmn:itemDefinition>
  <dmn:itemDefinition id="_2D4F30EE-21A6-4A78-A524-A5C238D433AE" name="tFine" isCollection="false">
    ...
  </dmn:itemDefinition>
  <dmn:decision id="_4055D956-1C47-479C-B3F4-BAEB61F1C929" name="Fine">
    <dmn:variable id="_8C1EAC83-F251-4D94-8A9E-B03ACF6849CD" name="Fine" typeRef="tFine">
    </dmn:variable>
    <dmn:informationRequirement id="_800A3BBB-90A3-4D9D-BA5E-A311DED0134F">
      <dmn:requiredInput href="#_1929CBD5-40E0-442D-B909-49CEDE0101DC">
      </dmn:requiredInput>
    </dmn:informationRequirement>
  </dmn:decision>
  <dmn:decision id="_8A408366-D8E9-4626-ABF3-5F69AA01F880" name="Should the driver be suspended?">
    <dmn:question>Should the driver be suspended due to points on his license?</dmn:question>
    <dmn:allowedAnswers>"Yes", "No"</dmn:allowedAnswers>
    <dmn:variable id="_40387B66-5D00-48C8-BB90-E83EE3332C72" name="Should the driver be suspended?" typeRef="string">
    </dmn:variable>
    <dmn:informationRequirement id="_982211B1-5246-49CD-BE85-3211F71253CF">
      <dmn:requiredInput href="#_1F9350D7-146D-46F1-85D8-15B5B68AF22A">
      </dmn:requiredInput>
    </dmn:informationRequirement>
    <dmn:informationRequirement id="_AEC4AA5F-50C3-4FED-A0C2-261F90290731">
      <dmn:requiredDecision href="#_4055D956-1C47-479C-B3F4-BAEB61F1C929">
      </dmn:requiredDecision>
    </dmn:informationRequirement>
  </dmn:decision>
  <dmn:inputData id="_1929CBD5-40E0-442D-B909-49CEDE0101DC" name="Violation">
    <dmn:variable id="_C16CF9B1-5FAB-48A0-95E0-5FCD661E0406" name="Violation" typeRef="tViolation">
    </dmn:variable>
  </dmn:inputData>
  <dmn:inputData id="_1F9350D7-146D-46F1-85D8-15B5B68AF22A" name="Driver">
    <dmn:variable id="_A80F16DF-0DB4-43A2-B041-32900B1A3F3D" name="Driver" typeRef="tDriver">
    </dmn:variable>
  </dmn:inputData>
</dmn:definitions>
----
--

Evaluate a specified DMN model::
+
--
`[POST] /{modelName}`

For this endpoint, the request body must contain all input data of the DMN model. The response is the resulting DMN context of the model, including the decision values, the original input values, and all other parametric DRG components in serialized form. For example, a business knowledge model is available in string-serialized form in its signature.

.Example `Traffic Violation` DMN model
image::kogito/dmn/dmn-model-traffic-violation.png[Image of Traffic Violation DMN model]

.Example REST endpoint
`\http://localhost:8080/Traffic Violation`

.Example POST request body with input data
[source,json]
----
{
  "Driver": {
    "Points": 2
  },
  "Violation": {
    "Type": "speed",
    "Actual Speed": 120,
    "Speed Limit": 100
  }
}
----

.Example curl request
[source]
----
curl -X POST http://localhost:8080/Traffic Violation -H 'content-type: application/json' -H 'accept: application/json' -d '{"Driver": {"Points": 2}, "Violation": {"Type": "speed", "Actual Speed": 120, "Speed Limit": 100}}'
----

.Example response (JSON)
[source,json]
----
{
  "Violation": {
    "Type": "speed",
    "Speed Limit": 100,
    "Actual Speed": 120
  },
  "Driver": {
    "Points": 2
  },
  "Fine": {
    "Points": 3,
    "Amount": 500
  },
  "Should the driver be suspended?": "No"
}
----
--

Evaluate a specified decision service within a DMN model::
+
--
`[POST] /{modelName}/{decisionServiceName}`

For this endpoint, the request body must contain all the requirements of the decision service. The response is the resulting DMN context of the decision service, including the decision values, the original input values, and all other parametric DRG components in serialized form. For example, a business knowledge model is available in string-serialized form in its signature.

If the decision service is composed of a single-output decision, the response is the resulting value of that specific decision. This behavior provides an equivalent value at the API level of a specification feature when invoking the decision service in the model itself. As a result, you can, for example, interact with a DMN decision service from single-page web applications.

.Example `TrafficViolationDecisionService` decision service with single-output decision
image::kogito/dmn/dmn-model-traffic-violation-single-output.png[Image of decision service in Traffic Violation DMN model]

.Example `TrafficViolationDecisionService` decision service with multiple-output decision
image::kogito/dmn/dmn-model-traffic-violation-multi-output.png[Image of decision service in Traffic Violation DMN model]

.Example REST endpoint
`\http://localhost:8080/Traffic Violation/TrafficViolationDecisionService`

.Example POST request body with input data
[source,json]
----
{
  "Driver": {
    "Points": 2
  },
  "Violation": {
    "Type": "speed",
    "Actual Speed": 120,
    "Speed Limit": 100
  }
}
----

.Example curl request
[source]
----
curl -X POST http://localhost:8080/Traffic Violation/TrafficViolationDecisionService -H 'content-type: application/json' -H 'accept: application/json' -d '{"Driver": {"Points": 2}, "Violation": {"Type": "speed", "Actual Speed": 120, "Speed Limit": 100}}'
----

.Example response for single-output decision (JSON)
[source,json]
----
"No"
----

.Example response for multiple-output decision (JSON)
[source,json]
----
{
  "Violation": {
    "Type": "speed",
    "Speed Limit": 100,
    "Actual Speed": 120
  },
  "Driver": {
    "Points": 2
  },
  "Fine": {
    "Points": 3,
    "Amount": 500
  },
  "Should the driver be suspended?": "No"
}
----
--

Evaluate a specified DMN model and return a `DMNResult` response::
+
--
`[POST] /{modelName}/dmnresult`

.Example REST endpoint
`\http://localhost:8080/Traffic Violation`

.Example POST request body with input data
[source,json]
----
{
  "Driver": {
    "Points": 2
  },
  "Violation": {
    "Type": "speed",
    "Actual Speed": 120,
    "Speed Limit": 100
  }
}
----

.Example curl request
[source]
----
curl -X POST http://localhost:8080/Traffic Violation -H 'content-type: application/json' -H 'accept: application/json' -d '{"Driver": {"Points": 2}, "Violation": {"Type": "speed", "Actual Speed": 120, "Speed Limit": 100}}'
----

.Example response (JSON)
[source,json]
----
{
  "namespace": "https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF",
  "modelName": "Traffic Violation",
  "dmnContext": {
    "Violation": {
      "Type": "speed",
      "Speed Limit": 100,
      "Actual Speed": 120,
      "Code": null,
      "Date": null
    },
    "Driver": {
      "Points": 2,
      "State": null,
      "City": null,
      "Age": null,
      "Name": null
    },
    "Fine": {
      "Points": 3,
      "Amount": 500
    },
    "Should the driver be suspended?": "No"
  },
  "messages": [],
  "decisionResults": [
    {
      "decisionId": "_4055D956-1C47-479C-B3F4-BAEB61F1C929",
      "decisionName": "Fine",
      "result": {
        "Points": 3,
        "Amount": 500
      },
      "messages": [],
      "evaluationStatus": "SUCCEEDED"
    },
    {
      "decisionId": "_8A408366-D8E9-4626-ABF3-5F69AA01F880",
      "decisionName": "Should the driver be suspended?",
      "result": "No",
      "messages": [],
      "evaluationStatus": "SUCCEEDED"
    }
  ]
}
----
--

Evaluate a specified decision service within a DMN model and return a `DMNResult` response::
+
--
`[POST] /{modelName}/{decisionServiceName}/dmnresult`

.Example REST endpoint
`\http://localhost:8080/Traffic Violation/TrafficViolationDecisionService`

.Example POST request body with input data
[source,json]
----
{
  "Driver": {
    "Points": 2
  },
  "Violation": {
    "Type": "speed",
    "Actual Speed": 120,
    "Speed Limit": 100
  }
}
----

.Example curl request
[source]
----
curl -X POST http://localhost:8080/Traffic Violation/TrafficViolationDecisionService -H 'content-type: application/json' -H 'accept: application/json' -d '{"Driver": {"Points": 2}, "Violation": {"Type": "speed", "Actual Speed": 120, "Speed Limit": 100}}'
----

.Example response (JSON)
[source,json]
----
{
  "namespace": "https://github.com/kiegroup/drools/kie-dmn/_A4BCA8B8-CF08-433F-93B2-A2598F19ECFF",
  "modelName": "Traffic Violation",
  "dmnContext": {
    "Violation": {
      "Type": "speed",
      "Speed Limit": 100,
      "Actual Speed": 120,
      "Code": null,
      "Date": null
    },
    "Driver": {
      "Points": 2,
      "State": null,
      "City": null,
      "Age": null,
      "Name": null
    },
    "Should the driver be suspended?": "No"
  },
  "messages": [],
  "decisionResults": [
    {
      "decisionId": "_8A408366-D8E9-4626-ABF3-5F69AA01F880",
      "decisionName": "Should the driver be suspended?",
      "result": "No",
      "messages": [],
      "evaluationStatus": "SUCCEEDED"
    }
  ]
}
----
--

[id="con-audit-console_{context}"]
== {PRODUCT} Audit Investigation Console

[role="_abstract"]
The {PRODUCT} Audit Investigation Console is a user interface for monitoring and investigating Decision Model and Notation (DMN) model executions in {PRODUCT}.

.{PRODUCT} Audit Investigation Console
image::kogito/dmn/kogito-audit-console-home.png[Image of Kogito Audit Investigation Console]

You can use the Audit Investigation Console to browse DMN model executions, verify execution status, retrieve execution details, such as decision outcomes, input data, and model preview, and obtain explanation information about how the processed decisions were made.

The Audit Investigation Console requires your {PRODUCT} services to use the following {PRODUCT} components:

* *{PRODUCT} Trusty Service*: Enables the Audit Investigation Console to access stored events related to decision tracing from your {PRODUCT} services. The {PRODUCT} Trusty Service requires Infinispan persistence and Apache Kafka messaging for your {PRODUCT} service. For more information about the Trusty Service, see {URL_CONFIGURING_KOGITO}#con-trusty-service_kogito-configuring[_{CONFIGURING_KOGITO}_].
* *{PRODUCT} Explainability Service*: Generates explainability data that is stored in the {PRODUCT} Trusty Service. The Audit Investigation Console accesses the explainbility information from tracing-event data for decisions in your {PRODUCT} services. The {PRODUCT} Explainbility Service requires Apache Kafka messaging for your {PRODUCT} service.
* *{PRODUCT} Tracing decision add-on*: Enables the {PRODUCT} service to produce tracing events and publish the events to Apache Kafka. The add-on also exposes the REST endpoint `/predict` for the {PRODUCT} Explainbility Service.

[id="ref-audit-console-configurations_{context}"]
=== Supported configurations for the tracing add-on

[role="_abstract"]
The {PRODUCT} Audit Investigation Console requires the following project dependency for the tracing add-on:

.Project dependency to enable tracing capability on Quarkus
[source,xml]
----
<dependency>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-addons-quarkus-tracing-decision</artifactId>
</dependency>
----

.Project dependency to enable tracing capability on SpringBoot
[source,xml]
----
<dependency>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-addons-springboot-tracing-decision</artifactId>
</dependency>
----

The tracing add-on enables the Trusty Service to interact with the decision-tracing data through the CloudEvents messages. The default configuration for the add-on pushes the decision-tracing events to the `kogito-tracing-decision` Apache Kafka topic and pushes the DMN models used by the {PRODUCT} service to the `kogito-tracing-model` topic under the group ID `kogito-runtimes`.

To specify the Kafka bootstrap server for your {PRODUCT} service, set the following property in the `application.properties` file of your {PRODUCT} project:

.Application property for Kafka bootstrap server
[source,subs="+quotes"]
----
kafka.bootstrap.servers=http://__HOST__:__PORT__
----

NOTE: In a Kubernetes or OpenShift environment, if you specified the `KAFKA_BOOTSTRAP_SERVERS` environment variable in the relevant container, this application property in your {PRODUCT} project is not required.

On Quarkus, to customize the tracing add-on configurations, use the format `mp.messaging.outgoing.kogito-tracing-decision.__PROPERTY_NAME__` for the decisions, and the format `mp.messaging.outgoing.kogito-tracing-model.__PROPERTY_NAME__` for the DMN models.

For example, to change the topic name for the decision-tracing events, add the following line to the `application.properties` file:

.Example property to change the topic name for decision-tracing events
[source,subs="+quotes"]
----
mp.messaging.outgoing.kogito-tracing-decision.topic=my-kogito-tracing-decision
----

On SpringBoot, to customize the tracing add-on configurations, set the following properties in the `application.properties` file of your {PRODUCT} project as needed:

.Application properties for the tracing add-on on SpringBoot
[cols="30%,70%", options="header"]
|===
|Property
|Description

| `kogito.addon.tracing.decision.kafka.bootstrapAddress`
| Sets the address used in the initial connection to find a bootstrap server on the cluster of `n` brokers

Default value: None (must be set by user)

| `kogito.addon.tracing.decision.kafka.topic.name`
| Sets the topic name for the decision-tracing events

Default value: `kogito-tracing-decision`

| `kogito.addon.tracing.decision.kafka.topic.partitions`
| Sets the number of partitions to use for the decision-tracing events topic

Default value: `1`

| `kogito.addon.tracing.decision.kafka.topic.replicationFactor`
| Sets the factor of the data for the decision-tracing events topic

Default value: `1`

| `kogito.addon.tracing.decision.asyncEnabled`
| Enables asynchronous callback with the results of the send (success or failure) instead of waiting to complete

Default value: `true`

| `kogito.addon.tracing.model.kafka.topic.name`
| Sets the topic name for the DMN models used by the {PRODUCT} service

Default value: `kogito-tracing-model`
|===

[role="_additional-resources"]
.Additional resources
* https://quarkus.io/guides/kafka[Using Apache Kafka with Reactive Messaging] in Quarkus documentation
* https://kafka.apache.org/documentation/#producerconfigs[Producer Configs] in Apache Kafka documentation

[id="proc-audit-console-using_{context}"]
=== Using the {PRODUCT} Audit Investigation Console to view DMN model execution details

[role="_abstract"]
You can use the {PRODUCT} Audit Investigation Console to view DMN model execution details for your {PRODUCT} services. You can run the Audit Investigation Console for local {PRODUCT} services or add it to your {PRODUCT} infrastructure on {OPENSHIFT}.

.Prerequisites
* A {PRODUCT} Trusty Service instance and Explainbility Service instance are configured and running for your {PRODUCT} service. The Trusty Service enables the Audit Investigation Console to access stored DMN model execution data. The Trusty Service requires Infinispan persistence and Apache Kafka messaging for your {PRODUCT} service. For information about the Trusty Service, see {URL_CONFIGURING_KOGITO}#con-trusty-service_kogito-configuring[_{CONFIGURING_KOGITO}_].
* The `pom.xml` file of your {PRODUCT} project contains the following dependency for the tracing add-on:
+
--
.Project dependency to enable tracing capability on Quarkus
[source,xml]
----
<dependency>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-addons-quarkus-tracing-decision</artifactId>
</dependency>
----

.Project dependency to enable tracing capability SpringBoot
[source,xml]
----
<dependency>
  <groupId>org.kie.kogito</groupId>
  <artifactId>kogito-addons-springboot-tracing-decision</artifactId>
</dependency>
----
--
* The `application.properties` file of your {PRODUCT} project contains the following system properties:
+
--
.Application property for REST URLs
[source,subs="+quotes"]
----
kogito.service.url=http://__HOST__:__PORT__
----

NOTE: In a Kubernetes or OpenShift environment, if you specified the `KOGITO_SERVICE_URL` environment variable in the relevant container, this application property in your {PRODUCT} project is not required for the Explainability Service.

.Application property for Kafka bootstrap server
[source,subs="+quotes"]
----
kafka.bootstrap.servers=http://__HOST__:__PORT__
----

NOTE: In a Kubernetes or OpenShift environment, if you specified the `KAFKA_BOOTSTRAP_SERVERS` environment variable in the relevant container, this application property in your {PRODUCT} project is not required.

The service URL property defines the location where the {PRODUCT} service is deployed, such as `\http://localhost:8080`. This property enables the Explainability Service to generate the URLs to interact with {PRODUCT} and enrich tracing data with explainbility. The bootstrap property defines the Kafka bootstrap server for your {PRODUCT} service.
--

.Procedure
. Go to the https://repository.jboss.org/org/kie/kogito/trusty-ui/[`trusty-ui`] artifacts page, select the latest release of the {PRODUCT} Audit Investigation Console, and download the `trusty-ui-__VERSION__-runner.jar` file to a local directory.
. In a command terminal, navigate to the directory location of the downloaded `trusty-ui-__VERSION__-runner.jar` file and enter the following command to run the Audit Investigation Console:
+
--
.Running the Audit Investigation Console
[source,subs="+quotes"]
----
$ java -Dquarkus.http.port=9000 -Dkogito.trusty.http.url=http://__HOST__:__PORT__ -jar trusty-ui-__VERSION__-runner.jar
----

[NOTE]
====
The default port for the Audit Investigation Console is 8080, but this example specifies port 9000 to avoid conflicts with the example {PRODUCT} service running at port 8080.
====

In an OpenShift environment, you can use the {PRODUCT} command-line interface (CLI) or the OpenShift web console to add the Audit Investigation Console to your {PRODUCT} infrastructure.

In the `trusty-ui` CLI command, replace the Trusty Service host and port values with the host and port of your running Trusty Service instance. This command includes a `KOGITO_TRUSTY_ENDPOINT` environment variable that injects the specified Trusty Service endpoint into the Audit Investigation Console service container.

.Adding the Audit Investigation Console to your OpenShift infrastructure using the {PRODUCT} CLI
[source,subs="+quotes"]
----
$ kogito install trusty-ui --env KOGITO_TRUSTY_ENDPOINT=http://trusty:8080
----

.{PRODUCT} Audit Investigation Console instance on OpenShift web console
image::kogito/dmn/kogito-audit-console-instance.png[Image of Kogito Audit Investigation Console instance on OpenShift]

If you did not already install the required Trusty Service and Explainability Service, you can likewise use the OpenShift web console to add these instances under the *{PRODUCT} Supporting Service* tab and try again to add the Audit Investigation Console instance.

.{PRODUCT} Trusty Service and Explainability Service instances on OpenShift web console
image::kogito/dmn/kogito-trusty-explainability-instances.png[Image of Kogito Trusty Service and Explainability Service instances on OpenShift]
--

. In a web browser, navigate to `http://localhost:9000` to open the Audit Investigation Console. If you modified the configured Trusty UI port, use the modified location.
+
--
On OpenShift, navigate to the route URL for the Audit Investigation Console instance.

.{PRODUCT} Audit Investigation Console
image::kogito/dmn/kogito-audit-console-home.png[Image of Kogito Audit Investigation Console]

The Audit Investigation Console displays data for all available DMN model executions. By default, executions are filtered to display results from the last month. To modify the list view, you can use the search or sort fields at the top of the screen.
--
. In the DMN model executions list, select an execution ID to view and navigate through the details for the selected execution.
+
--
.Execution details page
image::kogito/dmn/kogito-audit-console-execution-detail.png[Image of execution details page]

At the top of the execution details page, you can hover your cursor over the execution status to view information about execution date, time, and executor.

.Execution status tooltip
image::kogito/dmn/kogito-audit-console-execution-status-tooltip.png[Image of Execution Status Tooltip, 303]
--
. In the execution details page, use the following tabs in the top menu to view different aspects of the DMN model execution:
+
--
* *Outcomes*: Use this page to view a list of the decision outcomes in the current execution. Each outcome is a card containing the output of the decision. You can click *View Details* for each card to open the *Outcome Details* section for that specific outcome.
* *Outcome Details*: Use this page to view information about decision outcomes of the execution.
+
.Outcome Details page
image::kogito/dmn/kogito-audit-console-outcomes-details.png[Image of Outcome Details page]
+
You can change which outcome to view by selecting from the drop-down options in the top menu.
+
.Outcomes selection
image::kogito/dmn/kogito-audit-console-outcomes-switch.png[Image of Outcomes selection]
+
The *Explanation* section provides insight about how the inputs of the model influenced the decision outcome. A score from `-1` to `1` is assigned to each input, representing its positive or negative effect on the decision result. Score values are rounded to the second decimal digit. If you hover your cursor over the graph bars, you can also see the full score value. Next to the *Features Score Chart* panel, the *Features Weight* panel contains the same scores in a tabular view, grouped by positive and negative weight.
+
The *Outcome Influencing Inputs* section provides a list of the inputs that were considered during the elaboration of the current decision outcome. The inputs typically consist of a sub-set of the inputs provided to the DMN model, or may consist of all provided inputs. For complex input structures, you can select from the *Browse Sections* options to view different input sections.
* *Input Data*: Use this page to view all inputs submitted to the DMN model for the current execution, including all inputs that were not incorporated in the outcomes processing. For complex input structures, you can select from the *Browse Sections* options to view different input sections.
+
.Input Data page
image::kogito/dmn/kogito-audit-console-input-data.png[Image of Input Data page]
* *Model Lookup*: Use this page to view the decision requirements diagram (DRD) of the executed DMN model.
+
.Model Lookup page
image::kogito/dmn/kogito-audit-console-model-lookup.png[Image of Model Lookup page]
+
[NOTE]
====
The *Model Lookup* viewer currently does not support DMN models that include other DMN models or PMML models.
====
--

For example {PRODUCT} services that use the Trusty Service and Explainability Service, see the following example applications in GitHub:

* https://github.com/kiegroup/kogito-examples/tree/stable/dmn-tracing-quarkus[`dmn-tracing-quarkus`]: A DMN decision service on Quarkus that uses the `kogito-addons-quarkus-tracing-decision` add-on to generate tracing events that the {PRODUCT} Trusty Service and Explainability Service can consume and expose.
* https://github.com/kiegroup/kogito-examples/tree/stable/trusty-demonstration[`trusty-demonstration`]: A tutorial for deploying the `dmn-tracing-quarkus` example application on Kubernetes as a demonstration of {PRODUCT} Trusty Service and Explainability Service capabilities in a cloud environment.

ifdef::KOGITO-ENT[]
[role="_additional-resources"]
== Additional resources
* {URL_CREATING_RUNNING}[_{CREATING_RUNNING}_]
* {URL_DEPLOYING_ON_OPENSHIFT}[_{DEPLOYING_ON_OPENSHIFT}_]
* {URL_PROCESS_SERVICES}[_{PROCESS_SERVICES}_]
* {URL_CONFIGURING_KOGITO}[_{CONFIGURING_KOGITO}_]
endif::[]

ifdef::parent-context[:context: {parent-context}]
ifndef::parent-context[:!context:]


[id="proc-audit-console-security_{context}"]
=== Enabling {PRODUCT} Audit Console security with OpenID Connect

[role="_abstract"]
For Quarkus-based {PRODUCT} services, you can use the https://quarkus.io/guides/security-openid-connect[Quarkus OpenID Connect adapter] with the {PRODUCT} Audit Console to enable the console to interact with the {PRODUCT} Trusty Service using bearer token authorization. These tokens are issued by OpenID Connect and OAuth 2.0 compliant authorization servers such as https://www.keycloak.org/about.html[Keycloak].

IMPORTANT: This procedure applies only when you are using a locally cloned copy of the https://github.com/kiegroup/kogito-apps/tree/master/trusty-ui[{PRODUCT} Audit Console] repository in GitHub.

.Prerequisites
* You have cloned the https://github.com/kiegroup/kogito-apps/tree/master/trusty-ui[{PRODUCT} Audit Console] repository from GitHub.

.Procedure
. In a command terminal, navigate to the local clone of the {PRODUCT} Audit Console repository and enter the following command to run the application with security enabled:
+
.Run the Audit Console with security enabled
[source]
----
mvn clean compile quarkus:dev -Dquarkus.profile=keycloak
----
+
IMPORTANT: Ensure that the service is not started at the same port as the security server. You can change the port by adding `-Dquarkus.http.port=__PORT_NUMBER__` to the start-up properties.

+
The {PRODUCT} Audit Console contains a Quarkus profile to encapsulate the security configuration, so if the service requires security, you can specify the `quarkus.profile=keycloak` property at build time to enable the needed security. If the `keycloak` Quarkus profile is not added, the OpenID Connect extension is disabled.

. Navigate to the `src/main/resources/application.properties` file of the Audit Console project and add the following properties:
+
.Required security properties in `applications.properties` file
[source]
----
# OpenID Connect configurations
%keycloak.quarkus.oidc.enabled=true
%keycloak.quarkus.oidc.tenant-enabled=true
%keycloak.quarkus.oidc.auth-server-url=http://localhost:8280/auth/realms/kogito
%keycloak.quarkus.oidc.client-id=kogito-console-quarkus
%keycloak.quarkus.oidc.credentials.secret=secret
%keycloak.quarkus.oidc.application-type=web-app
%keycloak.quarkus.oidc.logout.path=/logout
%keycloak.quarkus.oidc.logout.post-logout-path=/

# HTTP security configurations
%keycloak.quarkus.http.auth.permission.authenticated.paths=/*
%keycloak.quarkus.http.auth.permission.authenticated.policy=authenticated
----
+
NOTE: The `quarkus.oidc.enabled` property enables or disables security at build time, while the `quarkus.oidc.tenant-enabled` property enables or disables security at runtime.

. Replace any property definitions with those of your specific environment, especially the following properties:
+
* `quarkus.oidc.auth-server-url`: The base URL of the OpenID Connect (OIDC) server, such as `https://localhost:8280/auth`. All other OIDC server page and service URLs are derived from this URL. If you work with Keycloak OIDC server, ensure that the base URL is in the following format: `https://__HOST__:__PORT__/auth/realms/__KEYCLOAK_REALM__`.
* `quarkus.oidc.client-id`: The client ID of the application. Each application has a client ID that is used to identify the application.
* `quarkus.oidc.credentials.secret`: The client secret for the application.

. In the same `application.properties` file, also configure the resources to be exposed and the required permissions for accessing the resources.
+
NOTE: If you are enabling security at runtime using the `quarkus.oidc.tenant-enabled` property, the `quarkus.http.auth.permission` path and policy must specify how authentication is applied. By default, if security is enabled, the user must be authenticated to access any path.

. Stop and restart the {PRODUCT} Audit Console to ensure that the security changes are applied.

[role="_additional-resources"]
.Additional resources
* https://quarkus.io/guides/security[Security Architecture and Guides]
* https://quarkus.io/guides/security-openid-connect#configuring-using-the-application-properties-file[Configuring using the application.properties file]
* https://quarkus.io/guides/security-openid-connect-multitenancy[Using OpenID Connect multi-tenancy]
