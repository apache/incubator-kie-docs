[id='proc-knative-eventing-process-services_{context}']
= Enabling Knative Eventing for {PRODUCT} services

You can enable https://knative.dev/docs/eventing/[Knative Eventing] support for {PRODUCT} services that consume or publish messages within a Business Process Model and Notation (BPMN) process model. When you enable Knative Eventing for a {PRODUCT} project, event consumers and producers are generated from message start and end nodes in BPMN processes at build time. You can use these event consumers and producers as part of your {PRODUCT} service deployment in a Knative Eventing environment on Kubernetes or OpenShift clusters.

NOTE: Knative Eventing is currently supported for {PRODUCT} services on Quarkus only.

.Prerequisites
* You have installed and deployed Knative Eventing on a Kubernetes or an OpenShift cluster. For information about Knative Eventing on OpenShift, see https://docs.openshift.com/container-platform/4.5/serverless/installing_serverless/installing-knative-eventing.html[Installing Knative Eventing] in the OpenShift documentation.
* You have created a BPMN model in your {PRODUCT} project with message start or end events that you want to integrate with Knative Eventing. For information about creating BPMN models, see xref:proc-bpmn-model-creating_kogito-developing-process-services[].

.Procedure
. Add the following properties and dependencies to the `pom.xml` file of your {PRODUCT} project:
+
--
[source,xml,subs="attributes+,+quotes"]
----
<properties>
    <version.cloudevents>2.0.0-milestone1</version.cloudevents>
    <kogito.version>{PRODUCT_VERSION_LONG}</kogito.version>
</properties>

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.kie.kogito</groupId>
            <artifactId>kogito-quarkus-bom</artifactId>
            <version>${kogito.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
        <dependency>
            <groupId>io.cloudevents</groupId>
            <artifactId>cloudevents-api</artifactId>
            <version>${version.cloudevents}</version>
        </dependency>
        <dependency>
            <groupId>org.kie.kogito</groupId>
            <artifactId>knative-eventing-addon</artifactId>
        </dependency>
        <dependency>
            <groupId>io.quarkus</groupId>
            <artifactId>quarkus-smallrye-reactive-messaging</artifactId>
        </dependency>
        <dependency>
            <groupId>io.smallrye.reactive</groupId>
            <artifactId>smallrye-reactive-messaging-http</artifactId>
        </dependency>
    </dependencies>
</dependencyManagement>
----

These properties ensure that your project contains all required {PRODUCT}, Quarkus, and CloudEvents dependencies, and enable Knative Eventing add-on and messaging requirements. When a {PRODUCT} service has the Knative Eventing add-on enabled, {PRODUCT} generates code based on http://www.smallrye.io/smallrye-reactive-messaging/[Smallrye Reactive Messaging] to publish messages.
--
. In your {PRODUCT} project, open the BPMN file that you want to use for consuming or producing messages in the Knative Eventing environment. BPMN files are typically in `src/main/resources`.
+
--
For example, the following `handle-travelers.bpmn2` process uses messaging start and end events to communicate with travelers:

.Example process with messaging start and end events
image::kogito/bpmn/bpmn-messaging-example.png[Image of BPMN process receiving and publishing messages]

The names of message start and end events serve as CloudEvents https://github.com/cloudevents/spec/blob/v1.0/spec.md#type[`type` attribute] definitions in Knative Eventing and must be unique.
--
. For each message event in the BPMN process model, select the node, click *Properties* in the upper-right corner of the modeler, and verify that the node name is clear and unique.
+
--
For example, consider adding the project or process name as a prefix to the message node name, such as `travelagency.travelers` in the following example:

.Set a unique message node name
image::kogito/bpmn/kogito-knative-set-node-name.png[Image of a message node property name]
--
. After you verify and save the message node names, navigate to the `src/main/resources/application.properties` file in your {PRODUCT} project and add the following properties for every message node that publishes messages:
+
--
.Required application properties for every publishing message node
[source,subs="attributes+,+quotes"]
----
mp.messaging.outgoing.__MESSAGE_NODE_NAME__.connector=smallrye-http
mp.messaging.outgoing.__MESSAGE_NODE_NAME__.url=${K_SINK}
----

Replace `__MESSAGE_NODE_NAME__` with the name of the message node that publishes messages, typically a message end event. Every message node that publishes messages must have these properties set. Incoming (subscribed) message nodes do not require any configuration.

The `smallrye-http` property defines the HTTP endpoint for the published messages. The `${K_SINK}` property is an environment variable injected by Knative Eventing when you deploy a {PRODUCT} service that references a Knative Eventing https://knative.dev/docs/eventing/samples/sinkbinding/[`SinkBinding`] object.
--
. Build your {PRODUCT} project locally using your usual method, such as `mvn clean package`, and navigate to the `target/generated-sources/kogito` directory in your project and verify the following contents:
+
* Generated classes with the suffixes `MessageConsumer` and `MessageProducer`. These classes are generated based on the message start and end events in your BPMN model.
* Generated `app` folder containing a `CloudEventListenerResource.java` file. This file detects any CloudEvents messages produced by the Knative Eventing source that targets your {PRODUCT} service.

+
If any of these items are missing, ensure that you have configured all required dependencies, applications properties, and message event name. After all checks are complete, rebuild the project.
. After you configure and test your {PRODUCT} project locally, in your Kubernetes or OpenShift environment, add the following custom resources for consuming and producing events in Knative Eventing:

* To consume events, create a Knative Eventing https://knative.dev/docs/eventing/triggers/[`Trigger`] resource as shown in the following example:
+
.Custom resource for Knative Eventing Trigger (consuming)
[source,yaml]
----
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: travelers-trigger
spec:
  # The default Broker is enabled in the cluster because the namespace is labeled with `knative-eventing-injection=enabled`.
  broker: default
  filter:
    attributes:
      # Name of the message node in the process.
      type: travelers
  # The subscriber is the deployed service. Any event that matches the filter in the Broker is sent here.
  subscriber:
    ref:
      apiVersion: v1
      kind: Service
      name: process-knative-quickstart-quarkus
----
+
This Knative Eventing Trigger resource filters all messages delivered to the default Broker and sends them to the default service deployed by the {PRODUCT} Operator.

* To produce events for the Knative Eventing https://knative.dev/docs/eventing/broker/[Broker], create a https://knative.dev/docs/eventing/samples/sinkbinding/[`SinkBinding`] resource as shown in the following example:
+
.Custom resource for Knative Eventing `SinkBinding` (producing)
[source,yaml]
----
apiVersion: sources.knative.dev/v1alpha1
kind: SinkBinding
metadata:
  name: process-knative-quickstart-quarkus-sink
spec:
  subject:
    apiVersion: apps/v1
    kind: Deployment
    selector:
      matchLabels:
        app: process-knative-quickstart-quarkus
  # Any cloud event produced by the application is delivered to the Broker.
  sink:
    ref:
      apiVersion: eventing.knative.dev/v1
      kind: Broker
      name: default
----
+
This Knative Eventing `SinkBinding` resource injects the `${K_SINK}` environment variable to the `Deployment` resource created by the {PRODUCT} Operator. Every message produced by the {PRODUCT} service is redirected to the default Knative Broker.
+
If any other components need to consume the messages produced by the {PRODUCT} service, you must create an additional Knative Eventing `Trigger` resource as shown in the following example:
+
.Custom resource for other consuming components
[source,yaml]
----
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: event-display-trigger
spec:
  # The default Broker is enabled in the namespace.
  broker: default
  filter:
    # Listens only to events of type `success` emitted by the CloudEvents-processing service.
    attributes:
      # The same type being generated by the custom service.
      type: /process/travelers/processedtravellers
      # The subscriber is the deployed displayer service. Any event that matches the filter in the Broker is sent here.
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: event-display
----
+
The `spec.filter.attributes.type` value defined in the `Trigger` resource is the same as the value generated by the {PRODUCT} service.

For an example {PRODUCT} service with Knative Eventing enabled, see the https://github.com/kiegroup/kogito-examples/tree/stable/process-knative-quickstart-quarkus[`process-knative-quickstart-quarkus`] example application.

.Additional resources
ifdef::KOGITO[]
* {URL_DEPLOYING_ON_OPENSHIFT}[_{DEPLOYING_ON_OPENSHIFT}_]
endif::[]
ifdef::KOGITO-COMM[]
* xref:chap-kogito-deploying-on-openshift[]
* xref:proc-kogito-deploying-on-kubernetes_kogito-deploying-on-openshift[]
endif::[]
