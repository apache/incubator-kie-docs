[id="con_process-decisions-integration_{context}"]
== Processes and Decisions integration in {PRODUCT}
include::ref-process-decisions-integration.adoc[tags=con_process-decisions-integration]

[role="_abstract"]

When designing a process it could be useful or needed in some situation to have a decision evaluation that can be
used in to guide the process flow upon the result of this decision. In {PRODUCT} decisions can be declared as distinct services using DMN or DRL [*insert reference*].
There are different ways to do the integration from the process with decisions, the *embedded* and the *remote* approach,
and depending on the use case it would be worth using one or another, or even mixing the methods in the same process.

=== Embedded

The embedded integration approach basically makes usage of the `Business Rule Task` [*insert reference*] available in
{PRODUCT}, which uses the local process and decision engines communication that are running in the same application,
this does not require any remote call, but requires the decision services to be deployed in the same applications as
the process calling them.

To show it in more details there is available an example on [*insert link*].

//text from the example
This example shows the usage of decisions within processes. Decisions can be expressed in different domains or assets, such as DMN and DRL.
The focus here is to show how to integrate decisions in an embedded way using Business Rule Task where they must be
deployed together with the process, in the same application. All assets(bpmn, dmn, drl) must be under the `resources`
folder.

This example covers the following items:

* DMN to define a decision service
* DRL to define rules decision service
* How to integrate the process with decisions using Business Rule Task

[id="con_process-decisions-integration-traffic-process-{context}"]
==== The Traffic Process example

It is based on the traffic violation evaluation process, where it is required to fetch Driver information, and based on this, it is first performed the license validation to check if the driver has a valid license (using a RuleUnit in a DRL) after the license validation it is then executed the violation evaluation defined as a DMN decision and following, it is checked in the process if the output contains information whether the driver was suspended or not, completing the process.

===== Process using Business Rule Task

.Traffic Process
image::kogito/bpmn/decisions/traffic-rules-dmn.png[Image of Traffic Process in process designer]

This is a declarative approach, it does not require to have any extra implementation, the interaction with decisions is executed out-of-the-box by the engine. The information needed to execute the decision evaluation should be set in the Data Assignments in the Business Rule Task.

===== Process Properties

.Traffic Process Properties
image::kogito/bpmn/decisions/process-properties-embedded.png[Image of Traffic Process Properties in process designer]

These are the properties defined for the process, the most important one in this section to pay attention is the ID because it is used in the REST endpoint generation referring to the path to interact with this process.

===== Process Variables

The variables used in the process itself, but the focus in this example are the classes that are used to define the POJOs to interact the process with decisions, that are the `Violation`, `Driver`, `Fine`.

.Traffic Process Variables
image::kogito/bpmn/decisions/process-variables-embedded.png[Image of Traffic Process Variables in process designer]

[id="con_process-decisions-data-mapping-{context}"]
==== Mapping data from Process to/from DMN

It is important to mention DMN for instance can define the Data Type in its structure, but we can align all
attributes names in a Java class that is used as process variables, in case the attribute names contain spaces or are
not following java conventions we can use https://github.com/FasterXML/jackson[Jackson] annotations to make the process
variable POJOs aligned with DMN data types, for instance in the `Violation` ( class, where it is mapped the `speedLimit` attribute as `Speed Limit` using `@JsonProperty` annotation, in this case, this attribute from the process variable with Violation can be seamlessly integrated Violation Data Type defined in DMN.

.Violation class defined in the Traffic Process
[source,java]
----
public class Violation {

    @JsonProperty("Code")
    private String code;

    @JsonProperty("Date")
    private Date date;

    @JsonProperty("Type")
    private String type;

    @JsonProperty("Speed Limit")
    private BigDecimal speedLimit;

    @JsonProperty("Actual Speed")
    private BigDecimal actualSpeed;

    //Getters / Setters
}
----

**Violation Data Type in DMN**

.Violation Data Type in DMN
image::kogito/bpmn/decisions/violation-dmn-data-types.png[Image of Violation Data Type in DMN in DMN designer]

===== Get Driver Task

Fetch for driver information, in this implementation it is just mocking a result, that simply fill with an expired license date in case the `driverId` is an odd number and with a valid date in case of an even number. In a real use case, it could be performing an external call to a service or a database to get this information.

The service task implementation is done in the `DriverService` class.

In the data assignment the input is the `driverId` and output is the `driver` variable, filled with all driver information.

===== License Validation Task (DRL)

Represents the task to do the call to the DRL service.

.License Validation Task
image::kogito/bpmn/decisions/license-validation-drl-businessrule.png[Image of License Validation Task in process designer]

The properties to be set are mainly the `Rule Language` that should be set as `DRL` and the `Rule Flow Group` with
`unit:` + `[the FQCN of the Rule Unit Data class]`, in this case `org.kie.kogito.traffic.LicenseValidationService`.

.License Validation Task properties
image::kogito/bpmn/decisions/license-validation-dmn-businessrule-properties.png[Image of License Validation Task properties in process designer]

The input and output mapping for this task is just the driver variable that is filled with license validation information.

.License Validation Task Data Assignments
image::kogito/bpmn/decisions/license-validation-dmn-businessrule-data.png[Image of License Validation Task data assingment in process designer]


===== Traffic Violation Task (DMN)
Similar to the License Validation Task, but it represents the task to do the call to the DMN service.

.Traffic Violation Task (DMN)
image::kogito/bpmn/decisions/traffic-violation-dmn-businessrule.png[raffic Violation Task data in process designer]

The properties to be set are mainly the `Rule Language`that should be set as `DMN` and the `Namespace`, `Decision Name` and `DMN Model Name` must be set with the values defined in in the DMN, in this case `TrafficViolation.dmn`.

.Traffic Violation Task properties
image::kogito/bpmn/decisions/traffic-violation-dmn-businessrule-properties.png[Traffic Violation Task properties in process designer]

The input for this task is the `Driver` and `Violation` variables, and the outputs are the `Suspended` and `Fine`.

.Traffic Violation Task data assignment
image::kogito/bpmn/decisions/traffic-violation-dmn-businessrule-data.png[Traffic Violation Task data assignment in process designer]


===== Suspended Task
Just an example task where it could be performed any action based on the condition in which the driver is suspended. In the current implementation, it is just logging the information in the console.


===== Not Suspended Task
Just an example task where it could be performed any action based on the condition in which the driver is **not** suspended. In the current implementation, it is just logging the information in the console.

[id="con_process-decisions-decisions-{context}"]
==== Decisions

===== License Validation - Rule Unit

This decision consistis in rules which are evaluated to check if a driver's license is expired or not according to the expiration date and thus populating the result in the information in the driver variable.

The DRL file where this Rule Unit is declared is `LicenseValidationService.drl` and the the Java class that contains the Rule Unit Data is `LicenseValidationService`.

.License Validation DRL
[source,java]
----
unit LicenseValidationService

rule "Is driver license valid"
when
    $driver: /driver[licenseExpiration.after(currentTime)]
then
    $driver.setValidLicense(true);
end

rule "Is driver license expired"
when
    $driver: /driver[licenseExpiration.before(currentTime)]
then
    $driver.setValidLicense(false);
end

query "validation"
  $driver : /driver
end
----

.LicenseValidation class
[source,java]
----
public class LicenseValidationService implements RuleUnitData {
    private SingletonStore<Driver> driver;

    public LicenseValidationService() {
        this(DataSource.createSingleton());
    }

    public LicenseValidationService(SingletonStore<Driver> driver) {
        this.driver = driver;
    }

    public void setDriver(SingletonStore<Driver> driver) {
        this.driver = driver;
    }

    public SingletonStore<Driver> getDriver() {
        return driver;
    }

    public Date getCurrentTime() {
        return new Date();
    }
}
----

===== Traffic Violation - DMN

This decision consists in a DMN that basically checks if a driver is suspended or not according to the violation and current driver points in its license.

.Traffic Violation - DMN
image::kogito/bpmn/decisions/traffic-violation-dmn.png[Image of Traffic Violation - DMN in DMN designer]

The DMN file where this decision is declared is `TrafficViolation.dmn`.

=== Remote

The remote integration approach uses REST APIs from the decision services basically can make use of any BPMN feature to send HTTP requests like Custom service tasks and the REST Work Item [*insert reference*] available in {PRODUCT}. In this approach the process communicates to the decision services through the network, in this way it is not necessary they are running in the same application.

To show it in more details there is available an example on [*insert link*].

This is an example that shows the usage of decisions within processes. Decisions can be expressed in different domains or assets, such as DMN and DRL.
The focus here is to show how to integrate decisions in a remote way using REST APIs where they can be deployed decoupled from the process service, for instance, in different microservices with its build and deployment pipelines. For convenience, in this example,  the decision assets are under the same project as the process that generates different endpoints for the process and decisions but under the same application, but in a real use case they could be placed in a different applications.

This example covers the following items:

* DMN to define a decision service
* DRL to define rules decision service
* How to integrate the process with decisions using REST
* Service Task to call an external decision service
* REST Work Item to call an external decision service

==== The Traffic Process example:

The process example is the very similar to the example described in <<con_process-decisions-integration-traffic-process-{context}>> but using different tasks to perform the calls to the decision services, that are done through REST.

It is based on the traffic violation evaluation process, where it is required to fetch Driver information, and based on this, it is first performed the license validation to check if the driver has a valid license (using a RuleUnit in a DRL) after the license validation it is then executed the violation evaluation defined as a DMN decision and following, it is checked in the process if the output contains information whether the driver was suspended or not, completing the process.

NOTE: There are two examples to show different approaches to do integration with decisions, they are pretty similar from the process definition perspective, the difference is related to the task that performs the call to the decision evaluation, either using a Service Task or a REST Work item.

===== Process using Service Tasks

.Traffic Process with service tasks for REST
image::kogito/bpmn/decisions/traffic-rules-dmn-service-task.png[Image of Traffic Process with service tasks for REST in process designer]

In this approach it requires coding, to provide an implementation in the application responsible to execute the task, in this case, a REST/HTTP call. The implementation is up to the user, but here it's been used what the platform provides, like the [Quarkus REST Client](https://quarkus.io/guides/rest-client). Details can be seen in the classes `LicenseValidationRestClient` and `TrafficViolationRestClient`.

.LicenseValidationRestClient class
[source,java]
----
@Path("/validation/first")
@RegisterRestClient
public interface LicenseValidationRestClient {

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    Driver post(Map<String, Object> parameters);

}
----

.TrafficViolationRestClient class
[source,java]
----
@Path("/Traffic%20Violation")
@RegisterRestClient
public interface TrafficViolationRestClient {

    @POST
    @Produces(MediaType.APPLICATION_JSON)
    @Consumes(MediaType.APPLICATION_JSON)
    TrafficViolationResponse post(Map<String, Object> parameters);

}
----

The BPMN file where this process is declared is `traffic-rules-dmn-service-task.bpmn`.

===== Process using REST Work Item

.Process using REST Work Item
image::kogito/bpmn/decisions/traffic-rules-dmn-wih.png[Image of Traffic Process with service tasks for REST in process designer]

This is a declarative approach, it does not require to have any extra implementation, the REST/HTTP call is executed out-of-the-box by the engine. The information needed to execute the REST call, like the URL and HTTP method should be set in the Data Assignments in the REST Work Item.

The BPMN file where this process is declared is `traffic-rules-dmn-wih.bpmn`.

===== Process Properties

.Process Properties
image::kogito/bpmn/decisions/process-properties.png[Image of Traffic Process properties in process designer]

These are the properties defined for the process, the most important one in this section to pay attention is the ID because it is used in the REST endpoint generation referring to the path to interact with this process.

===== Process Variables

The variables used in the process itself, but the focus in this example are the classes that are used to define the POJOs to interact the process with decisions, that are the `Violation`, `Driver`, `Fine` and `TrafficViolationResponse`.

.Process Properties
image::kogito/bpmn/decisions/process-variables.png[Image of Traffic Process with service tasks for REST in process designer]


===== Mapping data from Process to/from DMN

The way to map data from process to decision for REST is the same as described in <<con_process-decisions-data-mapping-{context}>> that is based in Json translation.

It is important to mention DMN for instance can define the Data Type in its structure, but we can align all
attributes names in a Java class that is used as process variables, in case the attribute names contain spaces or are
not following java conventions we can use https://github.com/FasterXML/jackson[Jackson] annotations to make the process
variable POJOs aligned with DMN data types, for instance in the `Violation` ( class, where it is mapped the `speedLimit` attribute as `Speed Limit` using `@JsonProperty` annotation, in this case, this attribute from the process variable with Violation can be seamlessly integrated Violation Data Type defined in DMN.

.Violation class defined in the Traffic Process
[source,java]
----
public class Violation {

    @JsonProperty("Code")
    private String code;

    @JsonProperty("Date")
    private Date date;

    @JsonProperty("Type")
    private String type;

    @JsonProperty("Speed Limit")
    private BigDecimal speedLimit;

    @JsonProperty("Actual Speed")
    private BigDecimal actualSpeed;

    //Getters / Setters
}
----

===== Get Driver Task

Fetch for driver information, in this implementation it is just mocking a result, that simply fill with an expired license date in case the `driverId` is an odd number and with a valid date in case of an even number. In a real use case, it could be performing an external call to a service or a database to get this information.

The service task implementation is done in the `DriverService` class.

In the data assignment the input is the `driverId` and output is the `driver` variable, filled with all driver information.

===== License Validation Task (DRL)

Represents the task to do the call to the DRL service.

====== **Service Task**

.License Validation Service Task
image::kogito/bpmn/decisions/license-validation-drl-service-task.png[Image of License Validation Service Task in process designer]

The implementation properties where it is necessary to set the Java class implementing the task that executes the call should be set alongside the method. The URL configuration is done in the `application.properties`.

.License Validation Service Task properties
image::kogito/bpmn/decisions/license-validation-drl-service-task-properties.png[Image of License Validation Service Task properties in process designer]

The input and output mapping for this task is just the driver variable that is filled with license validation information.


.License Validation Service Task data assignment
image::kogito/bpmn/decisions/license-drl-service-task-data-mapping.png[Image of License Validation Service Task data assignment in process designer]

====== **REST Work Item**

.License Validation REST Work Item
image::kogito/bpmn/decisions/license-validation-drl-wih.png[Image of License Validation Service Task in process designer]

The input and output mapping for this task is just the driver variable that is filled with license validation information. For REST Work Item the URL and HTTP Method are set as input parameters in the process itselt, that is differnt from the Service Task approach.

.License Validation REST Work Item data assignment
image::kogito/bpmn/decisions/license-validation-drl-wih-data-mapping.png[Image of License Validation Service Task data assignment in process designer]

===== Traffic Violation Task (DMN)
Similar to the License Validation Task, but it represents the task to do the call to the DMN service.

====== **Service Task**

.Traffic Violation Service Task
image::kogito/bpmn/decisions/traffic-violation-drl-service-task.png[Image of License Validation Service Task in process designer]

The implementation properties where it is necessary to set the Java class implementing the task that executes the call should be set alongside the method.

.Traffic Violation Service Task properties
image::kogito/bpmn/decisions/traffic-violation-drl-service-task-properties.png[Image of Traffic Violation Service Task properties in process designer]

The input for this task is the `Driver` and `Violation` variables, and the output is the `Suspended` and `Fine` that are wrapped into the `TrafficViolationResponse`.

.Traffic Violation Service Task data assignment
image::kogito/bpmn/decisions/traffic-violation-drl-service-task-data.png[Image of Traffic Violation Service Task data assignment in process designer]

====== **REST Work Item**

.Traffic Violation REST Work Item
image::kogito/bpmn/decisions/traffic-violation-drl-wih.png[Image of Traffic Violation REST Work Item in process designer]

The input for this task is the `Driver` and `Violation` variables, and the output is the `Suspended` and `Fine` that are wrapped into the `TrafficViolationResponse`. For REST Work Item the URL and HTTP Method are set as input parameters in the process itselt, that is different from the Service Task approach.

.Traffic Violation REST Work Item data assignment
image::kogito/bpmn/decisions/traffic-violation-drl-wih-data.png[Image of Traffic Violation REST Work Item data assignmentg in process designer]

===== Suspended Task
Just an example task where it could be performed any action based on the condition in which the driver is suspended. In the current implementation, it is just logging the information in the console.


===== Not Suspended Task
Just an example task where it could be performed any action based on the condition in which the driver is **not** suspended. In the current implementation, it is just logging the information in the console.

## Decisions

The decisions defined for the Traffic Process using REST are the same as defined in <<con_process-decisions-decisions-{context}>>.