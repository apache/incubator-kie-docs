[id='con_drl-rule-units_{context}']

= Rule units in DRL

A *rule unit* is both a _module_ for rules and a _unit of execution_ (hence the name). The reason why we do not use the term  "module" is to avoid confusion with "JVM modules". 

A rule unit collects a set of rules together with the declaration of the type of facts that such rules act upon. A rule unit also serves as a unique namespace for each group of rules. A single rule base can contain multiple units. You typically store all the rules for a unit in the same file as the unit declaration so that the unit is self-contained. 

In the following example, we will build a simple application that evaluates incoming data from a sensor (temperature measurements) and produces alerts when the temperature is above a given threshold.

In this case you create a DRL file under the `org/acme` directory under the resource folder (usually `src/main/resources`)
and declare the `Temperature` and the `Alert` data types like in the following example. The name of the file is irrelevant, but you may call it `types.drl`.

.Example rule unit class
[source]
----
package com.acme

declare Temperature 
  value: double 
end

declare Alert 
    severity: String
    message: String
end

----

Now, in order to write rules that pattern match against `Temperature` values, we need first to expose an ingress for the incoming data to the engine. We also want to publish alerts on a separate channel. We can do this by declaring a rule unit with a data source of `Temperature` objects and a data source of `Alert` objects. 

There are different types of data sources, with different features. A _data stream_ is an append-only store for incoming data (you can think of it as of a queue). In this case, because the temperature data is coming from an external source (the sensor), and because we are going to publish to the the alerts as they are produced to the outer world, it seems appropriate use a _data stream_ in both cases. 

The unit can be declared implementing the `RuleUnitData` interface. 
We can expose a `temperature` data stream using the following `MonitoringService` declaration under package `com.acme`.
We declare a DRL file called `MonitoringService.drl` and we put it under the resource directory and the `com/acme` subdirectories.


.Example rule unit class
[source]
----
package com.acme
unit MonitoringService

import org.kie.kogito.rules.DataSource
import org.kie.kogito.rules.DataStream

declare MonitoringService extends RuleUnitData 
  temperature: DataStream<Temperature> = DataSource.createStream()
  alertData: DataStream<Alert> = DataSource.createStream()
end
----

We can now write rules against the streams that we have declared. For instance, we can write a simple rule that raises an alert when temperature goes above a given threshold.  

.Example rule unit declaration in a DRL file
[source]
----
package com.acme
unit MonitoringService

declare MonitoringService extends RuleUnitData 
  temperature: DataStream<Temperature> = DataSource.createStream()
  alertData: DataStream<Alert> = DataSource.createStream()
end

rule tooHot
when
    temp : /temperature[value >= 80]
then
    alertData.append(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----

Conventionally, at least the "main" DRL file should be called like the type declaration. You may also add other type declarations to this file (such as `Temperature` and `Alert`), and you can add several rules to the same DRL file; but you can also further break down the rule set, by creating more files, as long as they reside in the same directory and they all start with the correct unit declaration:


.Example rule unit header of a DRL file
[source]
----
package com.acme
unit MonitoringService
----

== Data sources for rule units

Data sources are typed sources of data that can that rule units _subscribe_ for updates. Users interact with the rule unit through the data sources it exposes. Depending on its kind, different set of actions may be supported. Currently we support the following kind of data sources:

DataStream::
an append-only storage, rules may pattern match against incoming values and append new values: it is not possible to remove or notify the engine of updates of mutable datathat may be contained. It is the simplest kind of storage, thus it can be employed for a number of use cases, where values may have to be published or shared.
DataStore:: 
a writable storage where it is possible to add and remove data, and notify the engine that mutable data may have been updated. Rules may pattern match against incoming values and update and remove values that are contained. People familiar with Drools may effectively think of this as of the "classic" notion of entry point. In fact, a `DataStore<Object>` is effectively equivalent to an old-style entry point. 
SingletonStore:: 
a writable storage where it is possible to set and clear one single element, and notify the engine that the element has been mutated. Rules may pattern match against the value and update and clear values that are contained. People familiar with Drools may effectively think of this as of a global. In fact, a `Singleton<Object>` is similar to an old-style global, except it is possible to pattern match against it. 


== Declaring rule units using Java

It is also possible to declare types and units using Java.
In this case the source code would go as usual under `src/main/java` and it would look like this:

.Example Temperature class
[source,java]
----
package com.acme;

public class Temperature {
    private final double value;
    public Temperature(double value) { this.value = value; }
    public double getValue() { return value; }
}
----

.Example Alert class
[source,java]
----
package com.acme;

public class Alert {
    private final String severity;
    private final String message;
    public Temperature(String severity, String message) { 
        this.severity = severity; 
        this.message = message; 
    }
    public String getSeverity() { return severity; }
    public String getMessage() { return message; }
}
----

.Example rule unit class
[source,java]
----
package com.acme;

import org.kie.kogito.rules.DataSource;
import org.kie.kogito.rules.DataStream;

public class MonitoringService implements RuleUnitData {
    private DataStream<Temperature> temperature = DataSource.createStream();
    private DataStream<Alert> alertData = DataSource.createStream();
    public DataStream<Temperature> getTemperature() { return temperature; }
    public DataStream<Alert> getAlertData() { return alertData; }
}
----

Rules would be lone in their own DRL file under the `src/main/resources` folder; 
the `unit` declaration would be retained, but the DRL file would only include rules.

.Example rule unit declaration in a DRL file
[source]
----
package com.acme
unit MonitoringService

rule tooHot
when
    temp : /temperature[value >= 80]
then
    alertData.append(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----

== Rule units used with BPMN processes

If you use a DRL rule unit as part of a business rule task in a Business Process Model and Notation (BPMN) process in your {PRODUCT} project, you do not need to create an explicit rule unit class that implements the `RuleUnitData` interface. Instead, you designate the rule unit in the DRL file as usual and specify the rule unit in the format `unit:__PACKAGE_NAME__.__UNIT_NAME__` in the implementation details for the business rule task in the BPMN process. When you build the project, the business process implicitly declares the rule unit as part of the business rule task to execute the DRL file.

For example, the following is a DRL file with a rule unit designation:

.Example rule unit declaration in a DRL file
[source]
----
package com.acme
unit MonitoringService

rule tooHot
when
    temp : Temperature( value >= 80 ) from temperature
then
    alertData.add(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----

In the relevant business process in a BPMN 2.0 process modeler, you select the business rule task and for the *Implementation/Execution* property, you set the rule language to `DRL` and the rule flow group to `unit:com.acme.MonitoringService`.

This rule unit syntax in the *Rule Flow Group* field specifies that you are using the `com.acme.MonitoringService` rule unit instead of a traditional rule flow group. This is the rule unit that you referenced in the example DRL file. When you build the project, the business process implicitly declares the rule unit as part of the business rule task to execute the DRL file.


//@comment Maybe this should go in an entire section for Legacy pattern matching (evacchi 2020-03-16)
== Legacy Syntax

People familiar with Drools, will remember the pattern matching syntax. For legacy use cases, it is still possible to rewrite rules using pattern matching. In this case, you will have to explicitly indicate the data source using the `from` clause:

.Example rule unit declaration in a DRL file using traditional notation
[source]
----
package com.acme
unit MonitoringService

rule tooHot
when
    temp : Temperature( value >= 80 ) from temperature
then
    alertData.add(new Alert("HIGH", "Temperature exceeds threshold: " + temp.value));
end
----
