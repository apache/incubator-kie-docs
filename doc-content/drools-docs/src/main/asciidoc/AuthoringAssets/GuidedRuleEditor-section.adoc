
include::guided-rules-con.adoc[]

include::guided-rules-create-proc.adoc[leveloffset=+1]

include::guided-rules-WHEN-proc.adoc[leveloffset=+2]

include::guided-rules-THEN-proc.adoc[leveloffset=+2]

[[_drools.guidedruleeditordsl]]
== Augmenting with DSL sentences


If the package the rule is part of has a DSL configuration, when you add conditions or actions, then it will provide a list of "DSL Sentences" which you can choose from - when you choose one, it will add a row to the rule - where the DSL specifies values come from a user, then a edit box (text) will be shown (so it ends up looking a bit like a form). This is optional, and there is another DSL editor.
Please note that the DSL capabilities in this editor are slightly less than the full set of DSL features (basically you can do [when] and [then] sections of the DSL only - which is no different to drools 3 in effect).

The following diagram shows the DSL sentences in action in the guided editor:

.DSL in guided editor
image::Workbench/AuthoringAssets/GuidedDSL.png[align="center"]


include::guided-rules-options-proc.adoc[leveloffset=+1]

include::rules-attributes-ref.adoc[leveloffset=+2]


[[_drools.guidedruleeditorcomplexexample]]
== A more complex example:

.A more complex BRL example
image::Workbench/AuthoringAssets/GuidedComplex.png[align="center"]


In the previous example, you can see how to use a mixture of Conditional Elements, literal values, and formulas.
The rule has 4 "top level" Patterns and 1 Action.
The "top level" Patterns are:

. A Fact Pattern on Person. This Pattern contains two field constraints: one for birthDate field and the other one is a formula. Note that the value of the birthDate restriction is selected from a calendar. Another thing to note is that you can make calculations and use nested fields in the formula restriction (i.e. car.brand). Finally, we are setting a variable name ($p) to the Person Fact Type. You can then use this variable in other Patterns.
+

[NOTE]
====
The generated DRL from this Pattern will be:

[source]
----
$p : Person( birthDate < "19-Dec-1982" , eval( car.brand == "Ford" && salary > (2500 * 4.1) ))
----
====
. A From Pattern. This condition will create a match for every Address whose street name is "Elm St." from the Person's list of addresses. The left side of the from is a regular Fact Pattern and the right side is an Expression Builder that let us inspect variable's fields.
+

[NOTE]
====
The generated DRL from this Pattern will be: `Address( street == "Elm St." ) from
          $p.addresses`
====
. A "Not Exist" Conditional Element. This condition will match when its content doesn't create a match. In this case, its content is a regular Fact Pattern (on Person). In this Fact Pattern you can see how variables ($p) could be used inside a formula value.
+

[NOTE]
====
The generated DRL from this Pattern will be: `not Person( salary == ( $p.salary * 2 )
          )`
====
. A "From Accumulate" Conditional Element. This is maybe one of the most complex Patterns you can use. It consist in a Left Pattern (It must be a Fact Pattern. In this case is a Number Pattern. The Number is named $totalAddresses), a Source Pattern (Which could be a Fact Pattern, From, Collect or Accumulate conditional elements. In this case is an Address Pattern Restriction with a field restriction in its zip field) and a Formula Section where you can use any built-in or custom Accumulate Function (in this example a count() function is used). Basically, this Conditional Element will count the addresses having a zip code of 43240 from the Person's list of addresses.
+

[NOTE]
====
The generated DRL from this Pattern will be: `$totalAddresses : Number() from accumulate ( $a : Address( zipCode == " 43240" ) from $p.addresses, count( $a ) )`
====
