[id='pmml-usage']
== Using KIE-PMML Generated Rules
Because the rules generated by kie-pmml require the usage of specific RuleUnit derived classes;
and because the rules expect a specific set of objects to work with, applying a model isn't quite
as easy as starting up a KieSession, inserting some data, and saying fireAllRules.

Instead, the rules are executed using a RuleUnitExecutor. The RuleUnitExecutor takes care of creating sessions and
tying the necessary DataSource objects to those sessions. Finally, as the name implies, it executes the rules
based on the RuleUnit that is passed as a parameter to the `_run()_` method.

.Example of using PMML-based rules without helper
[source,java]
----
public void executeModel(KieBase kbase,
                         Map<String,Object> variables,
                         String modelName,
                         String correlationId,
                         String modelPkgName) {
  RuleUnitExecutor executor = RuleUnitExecutor.create().bind(kbase);
  PMMLRequestData request = new PMMLRequestData(correlationId, modelName);
  PMML4Result resultHolder = new PMML4Result(correlationId);
  variables.entrySet().forEach( es -> {
    request.addRequestParam(es.getKey(), es.getValue());
  });

  DataSource<PMMLRequestData> requestData = executor.newDataSource("request");
  DataSource<PMML4Result> resultData = executor.newDataSource("results");
  DataSource<PMMLData> internalData = executor.newDataSource("pmmlData");

  requestData.insert(request);
  resultData.insert(resultHolder);

  List<String> possiblePackageNames = calculatePossiblePackageNames(modelName,
                                                                    modelPkgName);
  Class<? extends RuleUnit> ruleUnitClass = getStartingRuleUnit("RuleUnitIndicator",
                                                                (InternalKnowledgeBase)kbase,
                                                                possiblePackageNames);

  if (ruleUnitClass != null) {
    executor.run(ruleUnitClass);
    if ( "OK".equals(resultHolder.getResultCode()) ) {
      // extract result variables here
    }
  }
}
----

As illustrated in the above sample code, using the PMML based rules can be complex;
and that's for a very simple use-case. But don't get discouraged, there is some good news!
There are a number of helper classes to make using the rules easier.

Before we dig into the helper classes, though, let's cover some of the basic PMML-related classes
that are used in applying PMML based rules.

== Requests and Results
There are two classes that are absolutely necessary for interacting with the rules, PMMLRequestData and PMML4Result.

.PMMLRequestData
To ask the rule engine to apply your model to a set of data, you need to create an instance of PMMLRequestData.
[source,java]
----
public class PMMLRequestData {
    private String correlationId; // <1>
    private String modelName; // <2>
    private String source; // <3>
    private List<ParameterInfo<?>> requestParams; // <4>
    ...
}
----
<1> Identifies data that is associated with a particular request/result
<2> The name of the model that should be applied to the request data
<3> Used by internally generated PMMLRequestData objects, to identify the segment that generated the request
<4> The default mechanism for sending input data points

.PMML4Result
The PMML4Result object is used to hold the output information that is the result
of applying the PMML based rules to the input data.
[source,java]
----
public class PMML4Result {
    private String correlationId;
    private String segmentationId; // <1>
    private String segmentId; // <2>
    private int segmentIndex; // <3>
    private String resultCode; // <4>
    private Map<String, Object> resultVariables; // <5>
    ...
}
----
<1> When the underlying model was of type MiningModel, the segmentationId is used to differentiate between Segmentations. Multiple Segmentations occur when a Segment within a MiningModel contains a model of type MiningModel
<2> Used in conjunction with the segmentationId to identify which Segment generated the results
<3> Used to maintain ordering of Segments
<4> Used to determine whether the model was successfully applied. A value of "OK" indicates success.
<5> Contains the name of a resultant variable, and its associated value.

In addition to the normal getter methods, the PMML4Result provides a couple of methods for
directly retrieving the values for result variables. +
[.small]`public <T> Optional<T> getResultValue(String objName, String objField, Class<T> clazz, Object...params)` +
and +
[.small]`public Object getResultValue(String objName, String objField, Object...params)`

.ParameterInfo
This is the wrapper for basic data type objects that are being used as part of a PMMLRequestData.
[source,java]
----
public class ParameterInfo<T> { // <1>
    private String correlationId;
    private String name; // <2>
    private String capitalizedName;
    private Class<T> type; // <3>
    private T value; // <4>
    ...
}
----
<1> Note that the class is parameterized so that it can handle many different types
<2> The name of the variable that is expected as input for the model
<3> The class that is the actual type of the variable
<4> The actual value of the variable

== Helper Classes
As promised, there are some classes to assist in creating the required PMMLRequestData object, and also
to help fire off the rules using the required RuleExecutor.
