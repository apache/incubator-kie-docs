[id='pmml-usage']
== Using KIE-PMML Generated Rules
Because the rules generated by kie-pmml require the usage of specific RuleUnit derived classes;
and because the rules expect a specific set of objects to work with, applying a model isn't quite
as easy as starting up a KieSession, inserting some data, and saying fireAllRules.

Instead, the rules are executed using a RuleUnitExecutor. The RuleUnitExecutor takes care of creating sessions and
tying the necessary DataSource objects to those sessions. Finally, as the name implies, it executes the rules
based on the RuleUnit that is passed as a parameter to the `_run()_` method.

.Example of using PMML-based rules without helper
[source,java]
----
public void executeModel(KieBase kbase,
                         Map<String,Object> variables,
                         String modelName,
                         String correlationId,
                         String modelPkgName) {
  RuleUnitExecutor executor = RuleUnitExecutor.create().bind(kbase);
  PMMLRequestData request = new PMMLRequestData(correlationId, modelName);
  PMML4Result resultHolder = new PMML4Result(correlationId);
  variables.entrySet().forEach( es -> {
    request.addRequestParam(es.getKey(), es.getValue());
  });

  DataSource<PMMLRequestData> requestData = executor.newDataSource("request");
  DataSource<PMML4Result> resultData = executor.newDataSource("results");
  DataSource<PMMLData> internalData = executor.newDataSource("pmmlData");

  requestData.insert(request);
  resultData.insert(resultHolder);

  List<String> possiblePackageNames = calculatePossiblePackageNames(modelName, // <1>
                                                                    modelPkgName);
  Class<? extends RuleUnit> ruleUnitClass = getStartingRuleUnit("RuleUnitIndicator", // <2>
                                                                (InternalKnowledgeBase)kbase,
                                                                possiblePackageNames);

  if (ruleUnitClass != null) {
    executor.run(ruleUnitClass);
    if ( "OK".equals(resultHolder.getResultCode()) ) {
      // extract result variables here
    }
  }
}
----
<1> For the purpose of this example the `calculatePossiblePackageNames` method is assumed to belong to
the same class as our `executeModel` method.
<2> For the purpose of this example the `getStartingRuleUnit` method is assumed to belong to the same
class as our `executeModel` method.

As illustrated in the above sample code, using the PMML based rules can be complex;
and that's for a very simple use-case. But don't get discouraged, there is some good news!
There are a number of helper classes to make using the rules easier.

Before we dig into the helper classes, though, let's cover some of the basic PMML-related classes
that are used in applying PMML based rules.

== Requests and Results
There are two classes that are absolutely necessary for interacting with the rules, PMMLRequestData and PMML4Result.

.PMMLRequestData
To ask the rule engine to apply your model to a set of data, you need to create an instance of PMMLRequestData.
[source,java]
----
public class PMMLRequestData {
    private String correlationId; // <1>
    private String modelName; // <2>
    private String source; // <3>
    private List<ParameterInfo<?>> requestParams; // <4>
    ...
}
----
<1> Identifies data that is associated with a particular request/result
<2> The name of the model that should be applied to the request data
<3> Used by internally generated PMMLRequestData objects, to identify the segment that generated the request
<4> The default mechanism for sending input data points

.PMML4Result
The PMML4Result object is used to hold the output information that is the result
of applying the PMML based rules to the input data.
[source,java]
----
public class PMML4Result {
    private String correlationId;
    private String segmentationId; // <1>
    private String segmentId; // <2>
    private int segmentIndex; // <3>
    private String resultCode; // <4>
    private Map<String, Object> resultVariables; // <5>
    ...
}
----
<1> Used when the model type is MiningModel; the segmentationId is used to differentiate between multiple Segmentations
<2> Used in conjunction with the segmentationId to identify which Segment generated the results
<3> Used to maintain ordering of Segments
<4> Used to determine whether the model was successfully applied. A value of "OK" indicates success.
<5> Contains the name of a resultant variable, and its associated value.

In addition to the normal getter methods, the PMML4Result provides a couple of methods for
directly retrieving the values for result variables. +
[.small]`public <T> Optional<T> getResultValue(String objName, String objField, Class<T> clazz, Object...params)` +
and +
[.small]`public Object getResultValue(String objName, String objField, Object...params)`

.ParameterInfo
This is the wrapper for basic data type objects that are being used as part of a PMMLRequestData.
[source,java]
----
public class ParameterInfo<T> { // <1>
    private String correlationId;
    private String name; // <2>
    private String capitalizedName;
    private Class<T> type; // <3>
    private T value; // <4>
    ...
}
----
<1> Note that the class is parameterized so that it can handle many different types
<2> The name of the variable that is expected as input for the model
<3> The class that is the actual type of the variable
<4> The actual value of the variable

== Helper Classes
As promised, there are some classes to assist in creating the required PMMLRequestData object, and also
to help fire off the rules using the required RuleUnitExecutor.

.PMML4ExecutionHelper
This class is at the core of making PMML derived rules easier to use. In the above example code, the
developer needed to construct and manage the RuleUnitExecutor, all of the data sources, and the input and output
data objects. The PMML4ExecutionHelper abstracts much of this away.

.Sample using PMML4PMML4ExecutionHelper
[source,java]
----
public void executeModel(KieBase kbase,
                         Map<String,Object> variables,
                         String modelName,
                         String modelPkgName,
                         String correlationId) {
   PMML4ExecutionHelper helper = PMML4ExecutionHelperFactory.getExecutionHelper(modelName, kbase);
   helper.addPossiblePackageName(modelPkgName);

   PMMLRequestData request = new PMMLRequestData(correlationId, modelName);
   variables.entrySet().forEach(entry -> {
     request.addRequestParam(entry.getKey(), entry.getValue);
   });

   PMML4Result resultHolder = helper.submitRequest(request);
   if ("OK".equals(resultHolder.getResultCode)) {
     // extract result variables here
   }
}
----
[NOTE]
When using the PMML4ExecutionHelper, it is no longer necessary for the developer to figure out the possible package names, nor the RuleUnit class

.PMML4ExecutionHelperFactory
This factory class is the only way to construct a PMML4ExecutionHelper.
Below are the methods provided by this factory class, for getting an instance of PMML4ExecutionHelper.

[source,java]
----
public static PMML4ExecutionHelper getExecutionHelper(String modelName, KieBase kbase)

public static PMML4ExecutionHelper getExecutionHelper(String modelName, KieBase kbase, boolean includeMiningDataSources)
----
This first pair are useful when the PMML resource has already been compiled and is being used from an existing KieBase.


[source,java]
----
public static PMML4ExecutionHelper getExecutionHelper(String modelName,  String classPath, KieBaseConfiguration kieBaseConf)

public static PMML4ExecutionHelper getExecutionHelper(String modelName,String classPath, KieBaseConfiguration kieBaseConf, boolean includeMiningDataSources)
----
This second pair of methods is the first of the "on-the-fly" mechanisms for using a PMML resource that is not already part of a KieBase.
The `classPath` should point to a PMML file that is on the project's classpath.


[source,java]
----
public static PMML4ExecutionHelper getExecutionHelper(String modelName, byte[] content, KieBaseConfiguration kieBaseConf)

public static PMML4ExecutionHelper getExecutionHelper(String modelName, byte[] content, KieBaseConfiguration kieBaseConf, boolean includeMiningDataSources)
----
Like the previous pair of methods, this set of methods allows "on-the-fly" usage of a PMML resource. In this case, the resource is expected to be in the
form of a byte array.


[source,java]
----
public static PMML4ExecutionHelper getExecutionHelper(String modelName, Resource resource, KieBaseConfiguration kieBaseConf)

public static PMML4ExecutionHelper getExecutionHelper(String modelName, Resource resource, KieBaseConfiguration kieBaseConf, boolean includeMiningDataSources)
----
Finally, this pair of methods makes use of a PMML resource, that is in the form of an `org.kie.api.io.Resource` object, to allow
"on-the-fly" usage.

[NOTE]
All of the "on-the-fly" methods create a KieContainer for the generated rules and Java classes.
The container is used as the source of the KieBase that the RuleUnitExecutor uses. The container
does not get persisted.
