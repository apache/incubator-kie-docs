= House of doom (backward chaining)

A backward chaining rule system is goal-driven so starts with a conclusion which the engine tries to satisfy often using recursion. If it cannot do so it searches for sub-goals, that is, conclusions that will complete part of the current goal. It continues this process until either the initial conclusion is satisfied or there are no more unsatisfied sub-goals.

----
Name: House of doom
Main class: org.drools.examples.backwardchaining.HouseOfDoomMain
Module: drools-examples
Type: Java application
Rules file: BC-Example.drl
Objective: Demonstrate backward chaining and recursion
----

.Backward chaining chart
image::Examples/BackwardChaining/BackwardChainingChart.png[align="center"]


== Reasoning graph

The reasoning graph consists of the following:

1. 
The `Location` class; it has the `item` and the item's `location`.

2. 
The `Location` data inserted for the house example as depicted below:

[source,java]
----
ksession.insert( new Location("Office", "House") );
ksession.insert( new Location("Kitchen", "House") );
ksession.insert( new Location("Knife", "Kitchen") );
ksession.insert( new Location("Cheese", "Kitchen") );
ksession.insert( new Location("Desk", "Office") );
ksession.insert( new Location("Chair", "Office") );
ksession.insert( new Location("Computer", "Desk") );
ksession.insert( new Location("Drawer", "Desk") );
----

.Reasoning graph of a house
image::Examples/BackwardChaining/TransitiveReasoningGraph.png[align="center"]


== Recursive query

1. 
This is the query to look at the data inserted into the {ENGINE}: 

[source]
----
query isContainedIn( String x, String y )
  Location( x, y; )
  or
  ( Location( z, y; ) and isContainedIn( x, z; ) )
end
----

Notice how the query is recursive and is calling `isContainedIn`.

2. 
A rule to print out every string inserted into the system to see how things are implemented:

[source]
----
rule "go" salience 10
when
  $s : String( )
then
  System.out.println( $s );
end
----

3. 
A rule that calls upon the query `isContainedIn`:

[source]
----
rule "go1"
when
    String( this == "go1" )
    isContainedIn("Office", "House"; )
then
    System.out.println( "Office is in the House" );
end
----

The `go1` rule will fire when the "go1" string is inserted into the engine. That is, it asks if the item "Office" is in the location "House". Therefore, the query is evoked by the previous rule when the "go1" string is inserted.

4. 
The "go1" string is inserted it into the engine and `fireAllRules` is called.

.Insert string and fire rules
[source]
----
ksession.insert( "go1" );
ksession.fireAllRules();
----

.Rule output
[source]
----
go1
Office is in the House
----


== Transitive closure

1. 
A transitive closure by implementing the following rule:

[source]
----
rule "go2"
when
    String( this == "go2" )
    isContainedIn("Drawer", "House"; )
then
    System.out.println( "Drawer is in the House" );
end
----

2. 
Recall from the reasoning graph that there is no instance of "Drawer" directly in "House". "Drawer" was located in "Desk".

.Transitive Reasoning Graph of a Drawer
image::Examples/BackwardChaining/TransitiveReasoningGraph2.png[align="center"]

3. 
The "go2" string is inserted it into the engine and `fireAllRules` is called.

.Insert string and fire rules
[source]
----
ksession.insert( "go2" );
ksession.fireAllRules();
----

.Rule output
[source]
----
go2
Drawer is in the House
----

4. 
Understand how the engine determined this outcome:

* The query has to recurse down several levels to determine this.
* Instead of using `Location( x, y; )`, The query uses the value of `(z, y; )` since "Drawer" is not in "House".
* The `z` is currently unbound which means it has no value and will return everything that is in the argument.
* `y` is currently bound to "House", so `z` will return "Office" and "Kitchen".
* Information is gathered from "Office" and checks recursively if the "Drawer" is in the "Office". The following query line is being called for these parameters: `isContainedIn( x, z; )`
* There is no instance of "Drawer" in "Office"; therefore, it does not match.
* With `z` being unbound, it will return data that is within the "Office," and it will gather that *z == Desk*.

[source]
----
isContainedIn(x==drawer, z==desk)
----

`isContainedIn` recurses three times. On the final recurse, an instance triggers of "Drawer" in the "Desk".

[source]
----
Location(x==drawer, y==desk)
----

This matches on the first location and recurses back up, so we know that "Drawer" is in the "Desk," the "Desk" is in the "Office," and the "Office" is in the "House;" therefore, the "Drawer" is in the "House" and returns true.


== Reactive queries

1. 
A reactive query is implemented by the following rule:

[source]
----
rule "go3"
when
    String( this == "go3" )
    isContainedIn("Key", "Office"; )
then
    System.out.println( "Key is in the Office" );
end
----

A rule can ask a question even if the answer can not currently be satisfied. Later, if it is satisfied, it will return an answer.

2. 
The "go3" string is inserted it into the engine and `fireAllRules` is called.

.Insert string and fire rules
[source]
----
ksession.insert( "go3" );
ksession.fireAllRules();
----

.Rule output
[source]
----
go3
----

The first rule that matches any String returns "go3" but nothing else is returned because there is no answer; however, while "go3" is inserted in the system, it will continuously wait until it is satisfied.

3. 
Insert a new location of "Key" in the "Drawer":

.Insert location and fire rules
[source]
----
ksession.insert( new Location("key", "drawer") );
ksession.fireAllRules();
----

.Rule output
[source]
----
Key is in the Office
----

This new location satisfies the transitive closure because it is monitoring the entire graph. In addition, this process now has four recursive levels in which it goes through to match and fire the rule.


== Queries with unbound arguments

1. 
A query with unbound arguments by implementing the following rule:

[source]
----
rule "go4"
when
  String( this == "go4" )
  isContainedIn(thing, "office"; )
then
  System.out.println( thing + "is in the Office" );
end
----

This rule is asking for everything in the "Office," and it will tell everything in all the rows below. The unbound argument (variable thing) in this example will return every possible value.

2. 
The "go4" string is inserted it into the engine and `fireAllRules` is called.

.Insert string and fire rules
[source]
----
ksession.insert( "go4" );
ksession.fireAllRules();
----

.Rule output
[source]
----
go4
Chair is in the Office
Desk is in the Office
Key is in the Office
Computer is in the Office
Drawer is in the Office
----


== Multiple unbound arguments

1. 
A query with multiple unbound arguments is implemented by the following rule:

[source]
----
rule "go5"
when
    String( this == "go5" )
    isContainedIn(thing, location; )
then
    System.out.println(thing + " is in " + location );
end
----

Both `thing` and `location` are unbound variables, and without bound arguments, everything is called upon.

2. 
The "go5" string is inserted it into the engine and `fireAllRules` is called.

.Insert string and fire rules
[source]
----
ksession.insert( "go5" );
ksession.fireAllRules();
----

.Rule output
[source]
----
go5
Chair is in Office
Desk is in Office
Drawer is in Desk
Key is in Drawer
Kitchen is in House
Cheese is in Kitchen
Knife is in Kitchen
Computer is in Desk
Office is in House
Key is in Office
Drawer is in House
Computer is in House
Key is in House
Desk is in House
Chair is in House
Knife is in House
Cheese is in House
Computer is in Office
Drawer is in Office
Key is in Desk
----

When "go5" is called, it returns everything within everything.
