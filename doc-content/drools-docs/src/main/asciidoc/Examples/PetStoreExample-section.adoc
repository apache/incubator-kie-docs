= Pet Store Example

The Pet Store example demonstrates the following rule execution concepts: Agenda Groups, Global Variables and integration with a GUI. This will also demonstrate using auto-focus to control which of a set of rules is allowed to fire at any given time. This example will also use both Java and MVEL dialects within the rules, the use of accumulate functions and a way of calling Java functions from within the ruleset itself. 

[source]
----
Name: Pet Store 
Main class: org.drools.examples.petstore.PetStoreExample
Module: drools-examples
Type: Java application
Rules file: PetStore.drl
Objective: Demonstrate use of Agenda Groups, Global Variables and integration with a GUI,
including callbacks from within the rules
----

== Background on the PetStore.java application

The Pet Store example shows how to integrate Rules with a GUI, in this case a Swing based desktop application.
Within the rules file, it demonstrates how to use Agenda groups and auto-focus to control which set of rules is allowed to fire at any given time.
The example also illustrates the mixing of the Java and MVEL dialects within the rules, the use of `accumulate` functions and a way of calling Java functions from within a ruleset.

All of the Java code is contained in one file, [path]_PetStore.java_, which you can be ran as a Java application from command line or your IDE. _PetStore.java_ defines the following principal classes (in addition to several classes to handle Swing Events):

* `Petstore` contains the `main()` method that you will look at shortly.
* `PetStoreUI` is responsible for creating and displaying the Swing based GUI. It contains several smaller classes, mainly for responding to various GUI events such as mouse button clicks.
* `TableModel` holds the table data. Think of it as a JavaBean that extends the Swing class ``AbstractTableModel``.
* `CheckoutCallback` allows the GUI to interact with the Rules.
* `Ordershow` keeps the items that you wish to buy.
* `Purchase` stores details of the order and the products you are buying.
* `Product` is a JavaBean holding details of the product available for purchase, and its price.


Much of the Java code in this example is either plain JavaBeans or Swing-based.
Only a few Swing-related points will be discussed in this section, but a good tutorial about Swing components can be found at Sun's Swing website, in http://java.sun.com/docs/books/tutorial/uiswing/.

=== Fact insertion

The pieces of Java code in [path]_Petstore.java_
 that relate to rules and facts are shown below.

.Creating the Pet Store KieContainer in PetStore.main
====
[source,java]
----
// KieServices is the factory for all KIE services 
KieServices ks = KieServices.Factory.get();

// From the kie services, a container is created from the classpath
KieContainer kc = ks.getKieClasspathContainer();

// Create the stock.
Vector<Product> stock = new Vector<Product>();
stock.add( new Product( "Gold Fish", 5 ) );
stock.add( new Product( "Fish Tank", 25 ) );
stock.add( new Product( "Fish Food", 2 ) );

// A callback is responsible for populating the
// Working Memory and for firing all rules.
PetStoreUI ui = new PetStoreUI( stock,
                                new CheckoutCallback( kc ) );
ui.createAndShowGUI();
----
====


The code shown above creates a `KieContainer` from the classpath and based on the definitions in the [path]_kmodule.xml_
 file.

=== Rule execution
Unlike other examples where the facts are asserted and fired straight away, this example holds execution of the rules until more facts are gathered/interaction with the user.
The way it does this is via the second-to-last line where a `PetStoreUI` object is created using a constructor accepting the `Vector` object `stock` collecting our products, and an instance of the `CheckoutCallback` class containing the Rule Base that you just loaded.

The Java code that fires the rules is found within the  `CheckoutCallBack.checkout()` method.
This is triggered when you press the `Checkout` button which then executes ksession.fireAllRules(), which executes all of the rule set.

.Firing the Rules - extract from CheckoutCallBack.checkout()
====
[source,java]
----
public String checkout(JFrame frame, List<Product> items) {
    Order order = new Order();

    // Iterate through list and add to cart
    for ( Product p: items ) {
        order.addItem( new Purchase( order, p ) );
    }

    // Add the JFrame to the ApplicationData to allow for user interaction

    // From the container, a session is created based on  
    // its definition and configuration in the META-INF/kmodule.xml file 
    KieSession ksession = kcontainer.newKieSession("PetStoreKS");

    ksession.setGlobal( "frame", frame );
    ksession.setGlobal( "textArea", this.output );

    ksession.insert( new Product( "Gold Fish", 5 ) );
    ksession.insert( new Product( "Fish Tank", 25 ) );
    ksession.insert( new Product( "Fish Food", 2 ) );

    ksession.insert( new Product( "Fish Food Sample", 0 ) );

    ksession.insert( order );
    ksession.fireAllRules(); <1>

    // Return the state of the cart
    return order.toString();
}
----
<1> The execution of the rules occurs with this method.
====


Two items get passed into this method.
One is the handle to the `JFrame` Swing component surrounding the output text frame, found at the bottom of the GUI.
The second is a list of order items; this comes from the `TableModel` storing the information from the `Table` area at the top right section of the GUI.

The `for` loop transforms the list of order items coming from the GUI into the `Order` JavaBean, also contained in the file [path]_PetStore.java_.

NOTE: You can refer to the Swing dataset directly within the rules, but it is better coding practice to do it this way, using simple Java objects.
This means that you are not tied to Swing if you wanted to transform the sample into a Web application. This gives you more externalization of the rule execution process making it easier in later iterations to grow the application as required.

It is important to note that this rule is firing in a stateless state as all of the data is stored in Swing components and will not be executed until you press the checkout button. Each time the `Checkout` button is pressed, the contents of the list gets moved from the Swing `TableModel` into the Session's Working Memory and is then executed with the ksession.fireAllRules() method.

Within this code, there are nine calls to the `KieSession`.
The first of these creates a new `KieSession` from the `KieContainer`.
Remember that you passed in this `KieContainer` when you created the `CheckoutCallBack` class in the `main()` method.
The next two calls pass in the two objects that hold the global variables in the rules: the Swing text area and the Swing frame used for writing messages.

More inserts put information on products into the `KieSession`, as well as the order list.
The final call is the standard `fireAllRules()`.

=== Exploring PetStore.drl

Next, you can look at what the `fireAllRules()` method causes to happen within the rules file, _PetStore.drl_ when it is called. First you will look at the imports and global variables and then 

==== Imports and global variable definitions

The first part of file [path]_PetStore.drl_
 contains the standard package and import statements to make various Java classes available to the rules.
This provides a new concept called _global variables_ for use within the rules, which are defined as  `frame` and `textArea`.
The global variables hold references to the Swing components `JFrame` and `JTextArea` components that were previously passed on by the Java code calling the `setGlobal()` method.
Unlike variables in rules, which expire as soon as the rule has fired, global variables retain their value for the lifetime of the Session. This means the contents of these global variables are available for evaluation on _all_ subsequent rules.

==== 

.Package, Imports, Globals and Dialect: extract from PetStore.drl
====
[source,java]
----
package org.drools.examples

import org.kie.api.runtime.KieRuntime
import org.drools.examples.petstore.PetStoreExample.Order
import org.drools.examples.petstore.PetStoreExample.Purchase
import org.drools.examples.petstore.PetStoreExample.Product
import java.util.ArrayList
import javax.swing.JOptionPane;

import javax.swing.JFrame 
        
global JFrame frame <1>
global javax.swing.JTextArea textArea <2>


----
<1> Defines the global variable `frame`
<2> Defines the global variable `textArea`
====


==== Defining Java functions for business rule use

The next extract from the file [path]_PetStore.drl_
 contains two functions that are referenced by the rules that you will look at shortly.

.Java Functions in the Rules: extract from PetStore.drl
====
[source,java]
----
function void doCheckout(JFrame frame, KieRuntime krt) {
        Object[] options = {"Yes",
                            "No"};
                            
        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to checkout?",
                                             "",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);

       if (n == 0) {
            krt.getAgenda().getAgendaGroup( "checkout" ).setFocus();
       }   
}

function boolean requireTank(JFrame frame, KieRuntime krt, Order order, Product fishTank, int total) {
        Object[] options = {"Yes",
                            "No"};
                            
        int n = JOptionPane.showOptionDialog(frame,
                                             "Would you like to buy a tank for your " + total + " fish?",
                                             "Purchase Suggestion",
                                             JOptionPane.YES_NO_OPTION,
                                             JOptionPane.QUESTION_MESSAGE,
                                             null,
                                             options,
                                             options[0]);
                                             
       System.out.print( "SUGGESTION: Would you like to buy a tank for your "
                           + total + " fish? - " );

       if (n == 0) {
             Purchase purchase = new Purchase( order, fishTank );
             krt.insert( purchase );
             order.addItem( purchase );
             System.out.println( "Yes" );
       } else {
            System.out.println( "No" );
       }      
       return true;
}
----
====


Having all of the rules and functions within the same file makes it easier to read for this example. In a typical deployment this would not be the case, as you would separate different functions/rules into different files or also build a static Java method and import them using the import function, e.g. `import function my.package.Foo.hello`.
The two functions do the following:

* `doCheckout()` displays a dialog asking users whether they wish to checkout. If they do, focus is set to the `checkout` agenda-group, allowing rules in that group to (potentially) fire.
* `requireTank()` displays a dialog asking users whether they wish to buy a tank. If so, a new fish tank `Product` is added to the order list in Working Memory.

==== Business rule examples
You'll see the rules that call these functions later on.
The next set of examples are from the Pet Store rules themselves.
The first extract is the one that happens to fire first, partly because it has the `auto-focus` attribute set to true.

===== "Explode Cart" rule

.Putting items into working memory: extract from PetStore.drl
====
[source]
----
// Insert each item in the shopping cart into the Working Memory 
// Insert each item in the shopping cart into the Working Memory
rule "Explode Cart"
    agenda-group "init"
    auto-focus true
    salience 10
    dialect "java"
when
    $order : Order( grossTotal == -1 )
    $item : Purchase() from $order.items
then
    insert( $item );
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "show items" ).setFocus();
    kcontext.getKnowledgeRuntime().getAgenda().getAgendaGroup( "evaluate" ).setFocus();
end
----
====


This rule matches against all orders that do not yet have their `grossTotal` calculated. The execution loops for each purchase item in that order.
Some parts of the `Explode Cart` rule should be familiar: the rule name, the salience (suggesting the order for the rules being fired) and the dialect set to ``"java"``.
There are three new features:

* `agenda-group "init"` defines the name of the agenda group. In this case, there is only one rule in the group. However, neither the Java code nor a rule consequence sets the focus to this group, and therefore it relies on the next attribute for its chance to fire.
* `auto-focus```true`` ensures that this rule, while being the only rule in the agenda group, gets a chance to fire when `fireAllRules()` is called from the Java code.
* `kcontext....setFocus()` sets the focus to the `"show items"` and `"evaluate"` agenda groups in turn, permitting their rules to fire. In practice, you loop through all items on the order, inserting them into memory, then firing the other rules after each insert.


===== Looking at the agenda-group "show items"
The next two listings show the rules within the `"show items"` and `"evaluate"` agenda groups.
You can look at them in the order that they are called.

.Show Items in the GUI - extract from PetStore.drl
====
[source]
----
rule "Show Items"
    agenda-group "show items"
    dialect "mvel"
when
    $order : Order( )
    $p : Purchase( order == $order )
then
   textArea.append( $p.product + "\n");
end
----
====


The `"show items"` agenda-group has only one rule, called `"Show Items"` (note the difference in case as these are different). For each purchase on the order currently in the Working Memory (or Session), it logs details to the text area at the bottom of the GUI.
The `textArea` variable used to do this is one of the global variables you created earlier.

===== Looking at the agenda-group "evaluate"

The `evaluate` Agenda group also gains focus from the `"Explode Cart"` rule listed previously.
This Agenda group has two rules, `"Free Fish Food Sample"` and `"Suggest Tank"`, shown below in their own examples. The order that they execute by default will be `Free Fish Food Sample` and then `Suggest Tank` and this is how these rules will be explained in more detail below.

.Evaluate Agenda Group: extract from PetStore.drl
====
[source]
----
// Free Fish Food sample when we buy a Gold Fish if we haven't already bought 
// Fish Food and don't already have a Fish Food Sample
rule "Free Fish Food Sample"
    agenda-group "evaluate" <1>
    dialect "mvel"
when
    $order : Order()
    not ( $p : Product( name == "Fish Food") &amp;&amp; Purchase( product == $p ) ) <2>
    not ( $p : Product( name == "Fish Food Sample") &amp;&amp; Purchase( product == $p ) ) <3>
    exists ( $p : Product( name == "Gold Fish") &amp;&amp; Purchase( product == $p ) ) <4>
    $fishFoodSample : Product( name == "Fish Food Sample" );
then
    System.out.println( "Adding free Fish Food Sample to cart" );
    purchase = new Purchase($order, $fishFoodSample);
    insert( purchase );
    $order.addItem( purchase ); 
end

----

The rule `"Free Fish Food Sample"` will only fire if all of the following are true:

<1> You are currently evalualting the Agenda group `"evaluate"` in the rules execution
<2>  You __don't __already have any fish food, _and_ 
<3> You _don't_ already have a free fish food sample, _and_
<4> You _do_ have a Gold Fish in your order. 

If your order's facts all meet the requirements, then a new product will be created (Fish Food Sample) and adds it to the order in Working Memory.

[source]
----

// Suggest a tank if we have bought more than 5 gold fish and don't already have one
rule "Suggest Tank"
agenda-group "evaluate"
    dialect "java"
when
    $order : Order()
    not ( $p : Product( name == "Fish Tank") &amp;&amp; Purchase( product == $p ) ) <1>
    ArrayList( $total : size &gt; 5 ) from collect( Purchase( product.name == "Gold Fish" ) ) <2>
    $fishTank : Product( name == "Fish Tank" )
then
    requireTank(frame, kcontext.getKieRuntime(), $order, $fishTank, $total); 
end

----
The rule `"Suggest Tank` will follow the same pattern:

<1> You do not have a fish tank in your order _and_
<2> You have more than 5 fish in your order



====
If the rule does fire, it calls the `requireTank()` function that you looked at earlier (showing a Dialog box to the user, and adding a Tank to the order / working memory if confirmed). When calling the __requireTank__() function the rule passes the global _frame_ variable so that the function has a handle to the Swing GUI.tion that you looked at earlier (showing a Dialog box to the user, and adding a Tank to the order / working memory if confirmed). When calling the __requireTank__() function the rule passes the global _frame_ variable so that the function has a handle to the Swing GUI.

===== The "do checkout" rule

The next rule to look at is `"do checkout"`. Which will always execute due to its structure of omitting the use of a `when` statement.

.Doing the Checkout - extract (6) from PetStore.drl
====
[source]
----
rule "do checkout"
    dialect "java"
    when
    then
        doCheckout(frame, kcontext.getKieRuntime());
end
----
====


The rule `"do checkout"` has **no
      agenda group set and no auto-focus attribute**. Due to not having an agenda or auto-focus, the `do checkout` rule is deemed part of the default (MAIN) agenda group.
This group gets focus by default when all the rules in agenda-groups that explicitly had focus set/defined to them have run been evaluated against.

There is no when statement (Left Hand Side, LHS) to the rule, so the then statement (Right Hand Side, RHS) will always execute and thus call the `doCheckout()` function.
When calling the `doCheckout()` function, the rule passes the global `frame` variable to give the function a handle to the Swing GUI.
As you saw earlier, the `doCheckout()` function shows a confirmation dialog to the user.
If confirmed, the function sets the focus to the _checkout_ agenda-group, allowing the next sequence of rules to fire.

A good troubleshooting practice with rule execution is if results are not executing as you expect, is to remove the conditions from the `when` statement and test the action in the `then` statement to verify the action is behaving as expected.

.Checkout Rules: extract from PetStore.drl
====
[source]
----
rule "Gross Total"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal == -1)
   Number( total : doubleValue )
       from accumulate( Purchase( $price : product.price ), sum( $price ) )
then
    modify( $order ) { grossTotal = total };
    textArea.append( "\ngross total=" + total + "\n" );
end

rule "Apply 5% Discount"
    agenda-group "checkout"
dialect "mvel"
when
   $order : Order( grossTotal &gt;= 10 &amp;&amp; &lt; 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.95;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end


rule "Apply 10% Discount"
    agenda-group "checkout"
    dialect "mvel"
when
   $order : Order( grossTotal &gt;= 20 )
then
   $order.discountedTotal = $order.grossTotal * 0.90;
   textArea.append( "discountedTotal total=" + $order.discountedTotal + "\n" );
end
----
====

===== The "checkout" agenda-group

There are three rules in the _checkout_ agenda-group:

* If you haven't already calculated the gross total, `Gross Total` accumulates the product prices into a total, puts this total into the session, and displays it via the Swing `JTextArea`, using the `textArea` global variable.
* If your gross total is between 10 and 20, `"Apply 5% Discount"` calculates the discounted total and adds it to the session and displays it in the text area.
* If your gross total is not less than 20, `"Apply 10% Discount"` calculates the discounted total and adds it to the session and displays it in the text area.


Now that you have run through what happens in the code, have a look at what happens when you actually run the code.
The file [path]_PetStore.java_
 contains a `main()` method, so that it can be run as a standard Java application, either from the command line or via the IDE through a `Run As => Java Application`.
This assumes you have your classpath set correctly.
(See the start of the examples section for more information.)

The first screen that you see is the Pet Store Demo.
It has a list of available products (top left), an empty list of selected products (top right), checkout and reset buttons (middle) and an empty system messages area (bottom).

.PetStore Demo just after Launch
image::Examples/PetStoreExample/1-PetStore-Start-Screen.png[align="center"]

====== Summary of PetStore.java steps
To get to this point, the following things have happened:

. The `main()` method has run and loaded the Rule Base __but not yet fired the rules__. So far, this is the only code in connection with rules that has been run.
. A new `PetStoreUI` object has been created and given a handle to the Rule Base, for later use.
. Various Swing components do their functions, and the above screen is shown and __waits for your user input__.


==== Running the Pet Store example

To start the example over again, run PetStore.java in your preferred method. Once the GUI is loaded, you can click on various products from the list might give you a screen similar to the one below.

.PetStore Demo with Products Selected
image::Examples/PetStoreExample/2-stock-added-to-order-list.png[align="center"]


Note that __no rules code has been fired here__.
This is only Swing code, listening for mouse click events, and adding some selected product to the `TableModel` object for display in the top right hand section.
(As an aside, note that this is a classic use of the Model View Controller design pattern).

It is only when you press the "Checkout" button that you fire the business rules, in roughly the same order that you walked through the code earlier.

. Method `CheckOutCallBack.checkout()` is called (eventually) by the Swing class waiting for the click on the "Checkout" button. This inserts the data from the `TableModel` object (top right hand side of the GUI), and inserts it into the Session's Working Memory. It then fires the rules.
. The `"Explode Cart"` rule is the first to fire, given that it has `auto-focus` set to true. It loops through all the products in the cart, ensures that the products are in the Working Memory, and then gives the `show Items` and `evaluate` agenda groups a chance to fire. The rules in these groups add the contents of the cart to the text area (at the bottom of the window), evaluate if you're eligible for free fish food, and to ask you whether you want to buy a fish tank. This is shown in the figure below.


.Do you want to buy a fish tank?
image::Examples/PetStoreExample/3-purchase-suggestion.png[align="center"]


. The _Do Checkout_ rule is the next to fire as it (a) No other agenda group currently has focus and (b) it is part of the default (MAIN) agenda group. It always calls the__ doCheckout() function __which displays a 'Would you like to Checkout?' Dialog Box.
. The `doCheckout()` function sets the focus to the `checkout` agenda-group, giving the rules in that group the option to fire.
. The rules in the the `checkout` agenda-group display the contents of the cart and apply the appropriate discount.
. _Swing then waits for user input_ to either checkout more products (and to cause the rules to fire again), or to close the GUI - see the figure below.


.Petstore Demo after all rules have fired.
image::Examples/PetStoreExample/4-Petstore-final-screen.png[align="center"]


You could add more System.out calls to demonstrate this flow of events.
The output, as it currently appears in the Console window, is given in the listing below.

.Console (System.out) from running the PetStore GUI
====
[source]
----
Adding free Fish Food Sample to cart 
SUGGESTION: Would you like to buy a tank for your 6 fish? - Yes
----